{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ERB documentation","text":""},{"location":"#introduzione","title":"Introduzione","text":"<p>Questa documentazione raccoglie tutte le informazioni necessarie per comprendere e lavorare sul progetto della centralina di controllo della macchina. \u00c8 pensata sia per i membri esperti del team sia per i nuovi ragazzi che iniziano a collaborare: fornisce quindi spiegazioni passo per passo, a partire dalle basi del linguaggio C fino ad arrivare ai dettagli di firmware, hardware e schede elettroniche.</p>"},{"location":"#obiettivi-della-documentazione","title":"Obiettivi della documentazione","text":"<ul> <li>Offrire una panoramica chiara del progetto nella sua interezza.  </li> <li>Fornire materiale di formazione per i nuovi membri, senza dare nulla per scontato.  </li> <li>Creare un manuale di riferimento tecnico per lo sviluppo e la manutenzione.  </li> <li>Centralizzare tutte le informazioni in un unico posto facilmente consultabile.  </li> </ul>"},{"location":"#cosa-troverai-in-queste-pagine","title":"Cosa troverai in queste pagine","text":"<ol> <li> <p>Fondamenti di programmazione in C    Per chi non ha mai programmato o ha bisogno di ripasso.  </p> </li> <li> <p>Embedded e microcontrollore    Spiegazione del funzionamento di un microcontrollore e degli strumenti di sviluppo.  </p> </li> <li> <p>FreeRTOS    Introduzione al sistema operativo real-time usato nel firmware.  </p> </li> <li> <p>Architettura software    Struttura del progetto: task, FSM, logging, parser CAN.  </p> </li> <li> <p>Hardware e schede elettroniche    Panoramica della centralina, dei sensori e delle altre PCB.  </p> </li> <li> <p>Comunicazioni    CAN bus, UART e telemetria.  </p> </li> <li> <p>Guide pratiche    Esempi passo per passo per aggiungere nuove funzionalit\u00e0 al sistema.  </p> </li> </ol>"},{"location":"#destinatari","title":"Destinatari","text":"<p>Questa documentazione \u00e8 rivolta a: - Studenti e nuovi membri del team che devono imparare da zero. - Chi si occupa di sviluppo software e firmware. - Chi lavora sull\u2019hardware o sull\u2019integrazione dei sistemi.  </p>"},{"location":"#come-utilizzare-la-documentazione","title":"Come utilizzare la documentazione","text":"<p>Ti consigliamo di partire dalla sezione Fondamenti di C, per poi proseguire con le parti embedded e gradualmente arrivare alle implementazioni specifiche della macchina. Ogni capitolo \u00e8 indipendente e pu\u00f2 essere letto anche separatamente come riferimento tecnico.</p>"},{"location":"codice/centralina/","title":"Centralina","text":"<p>Questa sezione documenta il software sviluppato per la centralina.</p>"},{"location":"codice/centralina/#architettura-generale","title":"Architettura generale","text":"<p>Il codice \u00e8 organizzato in pi\u00f9 moduli, ciascuno con responsabilit\u00e0 precise:</p> <ul> <li>CAN controller: codifica e decodifica di messaggi sulla linea CAN.</li> <li>ADC controller: gestisce i sensori analogici.</li> <li>Digital I/O: per ingressi e uscite digitali.</li> <li>Hall sensors: legge i sensori a effetto Hall.</li> <li>Inverter: comunicazione con inverter e motori</li> <li>Telemetry: formatta i messaggi di telemetria e li mette in coda per essere spediti su una periferica a scelta.</li> <li>Ticker: sincronizza le task periodiche come la lettura dei sensori o l'esecuzione della macchina a stati dell'inverter.</li> <li>Tractive system manager: gestisce la macchina a stati complessiva della macchina e fornisce le autorizzazioni per accendere gli inverter.</li> </ul>"},{"location":"codice/centralina/#freertos","title":"FreeRTOS","text":"<p>FreeRTOS \u00e8 un sistema operativo real-time open source progettato per microcontrollori. Offre meccanismi per:</p> <ul> <li>Creare e gestire task che vengono eseguiti in modo concorrente.</li> <li>Sincronizzare l\u2019esecuzione tramite code, semafori e mutex.</li> <li>Pianificare attivit\u00e0 periodiche con timer software.</li> </ul> <p>Il suo utilizzo permette di strutturare il firmware in moduli indipendenti e ben organizzati, migliorando la scalabilit\u00e0 e la manutenibilit\u00e0 del progetto.</p>"},{"location":"codice/centralina/#macchine-a-stati","title":"Macchine a stati","text":"<p>Le FSM sono implementate in C utilizzando la struttura <code>switch-case</code>. Ogni stato rappresenta una fase di funzionamento, ad esempio:</p> <pre><code>switch (state) {\n    case INIT:\n        // Inizializzazione\n        break;\n    case RUN:\n        // Esecuzione principale\n        break;\n    case ERROR:\n        // Gestione errori\n        break;\n}\n</code></pre>"},{"location":"codice/centralina/#logging","title":"Logging","text":"<p>Il logging \u00e8 gestito tramite UART con code di output. Caratteristiche principali:</p> <ul> <li>Supporto a pi\u00f9 livelli di log (INFO, WARN, ERROR).</li> <li>Invio asincrono dei messaggi.</li> </ul> <p>Esempio di utilizzo:</p> <pre><code>LOG_INFO(\"Sistema inizializzato correttamente\");\nLOG_ERROR(\"Errore durante la trasmissione CAN\");\n</code></pre>"},{"location":"codice/centralina/#comunicazioni","title":"Comunicazioni","text":""},{"location":"codice/centralina/#can","title":"CAN","text":"<ul> <li>Supporto a due linee can.</li> <li>Callback per la gestione asincrona dei messaggi.</li> </ul>"},{"location":"codice/centralina/#uart","title":"UART","text":"<ul> <li>Utilizzata per logging e debug.</li> <li>Interfaccia DMA per migliorare le prestazioni.</li> </ul>"},{"location":"codice/centralina/#moduli-futuri","title":"Moduli futuri","text":"<ul> <li>Telemetria: invio dati in tempo reale a un server esterno.</li> <li>Strategie di controllo avanzate: da integrare in base agli sviluppi del progetto.</li> </ul>"},{"location":"codice/sintassi_base_c/","title":"Sintassi base del C","text":"<p>Il linguaggio C \u00e8 alla base dello sviluppo embedded: \u00e8 semplice, efficiente e permette un controllo diretto sull\u2019hardware. In questa sezione vediamo le fondamenta che servono per scrivere e capire il codice della centralina.</p>"},{"location":"codice/sintassi_base_c/#variabili","title":"Variabili","text":"<p>Una variabile \u00e8 uno spazio di memoria a cui diamo un nome e che contiene un valore.</p> <p>\u26a0\ufe0f Nota per l\u2019embedded: \u00c8 sempre consigliato evitare l\u2019allocazione dinamica con funzioni come <code>malloc()</code> o <code>alloca()</code>. Negli ambienti a risorse limitate (come i microcontrollori) queste chiamate possono causare memory leak, frammentazione o corruzione della memoria. Meglio usare variabili globali, statiche o allocate nello stack, che garantiscono maggiore stabilit\u00e0 e prevedibilit\u00e0.</p>"},{"location":"codice/sintassi_base_c/#dichiarazione","title":"Dichiarazione","text":"<pre><code>int numero;        // variabile intera\nfloat temperatura; // variabile con virgola\nchar lettera;      // variabile carattere\n````\n\n### Inizializzazione\n\n```c\nint numero = 10;\nfloat temperatura = 36.5;\nchar lettera = 'A';\n</code></pre>"},{"location":"codice/sintassi_base_c/#regole-sui-nomi","title":"Regole sui nomi","text":"<ul> <li>Devono iniziare con lettera o <code>_</code></li> <li>Possono contenere lettere, numeri e <code>_</code></li> <li>Sono case-sensitive (<code>variabile</code> \u2260 <code>Variabile</code>)</li> </ul>"},{"location":"codice/sintassi_base_c/#tipi-di-dato-principali","title":"Tipi di dato principali","text":""},{"location":"codice/sintassi_base_c/#interi","title":"Interi","text":"<ul> <li><code>int</code> \u2192 intero base (dimensione dipende dal compilatore, spesso 32 bit)</li> <li><code>short</code> \u2192 intero corto (16 bit)</li> <li><code>long</code> \u2192 intero lungo (32 o 64 bit)</li> <li><code>unsigned</code> \u2192 versione senza segno (solo positivi)</li> </ul> <p>Esempio:</p> <pre><code>int a = -10;\nunsigned int b = 20;\n</code></pre>"},{"location":"codice/sintassi_base_c/#numeri-decimali","title":"Numeri decimali","text":"<ul> <li><code>float</code> \u2192 virgola mobile a 32 bit (circa 6-7 cifre decimali)</li> <li><code>double</code> \u2192 virgola mobile a 64 bit (circa 15-16 cifre decimali)</li> </ul> <p>Esempio:</p> <pre><code>float x = 3.14f;\ndouble y = 2.718281828;\n</code></pre>"},{"location":"codice/sintassi_base_c/#caratteri","title":"Caratteri","text":"<ul> <li><code>char</code> \u2192 memorizza un singolo carattere (es. 'A', 'b', '1')</li> <li>In realt\u00e0 \u00e8 un numero intero (ASCII)</li> </ul> <pre><code>char c = 'A';  // ASCII 65\n</code></pre>"},{"location":"codice/sintassi_base_c/#booleani","title":"Booleani","text":"<p>In C puro non esisteva, ma da C99 si pu\u00f2 usare, bisogna includere la libreria <code>stdbool.h</code>:</p> <pre><code>#include &lt;stdbool.h&gt;\n\nbool flag = true;\n</code></pre> <p>Reminder: C \\(\\ne\\) C++, la libreria standard C \u00e8 definita da file chiamati <code>&lt;libreria&gt;.h</code> e non <code>&lt;libreria&gt;</code> e basta, bisogna mettere il .h </p>"},{"location":"codice/sintassi_base_c/#costanti","title":"Costanti","text":"<p>Una costante \u00e8 un valore che non cambia.</p> <pre><code>const float PI = 3.14159;\n#define MAX_VALORE 100\n</code></pre> <ul> <li><code>const</code> \u2192 variabile costante</li> <li><code>#define</code> \u2192 macro gestita dal preprocessore</li> </ul>"},{"location":"codice/sintassi_base_c/#operatori","title":"Operatori","text":""},{"location":"codice/sintassi_base_c/#aritmetici","title":"Aritmetici","text":"<pre><code>+   // addizione\n-   // sottrazione\n*   // moltiplicazione\n/   // divisione\n%   // resto (solo interi)\n</code></pre>"},{"location":"codice/sintassi_base_c/#relazionali","title":"Relazionali","text":"<pre><code>==  // uguale\n!=  // diverso\n&gt;   // maggiore\n&lt;   // minore\n&gt;=  // maggiore o uguale\n&lt;=  // minore o uguale\n</code></pre>"},{"location":"codice/sintassi_base_c/#logici","title":"Logici","text":"<pre><code>&amp;&amp;  // AND logico\n||  // OR logico\n!   // NOT logico\n</code></pre>"},{"location":"codice/sintassi_base_c/#operatori-bitwise","title":"Operatori bitwise","text":"<pre><code>&lt;&lt;  // left shift\n&gt;&gt;  // right shift\n</code></pre>"},{"location":"codice/sintassi_base_c/#puntatori","title":"Puntatori","text":"<p>Un puntatore \u00e8 una variabile che contiene l\u2019indirizzo di memoria di un\u2019altra variabile. Sono fondamentali in C perch\u00e9 permettono di accedere direttamente alla memoria, alle periferiche e ai registri.</p>"},{"location":"codice/sintassi_base_c/#dichiarazione_1","title":"Dichiarazione","text":"<pre><code>int x = 10;\nint *p = &amp;x;   // p contiene l\u2019indirizzo di x\n</code></pre>"},{"location":"codice/sintassi_base_c/#utilizzo","title":"Utilizzo","text":"<pre><code>printf(\"Valore di x: %d\\n\", x);   // stampa 10\nprintf(\"Indirizzo di x: %p\\n\", &amp;x);\nprintf(\"Valore tramite puntatore: %d\\n\", *p); // stampa 10\n</code></pre> <ul> <li><code>&amp;x</code> \u2192 indirizzo della variabile <code>x</code></li> <li><code>*p</code> \u2192 valore contenuto all\u2019indirizzo puntato da <code>p</code></li> </ul>"},{"location":"codice/sintassi_base_c/#puntatori-e-array","title":"Puntatori e array","text":"<p>Un array \u00e8 strettamente legato ai puntatori.</p> <pre><code>int numeri[3] = {1, 2, 3};\nint *ptr = numeri;\n\nprintf(\"%d\\n\", *ptr);       // 1\nprintf(\"%d\\n\", *(ptr + 1)); // 2\n</code></pre>"},{"location":"codice/sintassi_base_c/#puntatori-a-char-e-stringhe","title":"Puntatori a <code>char</code> e stringhe","text":"<p>In C una stringa \u00e8 un array di <code>char</code> terminato da <code>\\0</code>.</p> <pre><code>char saluto[] = \"Ciao\";\nchar *p = saluto;\n\nprintf(\"%s\\n\", p);   // stampa \"Ciao\"\n</code></pre>"},{"location":"codice/sintassi_base_c/#tipi-definiti-dallutente","title":"Tipi definiti dall\u2019utente","text":""},{"location":"codice/sintassi_base_c/#struct","title":"<code>struct</code>","text":"<p>Serve per raggruppare variabili diverse in un\u2019unica entit\u00e0.</p> <pre><code>struct Sensore {\n    int id;\n    float valore;\n};\n\nstruct Sensore s1 = {1, 23.5};\n</code></pre>"},{"location":"codice/sintassi_base_c/#typedef","title":"<code>typedef</code>","text":"<p>Permette di creare alias per tipi pi\u00f9 leggibili.</p> <pre><code>typedef unsigned int uint32_t;\n\nuint32_t counter = 100;\n</code></pre>"},{"location":"codice/sintassi_base_c/#riassunto","title":"Riassunto","text":"<ul> <li>Le variabili sono spazi di memoria con un nome e un tipo.</li> <li>I tipi principali: <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>bool</code>.</li> <li>Gli operatori permettono di fare calcoli e confronti.</li> <li>I puntatori gestiscono indirizzi di memoria e sono fondamentali nell\u2019embedded.</li> <li><code>struct</code> e <code>typedef</code> aiutano a organizzare meglio i dati.</li> </ul>"},{"location":"codice/visibilit%C3%A0_delle_variabili/","title":"Visibilit\u00e0 e organizzazione del codice in C","text":"<p>Oltre a sapere cos\u2019\u00e8 una variabile, \u00e8 fondamentale capire dove \u00e8 visibile e come organizzare i file in un progetto embedded.</p>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#file-c-e-h","title":"File <code>.c</code> e <code>.h</code>","text":"<p>In un progetto in C i file sono generalmente divisi in due categorie:</p> <ul> <li>File <code>.c</code> \u2192 contengono il codice implementativo (funzioni, logica).  </li> <li>File <code>.h</code> \u2192 contengono le dichiarazioni (prototipi di funzioni, definizioni di strutture, costanti, variabili globali).  </li> </ul>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#esempio","title":"Esempio","text":"<p>sensore.h</p> <pre><code>#ifndef SENSORE_H\n#define SENSORE_H\n\nvoid sensore_init(void);\nint sensore_leggi(void);\n\n#endif\n````\n\n**sensore.c**\n\n```c\n#include \"sensore.h\"\n\nvoid sensore_init(void) {\n    // inizializzazione hardware\n}\n\nint sensore_leggi(void) {\n    return 42; // valore di esempio\n}\n</code></pre> <p>Cos\u00ec il modulo <code>sensore</code> pu\u00f2 essere usato anche da altri file senza duplicare il codice.</p>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#visibilita-delle-variabili","title":"Visibilit\u00e0 delle variabili","text":"<p>La visibilit\u00e0 definisce in quali file o funzioni una variabile \u00e8 accessibile.</p>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#variabili-locali","title":"Variabili locali","text":"<p>Dichiarate dentro una funzione \u2192 visibili solo l\u00ec, allocate nello stack.</p> <pre><code>void funzione() {\n    int x = 10; // visibile solo dentro questa funzione\n}\n</code></pre>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#variabili-globali","title":"Variabili globali","text":"<p>Dichiarate fuori da ogni funzione \u2192 visibili in tutto il file <code>.c</code>.</p> <pre><code>int contatore = 0; // visibile in tutto il file\n</code></pre> <p>Se vogliamo usarle anche da altri file \u2192 serve la parola chiave <code>extern</code> nell\u2019header.</p> <pre><code>// in main.c\nint contatore = 0;\n\n// in sensore.h\nextern int contatore;\n</code></pre>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#il-ruolo-di-static","title":"Il ruolo di <code>static</code>","text":"<p>La parola chiave <code>static</code> ha due significati diversi a seconda del contesto.</p>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#1-variabili-locali-statiche","title":"1. Variabili locali statiche","text":"<p>Mantengono il loro valore tra pi\u00f9 chiamate della funzione.</p> <pre><code>void funzione() {\n    static int chiamate = 0;\n    chiamate++;\n    printf(\"%d\\n\", chiamate);\n}\n</code></pre> <p>Ogni volta che chiamo <code>funzione()</code>, la variabile non si azzera ma \u201cricorda\u201d il valore precedente.</p>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#2-variabili-e-funzioni-a-livello-di-file","title":"2. Variabili e funzioni a livello di file","text":"<p>Limitano la visibilit\u00e0 al solo file <code>.c</code> (non esportate).</p> <pre><code>static int interno = 5;\n\nstatic void helper() {\n    // usata solo in questo file\n}\n</code></pre> <p>Questo \u00e8 molto utile per l\u2019incapsulamento: evitiamo che variabili o funzioni \u201cinterne\u201d inquinino lo spazio globale del progetto.</p>"},{"location":"codice/visibilit%C3%A0_delle_variabili/#buone-pratiche","title":"Buone pratiche","text":"<ul> <li>Le variabili devono essere il pi\u00f9 locali possibile.</li> <li>Le globali vanno usate solo se davvero necessarie.</li> <li>Usare <code>static</code> per tutto ci\u00f2 che \u00e8 interno a un modulo (<code>.c</code>).</li> <li>Negli header <code>.h</code> mettere solo:<ul> <li>prototipi delle funzioni pubbliche,</li> <li>definizioni di costanti/struct/enum,</li> <li>dichiarazioni <code>extern</code> se serve condividere una variabile globale.</li> </ul> </li> </ul> <p>Cos\u00ec il progetto rimane ordinato, modulare e pi\u00f9 facile da manutenere.</p>"}]}