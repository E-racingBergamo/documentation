{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ERB documentation","text":""},{"location":"#introduzione","title":"Introduzione","text":"<p>Questa documentazione raccoglie tutte le informazioni necessarie per comprendere e lavorare sul progetto della centralina di controllo della macchina. \u00c8 pensata sia per i membri esperti del team sia per i nuovi ragazzi che iniziano a collaborare: fornisce quindi spiegazioni passo per passo, a partire dalle basi del linguaggio C fino ad arrivare ai dettagli di firmware, hardware e schede elettroniche.</p>"},{"location":"#obiettivi-della-documentazione","title":"Obiettivi della documentazione","text":"<ul> <li>Offrire una panoramica chiara del progetto nella sua interezza.  </li> <li>Fornire materiale di formazione per i nuovi membri, senza dare nulla per scontato.  </li> <li>Creare un manuale di riferimento tecnico per lo sviluppo e la manutenzione.  </li> <li>Centralizzare tutte le informazioni in un unico posto facilmente consultabile.  </li> </ul>"},{"location":"#cosa-troverai-in-queste-pagine","title":"Cosa troverai in queste pagine","text":"<ol> <li> <p>Fondamenti di programmazione in C    Per chi non ha mai programmato o ha bisogno di ripasso.  </p> </li> <li> <p>Embedded e microcontrollore    Spiegazione del funzionamento di un microcontrollore e degli strumenti di sviluppo.  </p> </li> <li> <p>FreeRTOS    Introduzione al sistema operativo real-time usato nel firmware.  </p> </li> <li> <p>Architettura software    Struttura del progetto: task, FSM, logging, parser CAN.  </p> </li> <li> <p>Hardware e schede elettroniche    Panoramica della centralina, dei sensori e delle altre PCB.  </p> </li> <li> <p>Comunicazioni    CAN bus, UART e telemetria.  </p> </li> <li> <p>Guide pratiche    Esempi passo per passo per aggiungere nuove funzionalit\u00e0 al sistema.  </p> </li> </ol>"},{"location":"#destinatari","title":"Destinatari","text":"<p>Questa documentazione \u00e8 rivolta a:</p> <ul> <li>Studenti e nuovi membri del team che devono imparare da zero.  </li> <li>Chi si occupa di sviluppo software e firmware.  </li> <li>Chi lavora sull\u2019hardware o sull\u2019integrazione dei sistemi.  </li> </ul>"},{"location":"#come-utilizzare-la-documentazione","title":"Come utilizzare la documentazione","text":"<p>Ti consigliamo di partire dalla sezione Fondamenti di C, per poi proseguire con le parti embedded e gradualmente arrivare alle implementazioni specifiche della macchina. Ogni capitolo \u00e8 indipendente e pu\u00f2 essere letto anche separatamente come riferimento tecnico.</p>"},{"location":"codice/centralina/","title":"Centralina","text":"<p>Questa sezione documenta il software sviluppato per la centralina.</p>"},{"location":"codice/centralina/#architettura-generale","title":"Architettura generale","text":"<p>Il codice \u00e8 organizzato in pi\u00f9 moduli, ciascuno con responsabilit\u00e0 precise:</p> <ul> <li>CAN controller: codifica e decodifica di messaggi sulla linea CAN.</li> <li>ADC controller: gestisce i sensori analogici.</li> <li>Digital I/O: per ingressi e uscite digitali.</li> <li>Hall sensors: legge i sensori a effetto Hall.</li> <li>Inverter: comunicazione con inverter e motori</li> <li>Telemetry: formatta i messaggi di telemetria e li mette in coda per essere spediti su una periferica a scelta.</li> <li>Ticker: sincronizza le task periodiche come la lettura dei sensori o l'esecuzione della macchina a stati dell'inverter.</li> <li>Tractive system manager: gestisce la macchina a stati complessiva della macchina e fornisce le autorizzazioni per accendere gli inverter.</li> </ul>"},{"location":"codice/centralina/#freertos","title":"FreeRTOS","text":"<p>FreeRTOS \u00e8 un sistema operativo real-time open source progettato per microcontrollori. Offre meccanismi per:</p> <ul> <li>Creare e gestire task che vengono eseguiti in modo concorrente.</li> <li>Sincronizzare l\u2019esecuzione tramite code, semafori e mutex.</li> <li>Pianificare attivit\u00e0 periodiche con timer software.</li> </ul> <p>Il suo utilizzo permette di strutturare il firmware in moduli indipendenti e ben organizzati, migliorando la scalabilit\u00e0 e la manutenibilit\u00e0 del progetto.</p>"},{"location":"codice/centralina/#macchine-a-stati","title":"Macchine a stati","text":"<p>Le FSM sono implementate in C utilizzando la struttura <code>switch-case</code>. Ogni stato rappresenta una fase di funzionamento, ad esempio:</p> <pre><code>switch (state) {\n    case INIT:\n        // Inizializzazione\n        break;\n    case RUN:\n        // Esecuzione principale\n        break;\n    case ERROR:\n        // Gestione errori\n        break;\n}\n</code></pre>"},{"location":"codice/centralina/#logging","title":"Logging","text":"<p>Il logging \u00e8 gestito tramite UART con code di output. Caratteristiche principali:</p> <ul> <li>Supporto a pi\u00f9 livelli di log (INFO, WARN, ERROR).</li> <li>Invio asincrono dei messaggi.</li> </ul> <p>Esempio di utilizzo:</p> <pre><code>LOG_INFO(\"Sistema inizializzato correttamente\");\nLOG_ERROR(\"Errore durante la trasmissione CAN\");\n</code></pre>"},{"location":"codice/centralina/#comunicazioni","title":"Comunicazioni","text":""},{"location":"codice/centralina/#can","title":"CAN","text":"<ul> <li>Supporto a due linee can.</li> <li>Callback per la gestione asincrona dei messaggi.</li> </ul>"},{"location":"codice/centralina/#uart","title":"UART","text":"<ul> <li>Utilizzata per logging e debug.</li> <li>Interfaccia DMA per migliorare le prestazioni.</li> </ul>"},{"location":"codice/centralina/#moduli-futuri","title":"Moduli futuri","text":"<ul> <li>Telemetria: invio dati in tempo reale a un server esterno.</li> <li>Strategie di controllo avanzate: da integrare in base agli sviluppi del progetto.</li> </ul>"},{"location":"codice/lezioni_di_c/funzioni/","title":"Funzioni e modularit\u00e0","text":"<p>Le funzioni sono blocchi di codice riutilizzabili che eseguono un compito specifico. La loro corretta progettazione \u00e8 fondamentale per la modularit\u00e0 di un progetto, soprattutto in ambienti embedded dove il firmware viene suddiviso in moduli separati e ben organizzati.</p>"},{"location":"codice/lezioni_di_c/funzioni/#dichiarazione-e-definizione","title":"Dichiarazione e definizione","text":"<p>Una funzione si dichiara indicando il tipo di ritorno, il nome e i parametri:</p> <pre><code>int somma(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>Qui <code>somma</code> prende due interi e restituisce un intero. Il tipo di ritorno pu\u00f2 essere qualsiasi tipo valido: <code>int</code>, <code>float</code>, <code>char</code>, <code>struct</code>, oppure <code>void</code> se non deve restituire nulla.</p>"},{"location":"codice/lezioni_di_c/funzioni/#parametri-per-valore-e-per-riferimento","title":"Parametri per valore e per riferimento","text":"<ul> <li>Per valore: viene passata una copia della variabile, modifiche dentro la funzione non influenzano l\u2019originale.</li> <li>Per riferimento: si passa l\u2019indirizzo della variabile tramite un puntatore, e quindi la funzione pu\u00f2 modificare l\u2019originale.</li> </ul> <pre><code>void incrementa_valore(int x) {\n    x++;\n}\n\nvoid incrementa_riferimento(int *x) {\n    (*x)++;\n}\n</code></pre> <p>In questo caso il simbolo <code>*</code> viene chiamato operatore di dereference, che consente di modificare direttamente il valore della variabile a partire dal suo puntatore. Se nel secondo caso si facesse <code>x++</code> si andrebbe ad incrementare il puntatore alla variabile, rischiando di andare oltre la sua area di memoria con operazioni successive e corrompere altre variabili o funzioni.</p>"},{"location":"codice/lezioni_di_c/funzioni/#tipi-di-funzioni","title":"Tipi di funzioni","text":"<ol> <li>Funzioni con ritorno e parametri <pre><code>int moltiplica(int a, int b) {\n    return a * b;\n}\n</code></pre></li> <li>Funzioni senza parametri <pre><code>int leggi_sensore(void) {\n    return 42;\n}\n</code></pre></li> <li>Funzioni senza ritorno (<code>void</code>) <pre><code>void stampa_valore(int v) {\n    printf(\"%d\\n\", v);\n}\n</code></pre></li> <li>Funzioni inline     Suggeriscono al compilatore di espandere la funzione al posto della chiamata (ottimizzazione). In poche parole la funzione viene copiata al posto della chiamata. E' consigliabile usarlo solo con funzioni piccole, cio\u00e8 che fanno una semplice operazione aritmetica o chiamata a funzione.     <pre><code>inline int quadrato(int x) {\n    return x * x;\n}\n</code></pre></li> <li>Funzioni static     Se dichiarate <code>static</code> a livello di file <code>.c</code>, la loro visibilit\u00e0 \u00e8 limitata solo a quel file, impedendo che siano richiamabili da altri moduli.     <pre><code>static void reset_interno(void) {\n    // codice interno\n}\n</code></pre></li> </ol> <p>E utile conoscere anche la combinazione di static e inline, che permette al compilatore di poter scegliere quando utilizzare inline o quando invece serve avere una definizione della funzione vera e propria.</p>"},{"location":"codice/lezioni_di_c/funzioni/#modularita-con-file-c-e-h","title":"Modularit\u00e0 con file <code>.c</code> e <code>.h</code>","text":"<p>Per mantenere il codice ordinato:</p> <ul> <li>nel file <code>.c</code> si mettono le definizioni delle funzioni,</li> <li>nel file <code>.h</code> si mettono i prototipi (cio\u00e8 la firma senza corpo).</li> </ul> <p>Esempio:</p> <p>math_utils.h</p> <pre><code>#ifndef MATH_UTILS_H\n#define MATH_UTILS_H\n\nint somma(int a, int b);\nint moltiplica(int a, int b);\n\n#endif\n</code></pre> <p>math_utils.c</p> <pre><code>#include \"math_utils.h\"\n\nint somma(int a, int b) {\n    return a + b;\n}\n\nint moltiplica(int a, int b) {\n    return a * b;\n}\n</code></pre> <p>Cos\u00ec gli altri moduli possono includere <code>math_utils.h</code> e usare le funzioni senza conoscere l\u2019implementazione.</p>"},{"location":"codice/lezioni_di_c/funzioni/#puntatori-a-funzioni","title":"Puntatori a funzioni","text":"<p>In C \u00e8 possibile memorizzare l\u2019indirizzo di una funzione in una variabile, e poi richiamarla attraverso questa. Questo meccanismo \u00e8 molto utile per callback e per realizzare codice flessibile.</p> <pre><code>int somma(int a, int b) { return a + b; }\nint moltiplica(int a, int b) { return a * b; }\n\nint calcola(int (*operazione)(int, int), int x, int y) {\n    return operazione(x, y);\n}\n\nint main(void) {\n    int r1 = calcola(somma, 2, 3);\n    int r2 = calcola(moltiplica, 2, 3);\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/funzioni/#typedef-per-puntatori-a-funzioni","title":"Typedef per puntatori a funzioni","text":"<p>Scrivere i prototipi di puntatori a funzioni pu\u00f2 diventare complicato, per questo si usa <code>typedef</code>.</p> <pre><code>typedef int (*Operazione)(int, int);\n\nint calcola(Operazione op, int x, int y) {\n    return op(x, y);\n}\n</code></pre> <p>Questo approccio \u00e8 molto comune in embedded, ad esempio per definire callback da registrare in un driver.</p>"},{"location":"codice/lezioni_di_c/funzioni/#lambda-in-c","title":"Lambda in C","text":"<p>Il C standard non supporta le lambda (funzioni anonime inline) come C++ o altri linguaggi. Alcuni compilatori (come GCC) offrono estensioni che permettono funzioni nidificate, ma non sono portabili e non sono consigliate in un progetto embedded.</p> <p>Per simulare lambde, in C si usano:</p> <ul> <li>puntatori a funzioni,</li> <li>funzioni statiche locali al file,</li> <li>closure manuali con struct che raggruppano stato e puntatore a funzione.</li> </ul>"},{"location":"codice/lezioni_di_c/funzioni/#funzioni-avanzate","title":"Funzioni avanzate","text":"<p>Ricorsione Una funzione ricorsiva \u00e8 una funzione che chiama se stessa per risolvere un problema pi\u00f9 grande suddividendolo in sottoproblemi pi\u00f9 semplici. Un esempio classico \u00e8 il calcolo del fattoriale:</p> <pre><code>int fattoriale(int n) {\n    if (n &lt;= 1)\n        return 1;\n    else\n        return n * fattoriale(n - 1);\n}\n</code></pre> <p>In questo caso la funzione continua a richiamarsi fino a quando raggiunge la condizione base (<code>n &lt;= 1</code>). La ricorsione \u00e8 potente, ma in ambiente embedded va usata con estrema cautela perch\u00e9 ogni chiamata aggiunge un nuovo frame nello stack. Poich\u00e9 lo stack nei microcontrollori \u00e8 tipicamente molto limitato, un uso eccessivo della ricorsione pu\u00f2 portare a stack overflow e comportamenti imprevedibili. In sistemi a risorse limitate, \u00e8 spesso preferibile convertire una ricorsione in un ciclo iterativo.</p> <p>Funzioni variadiche Alcune funzioni in C possono accettare un numero variabile di argomenti. L\u2019esempio pi\u00f9 noto \u00e8 <code>printf</code>. Per implementarle si utilizza la libreria <code>&lt;stdarg.h&gt;</code>, che fornisce i tipi e le macro necessarie per accedere agli argomenti aggiuntivi.</p> <p>Esempio semplificato di funzione che calcola la media di un numero variabile di interi:</p> <pre><code>#include &lt;stdarg.h&gt;\n#include &lt;stdio.h&gt;\n\ndouble media(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    int somma = 0;\n\n    for (int i = 0; i &lt; count; i++) {\n        somma += va_arg(args, int);\n    }\n\n    va_end(args);\n    return (double)somma / count;\n}\n</code></pre> <p>L\u2019uso di funzioni variadiche deve essere ponderato: gli argomenti non hanno un tipo esplicito e un errore nella gestione (ad esempio passare un tipo sbagliato) non viene rilevato dal compilatore.</p> <p>Funzioni inline vs macro Le macro (<code>#define</code>) permettono di definire frammenti di codice riutilizzabili che vengono sostituiti dal preprocessore. Ad esempio:</p> <pre><code>#define QUADRATO(x) ((x) * (x))\n</code></pre> <p>Il problema \u00e8 che le macro non hanno controllo sui tipi e possono introdurre errori difficili da individuare (ad esempio <code>QUADRATO(a+b)</code> si espande in <code>((a+b)*(a+b))</code>, che pu\u00f2 avere effetti collaterali inattesi se <code>x</code> \u00e8 un\u2019espressione con side-effect).</p> <p>Le funzioni <code>inline</code> sono un\u2019alternativa molto pi\u00f9 sicura:</p> <pre><code>inline int quadrato(int x) {\n    return x * x;\n}\n</code></pre> <p>Il compilatore pu\u00f2 sostituire la chiamata con il corpo della funzione (senza overhead di chiamata), mantenendo per\u00f2 il controllo sui tipi e la leggibilit\u00e0. Per questo motivo, in C moderno si preferisce sempre l\u2019uso di funzioni <code>inline</code> rispetto alle macro per operazioni semplici.</p> <p>Uso di <code>const</code> nei parametri La keyword <code>const</code> applicata ai parametri di funzione \u00e8 fondamentale per chiarire le intenzioni e prevenire modifiche indesiderate.</p> <p>Esempio senza <code>const</code>:</p> <pre><code>void stampa_stringa(char *str);\n</code></pre> <p>In questo caso non \u00e8 chiaro se la funzione modifichi o meno il contenuto della stringa.</p> <p>Con <code>const</code>:</p> <pre><code>void stampa_stringa(const char *str);\n</code></pre> <p>Ora il compilatore impedir\u00e0 qualsiasi modifica al contenuto di <code>str</code> all\u2019interno della funzione, e chi legge il codice capisce immediatamente che la funzione si limita a leggere la stringa senza alterarla.</p> <p>L\u2019uso di <code>const</code> \u00e8 particolarmente importante in ambienti embedded, dove la protezione contro modifiche indesiderate alla memoria (ad esempio buffer condivisi o registri di periferiche mappati in memoria) pu\u00f2 prevenire errori difficili da diagnosticare.</p>"},{"location":"codice/lezioni_di_c/puntatori/","title":"Approfondimento sui puntatori","text":"<p>I puntatori sono uno degli strumenti pi\u00f9 potenti e importanti del linguaggio C. Permettono di lavorare direttamente con indirizzi di memoria, rendendo possibile l\u2019accesso efficiente a variabili, array, strutture e periferiche hardware. Anche se li abbiamo introdotti nelle sezioni su variabili e funzioni, vale la pena dedicare un capitolo a parte per chiarire tutti i dettagli e i casi particolari.</p>"},{"location":"codice/lezioni_di_c/puntatori/#cose-un-puntatore","title":"Cos\u2019\u00e8 un puntatore","text":"<p>Quando dichiariamo una variabile, ad esempio <code>int numero = 10;</code>, il processore riserva una cella di memoria (o pi\u00f9 di una, a seconda del tipo di dato) per memorizzare il valore <code>10</code> e associa a questa casella il nome <code>numero</code>. L'indirizzo di questa casella \u00e8 la sua posizione fisica nella memoria.</p> <p>Un puntatore non \u00e8 altro che una variabile speciale il cui valore non \u00e8 un dato come un numero o un carattere, ma l'indirizzo di memoria di un'altra variabile. Invece di contenere il dato stesso, il puntatore \"punta\" alla casella di memoria che contiene quel dato. Dichiarazione:</p> <pre><code>int x = 10;\nint *p = &amp;x; // p contiene l\u2019indirizzo di x\n\nint *puntatore_a_intero;\nchar *puntatore_a_carattere;\nfloat *puntatore_a_float;\n</code></pre> <ul> <li><code>&amp;x</code> \u2192 (<code>&amp;</code> operatore di indirizzo) indirizzo della variabile <code>x</code></li> <li><code>*p</code> \u2192 (<code>*</code> operatore di dereferenziazione o indirezione) valore contenuto all\u2019indirizzo puntato da <code>p</code></li> </ul> <p>\u00c8 importante sottolineare il fatto che in queste variabili sono a tutti gli effetti salvati degli indirizzi di memoria, quindi il tipo di dato contenuto al loro interno \u00e8 un <code>unsigned int</code> che ha la dimensione del bus del processore. Sulle architetture a 32bit sar\u00e0 un <code>uint32</code> mentre in quelle a 64bit sar\u00e0 un <code>uint64</code>. Dichiarare un tipo diverso serve al processore per capire quanto \u00e8 grande il dato contenuto alla cella di memoria a cui si sta puntando e come interpretarlo.</p> <p>Attenzione: </p> <p>Quando si usano i puntatori, a meno che non si sia assolutamente sicuri che abbiano un valore valido, bisogna controllare che non sia nullo e che sia del tipo corretto rispetto al dato a cui si sta puntando. \u00c8 anche possibile assegnare <code>NULL</code> ad un puntatore, ma bisogna stare attenti a come lo si usa.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-e-costanti","title":"Puntatori e costanti","text":"<p>Esistono varie combinazioni di <code>const</code> con i puntatori:</p> <ol> <li>Puntatore a costante: il contenuto non pu\u00f2 essere modificato</li> </ol> <pre><code>const int *p = &amp;x;\n*p = 5; // ERRORE\np = &amp;y; // OK\n</code></pre> <ol> <li>Puntatore costante: il puntatore non pu\u00f2 cambiare, ma il contenuto pu\u00f2</li> </ol> <pre><code>int *const p = &amp;x;\n*p = 5; // OK\np = &amp;y; // ERRORE\n</code></pre> <ol> <li>Puntatore costante a costante: niente pu\u00f2 essere modificato</li> </ol> <pre><code>const int *const p = &amp;x;\n*p = 5; // ERRORE\np = &amp;y; // ERRORE\n</code></pre> <p>Questa distinzione \u00e8 fondamentale in embedded per proteggere buffer o registri di periferica.</p>"},{"location":"codice/lezioni_di_c/puntatori/#aritmetica-dei-puntatori","title":"Aritmetica dei puntatori","text":"<p>Quando incrementiamo (<code>++</code>) un puntatore, non stiamo aggiungendo 1 all'indirizzo di memoria. Stiamo invece spostando il puntatore in avanti della dimensione del tipo di dato a cui punta. Se <code>p_voti</code> \u00e8 un puntatore a <code>int</code> e un <code>int</code> occupa 4 byte, <code>p_voti++</code> aumenter\u00e0 l'indirizzo di 4, puntando cos\u00ec all'intero successivo.</p> <p>Le operazioni consentite sono:</p> <ul> <li>Incremento/Decremento: <code>p++</code>, <code>p--</code></li> <li>Somma/Sottrazione di un intero: <code>p + n</code>, <code>p - n</code></li> <li>Differenza tra due puntatori: Se <code>p1</code> e <code>p2</code> puntano a elementi dello stesso array, <code>p2 - p1</code> restituisce il numero di elementi tra di loro.</li> </ul> <pre><code>int a[3] = {10, 20, 30};\nint *p = a;\n\np++;        // ora punta a a[1]\nprintf(\"%d\\n\", *p); // stampa 20\n</code></pre> <p>L\u2019operatore <code>+</code> o <code>-</code> muove il puntatore di un numero di elementi, non di byte. La sottrazione tra puntatori restituisce il numero di elementi tra loro.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-e-array","title":"Puntatori e array","text":"<p>In C, c'\u00e8 una stretta relazione tra puntatori e array. Il nome di un array, usato in un'espressione, viene convertito in un puntatore al suo primo elemento.</p> <p>Questo significa che possiamo usare l'aritmetica dei puntatori per scorrere gli elementi di un array. Passare un array a una funzione significa passare un puntatore:</p> <pre><code>void stampa(int arr[], int n) {\n    for(int i = 0; i &lt; n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n</code></pre> <p>\u00c8 equivalente a:</p> <pre><code>void stampa(int *arr, int n) { ... }\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-a-struct","title":"Puntatori a struct","text":"<p>Quando si ha una struttura, \u00e8 spesso pi\u00f9 efficiente passare un puntatore:</p> <pre><code>struct Punto {\n    int x;\n    int y;\n};\n\nvoid sposta(struct Punto *p, int dx, int dy) {\n    p-&gt;x += dx;\n    p-&gt;y += dy;\n}\n</code></pre> <ul> <li><code>p-&gt;x</code> \u00e8 equivalente a <code>(*p).x</code></li> <li>I puntatori a struct permettono di risparmiare memoria e tempo di copia.</li> </ul>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-void","title":"Puntatori void","text":"<p><code>void *</code> \u00e8 un puntatore generico, senza tipo. Serve quando vogliamo passare un indirizzo di memoria senza sapere il tipo, ad esempio in buffer generici o callback.</p> <pre><code>void stampa_generico(void *ptr, char tipo) {\n    if(tipo == 'i') printf(\"%d\\n\", *(int *)ptr);\n    if(tipo == 'f') printf(\"%f\\n\", *(float *)ptr);\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#array-di-puntatori-e-puntatori-a-puntatori","title":"Array di puntatori e puntatori a puntatori","text":"<p>\u00c8 possibile avere array di puntatori:</p> <pre><code>char *nomi[] = {\"Mario\", \"Luigi\", \"Peach\"};\n</code></pre> <p>O puntatori a puntatori, utili ad esempio per gestire array dinamici di stringhe:</p> <pre><code>char **strs;\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#passaggio-per-riferimento-simulato","title":"Passaggio per Riferimento (Simulato)","text":"<p>Di default, il C passa gli argomenti alle funzioni \"per valore\", creando una copia della variabile. Qualsiasi modifica all'interno della funzione non influisce sulla variabile originale. Passando un puntatore a una funzione, possiamo simulare un \"passaggio per riferimento\", permettendo alla funzione di modificare la variabile originale.</p> <p>Esempio riassuntivo:</p> <pre><code>void incrementa(int *valore) {\n    (*valore)++; // Incrementa il valore a cui punta 'valore'\n}\n\nint main() {\n    int a = 10;\n    incrementa(&amp;a); // Passiamo l'indirizzo di 'a'\n    printf(\"Valore di a dopo l'incremento: %d\\n\", a); // Stampa 11\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#allocazione-dinamica-della-memoria","title":"Allocazione Dinamica della Memoria","text":"<p>Fino ad ora, la memoria per le nostre variabili veniva allocata staticamente dal compilatore. I puntatori ci permettono di gestire la memoria dinamicamente a runtime, ovvero di richiederne e liberarne blocchi quando ne abbiamo bisogno. Questo \u00e8 fondamentale per creare strutture dati la cui dimensione non \u00e8 nota a priori. Le funzioni si trovano nella libreria <code>&lt;stdlib.h&gt;</code>.</p> <ul> <li> <p><code>malloc(size_t size)</code>: Alloca un blocco di memoria della dimensione specificata in byte. Restituisce un puntatore <code>void*</code> all'inizio del blocco, o <code>NULL</code> se fallisce.</p> </li> <li> <p><code>calloc(size_t num, size_t size)</code>: Alloca memoria per un array di <code>num</code> elementi, ciascuno di dimensione <code>size</code>. La memoria viene inizializzata a zero.</p> </li> <li> <p><code>realloc(void *ptr, size_t new_size)</code>: Ridimensiona un blocco di memoria precedentemente allocato.</p> </li> <li> <p><code>free(void *ptr)</code>: Dealloca (libera) un blocco di memoria precedentemente allocato, rendendolo di nuovo disponibile al sistema.</p> </li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *array_dinamico;\n    int n = 5;\n\n    // Alloca memoria per 5 interi\n    array_dinamico = (int*) malloc(n * sizeof(int));\n\n    if (array_dinamico == NULL) {\n        printf(\"Allocazione di memoria fallita!\\n\");\n        return 1;\n    }\n\n    // Usa l'array come un normale array\n    for (int i = 0; i &lt; n; i++) {\n        array_dinamico[i] = i * 10;\n        printf(\"%d \", array_dinamico[i]);\n    }\n    printf(\"\\n\");\n\n    // \u00c8 FONDAMENTALE liberare la memoria quando non serve pi\u00f9\n    free(array_dinamico);\n    array_dinamico = NULL; // Buona pratica per evitare \"dangling pointers\"\n\n    return 0;\n}\n</code></pre> <p>Attenzione: Dimenticare di usare <code>free()</code> causa memory leak (perdita di memoria), un bug grave in cui il programma consuma memoria senza mai rilasciarla.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-a-puntatori","title":"Puntatori a Puntatori","text":"<p>Un puntatore a puntatore \u00e8 una variabile che contiene l'indirizzo di un altro puntatore. Si dichiara con un doppio asterisco (<code>**</code>). <pre><code>int x = 10;\nint *p = &amp;x;\nint **pp = &amp;p;\n\nprintf(\"Valore di x: %d\\n\", x);\nprintf(\"Valore tramite p: %d\\n\", *p);\nprintf(\"Valore tramite pp: %d\\n\", **pp);\n</code></pre></p> <p>Sono utili, ad esempio, per creare array di stringhe o per modificare un puntatore all'interno di una funzione.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-a-funzioni","title":"Puntatori a Funzioni","text":"<p>Cos\u00ec come le variabili, anche le funzioni risiedono in memoria e hanno un indirizzo. Un puntatore a funzione pu\u00f2 memorizzare questo indirizzo, permettendoci di trattare le funzioni come dati: passarle ad altre funzioni, inserirle in array, ecc.</p> <p>La sintassi \u00e8 un po' ostica: <code>tipo_ritorno (*nome_puntatore)(lista_parametri);</code></p> <pre><code>int somma(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int (*operazione)(int, int); // Dichiara un puntatore a funzione\n    operazione = &amp;somma;\n\n    int risultato = operazione(5, 3); // Chiama la funzione 'somma' tramite il puntatore\n    printf(\"Risultato: %d\\n\", risultato); // Stampa 8\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/","title":"Sintassi base del C","text":"<p>Il linguaggio C \u00e8 alla base dello sviluppo embedded: \u00e8 semplice, efficiente e permette un controllo diretto sull\u2019hardware. In questa sezione vediamo le fondamenta che servono per scrivere e capire il codice della centralina.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#variabili","title":"Variabili","text":"<p>Una variabile \u00e8 uno spazio di memoria a cui diamo un nome e che contiene un valore.</p> <p>\u26a0\ufe0f Nota per l\u2019embedded: \u00c8 sempre consigliato evitare l\u2019allocazione dinamica con funzioni come <code>malloc()</code> o <code>alloca()</code>. Negli ambienti a risorse limitate (come i microcontrollori) queste chiamate possono causare memory leak, frammentazione o corruzione della memoria. Meglio usare variabili globali, statiche o allocate nello stack, che garantiscono maggiore stabilit\u00e0 e prevedibilit\u00e0.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#dichiarazione","title":"Dichiarazione","text":"<pre><code>int numero;        // variabile intera\nfloat temperatura; // variabile con virgola\nchar lettera;      // variabile carattere\n````\n\n### Inizializzazione\n\n```c\nint numero = 10;\nfloat temperatura = 36.5;\nchar lettera = 'A';\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#regole-sui-nomi","title":"Regole sui nomi","text":"<ul> <li>Devono iniziare con lettera o <code>_</code></li> <li>Possono contenere lettere, numeri e <code>_</code></li> <li>Sono case-sensitive (<code>variabile</code> \u2260 <code>Variabile</code>)</li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#tipi-di-dato-principali","title":"Tipi di dato principali","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#interi","title":"Interi","text":"<ul> <li><code>int</code> \u2192 intero base (dimensione dipende dal compilatore, spesso 32 bit)</li> <li><code>short</code> \u2192 intero corto (16 bit)</li> <li><code>long</code> \u2192 intero lungo (32 o 64 bit)</li> <li><code>unsigned</code> \u2192 versione senza segno (solo positivi)</li> </ul> <p>Esempio:</p> <pre><code>int a = -10;\nunsigned int b = 20;\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#numeri-decimali","title":"Numeri decimali","text":"<ul> <li><code>float</code> \u2192 virgola mobile a 32 bit (circa 6-7 cifre decimali)</li> <li><code>double</code> \u2192 virgola mobile a 64 bit (circa 15-16 cifre decimali)</li> </ul> <p>Esempio:</p> <pre><code>float x = 3.14f;\ndouble y = 2.718281828;\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#caratteri","title":"Caratteri","text":"<ul> <li><code>char</code> \u2192 memorizza un singolo carattere (es. 'A', 'b', '1')</li> <li>In realt\u00e0 \u00e8 un numero intero (ASCII)</li> </ul> <pre><code>char c = 'A';  // ASCII 65\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#booleani","title":"Booleani","text":"<p>In C puro non esisteva, ma da C99 si pu\u00f2 usare, bisogna includere la libreria <code>stdbool.h</code>:</p> <pre><code>#include &lt;stdbool.h&gt;\n\nbool flag = true;\n</code></pre> <p>Reminder: C \\(\\ne\\) C++, la libreria standard C \u00e8 definita da file chiamati <code>&lt;libreria&gt;.h</code> e non <code>&lt;libreria&gt;</code> e basta, bisogna mettere il .h </p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#costanti","title":"Costanti","text":"<p>Una costante \u00e8 un valore che non cambia.</p> <pre><code>const float PI = 3.14159;\n#define MAX_VALORE 100\n</code></pre> <ul> <li><code>const</code> \u2192 variabile costante</li> <li><code>#define</code> \u2192 macro gestita dal preprocessore</li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#operatori","title":"Operatori","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#aritmetici","title":"Aritmetici","text":"<pre><code>+   // addizione\n-   // sottrazione\n*   // moltiplicazione\n/   // divisione\n%   // resto (solo interi)\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#relazionali","title":"Relazionali","text":"<pre><code>==  // uguale\n!=  // diverso\n&gt;   // maggiore\n&lt;   // minore\n&gt;=  // maggiore o uguale\n&lt;=  // minore o uguale\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#logici","title":"Logici","text":"<pre><code>&amp;&amp;  // AND logico\n||  // OR logico\n!   // NOT logico\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#operatori-bitwise","title":"Operatori bitwise","text":"<pre><code>&lt;&lt;  // left shift\n&gt;&gt;  // right shift\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori","title":"Puntatori","text":"<p>Un puntatore \u00e8 una variabile che contiene l\u2019indirizzo di memoria di un\u2019altra variabile. Sono fondamentali in C perch\u00e9 permettono di accedere direttamente alla memoria, alle periferiche e ai registri.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#dichiarazione_1","title":"Dichiarazione","text":"<pre><code>int x = 10;\nint *p = &amp;x;   // p contiene l\u2019indirizzo di x\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#utilizzo","title":"Utilizzo","text":"<pre><code>printf(\"Valore di x: %d\\n\", x);   // stampa 10\nprintf(\"Indirizzo di x: %p\\n\", &amp;x);\nprintf(\"Valore tramite puntatore: %d\\n\", *p); // stampa 10\n</code></pre> <ul> <li><code>&amp;x</code> \u2192 indirizzo della variabile <code>x</code></li> <li><code>*p</code> \u2192 valore contenuto all\u2019indirizzo puntato da <code>p</code></li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori-e-array","title":"Puntatori e array","text":"<p>Un array \u00e8 strettamente legato ai puntatori.</p> <pre><code>int numeri[3] = {1, 2, 3};\nint *ptr = numeri;\n\nprintf(\"%d\\n\", *ptr);       // 1\nprintf(\"%d\\n\", *(ptr + 1)); // 2\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori-a-char-e-stringhe","title":"Puntatori a <code>char</code> e stringhe","text":"<p>In C una stringa \u00e8 un array di <code>char</code> terminato da <code>\\0</code>.</p> <pre><code>char saluto[] = \"Ciao\";\nchar *p = saluto;\n\nprintf(\"%s\\n\", p);   // stampa \"Ciao\"\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#tipi-definiti-dallutente","title":"Tipi definiti dall\u2019utente","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#struct","title":"<code>struct</code>","text":"<p>Serve per raggruppare variabili diverse in un\u2019unica entit\u00e0.</p> <pre><code>struct Sensore {\n    int id;\n    float valore;\n};\n\nstruct Sensore s1 = {1, 23.5};\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#typedef","title":"<code>typedef</code>","text":"<p>Permette di creare alias per tipi pi\u00f9 leggibili.</p> <pre><code>typedef unsigned int uint32_t;\n\nuint32_t counter = 100;\n</code></pre>"},{"location":"codice/lezioni_di_c/stdint/","title":"Tipi di <code>stdint.h</code>","text":"<p>In C la dimensione di tipi come <code>int</code>, <code>long</code>, <code>short</code> pu\u00f2 variare a seconda del compilatore e dell\u2019architettura. Per i microcontrollori questo \u00e8 un problema, perch\u00e9 dobbiamo sapere con certezza quanti bit occupa una variabile.</p> <p>Per questo si usa l\u2019header <code>&lt;stdint.h&gt;</code>, che definisce tipi con dimensione fissa.</p>"},{"location":"codice/lezioni_di_c/stdint/#tipi-interi-con-dimensione-precisa","title":"Tipi interi con dimensione precisa","text":"<ul> <li><code>int8_t</code> \u2192 intero con segno a 8 bit (da -128 a 127)  </li> <li><code>uint8_t</code> \u2192 intero senza segno a 8 bit (da 0 a 255)  </li> <li><code>int16_t</code> \u2192 intero con segno a 16 bit  </li> <li><code>uint16_t</code> \u2192 intero senza segno a 16 bit  </li> <li><code>int32_t</code> \u2192 intero con segno a 32 bit  </li> <li><code>uint32_t</code> \u2192 intero senza segno a 32 bit  </li> <li><code>int64_t</code> \u2192 intero con segno a 64 bit  </li> <li><code>uint64_t</code> \u2192 intero senza segno a 64 bit  </li> </ul> <p>Esempio: <pre><code>uint16_t valore = 50000; // sicuro che \u00e8 16 bit senza segno\n````\n\n---\n\n## Tipi minimi e massimi\n\nOltre ai tipi a dimensione fissa, `stdint.h` fornisce anche tipi che garantiscono almeno una certa dimensione:\n\n- `int_least8_t` \u2192 almeno 8 bit con segno\n- `uint_least16_t` \u2192 almeno 16 bit senza segno\n- `int_fast32_t` \u2192 il tipo intero \u201cpi\u00f9 veloce\u201d con almeno 32 bit\n\nQuesti sono meno usati in embedded, ma possono tornare utili se non importa la dimensione esatta, ma solo la minima.\n\n---\n\n## Costanti con dimensione fissa\n\n`stdint.h` definisce anche **macro** per scrivere costanti con la dimensione giusta:\n\n```c\n#include &lt;stdint.h&gt;\n\nuint32_t mask = UINT32_C(0xFFFF0000);\n</code></pre></p> <p>Cos\u00ec evitiamo warning o errori quando usiamo numeri grandi.</p>"},{"location":"codice/lezioni_di_c/stdint/#buona-pratica","title":"Buona pratica","text":"<p>In un progetto embedded \u00e8 consigliato:</p> <ul> <li>usare sempre i tipi di <code>stdint.h</code> (<code>uint8_t</code>, <code>int32_t</code>, \u2026)</li> <li>evitare i tipi \u201cclassici\u201d (<code>int</code>, <code>long</code>, \u2026) perch\u00e9 non sempre hanno la stessa dimensione tra PC e microcontrollore</li> <li>abbinare <code>stdbool.h</code> e <code>stdint.h</code> per scrivere codice pi\u00f9 leggibile e portabile</li> </ul>"},{"location":"codice/lezioni_di_c/stdint/#confronto-tra-tipi-standard-e-tipi-di-stdinth","title":"Confronto tra tipi standard e tipi di <code>stdint.h</code>","text":"Tipo classico Dimensione (dipende da architettura) Possibili valori Equivalente <code>stdint.h</code> (fisso) <code>char</code> 8 bit (di solito) -128 \u2026 127 / 0 \u2026 255 <code>int8_t</code> / <code>uint8_t</code> <code>short</code> almeno 16 bit (spesso 16) -32.768 \u2026 32.767 <code>int16_t</code> <code>unsigned short</code> almeno 16 bit (spesso 16) 0 \u2026 65.535 <code>uint16_t</code> <code>int</code> almeno 16 bit (spesso 32 su ARM) dipende da piattaforma <code>int32_t</code> (se serve 32 bit certi) <code>unsigned int</code> almeno 16 bit (spesso 32) dipende da piattaforma <code>uint32_t</code> <code>long</code> almeno 32 bit (pu\u00f2 essere 32 o 64) dipende da compilatore <code>int32_t</code> o <code>int64_t</code> <code>unsigned long</code> almeno 32 bit (pu\u00f2 essere 32 o 64) dipende da compilatore <code>uint32_t</code> o <code>uint64_t</code>"},{"location":"codice/lezioni_di_c/stdint/#perche-e-importante","title":"Perch\u00e9 \u00e8 importante?","text":"<p>Su un PC a 64 bit: - <code>int</code> \u00e8 spesso 32 bit. - <code>long</code> \u00e8 64 bit (Linux) o 32 bit (Windows).  </p> <p>Su un microcontrollore ARM Cortex-M: - <code>int</code> \u00e8 quasi sempre 32 bit. - <code>long</code> \u00e8 32 bit (non 64!).  </p> <p>Quindi lo stesso codice scritto con <code>int</code> e <code>long</code> pu\u00f2 comportarsi in modo diverso a seconda di dove gira. Con <code>stdint.h</code> questo problema non esiste: la dimensione \u00e8 sempre quella dichiarata.</p>"},{"location":"codice/lezioni_di_c/strutture_base/","title":"Strutture dati minime","text":"<p>Nel linguaggio C le strutture dati fondamentali che si usano quasi ovunque sono gli array, le struct e le enum. Conoscerle a fondo \u00e8 essenziale per scrivere codice chiaro, efficiente e comprensibile.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#array","title":"Array","text":"<p>Un array \u00e8 una sequenza di elementi dello stesso tipo, memorizzati in celle di memoria contigue. Quando si dichiara un array, si deve indicare il tipo degli elementi e la dimensione:</p> <pre><code>int valori[10]; // array di 10 interi\n````\n\nQuesto significa che la variabile `valori` contiene 10 interi, indicizzati da `0` a `9`. L\u2019indice deve sempre essere compreso tra 0 e dimensione-1. Accedere a un indice fuori dai limiti produce un comportamento indefinito, cio\u00e8 errori difficili da individuare.\n\nGli array possono essere **inizializzati**:\n\n```c\nint a[5] = {1, 2, 3, 4, 5};\nint b[5] = {0}; // tutti inizializzati a zero\n</code></pre> <p>Se si forniscono meno valori rispetto alla dimensione, i restanti vengono messi a zero. \u00c8 possibile anche lasciare vuota la dimensione quando i valori sono noti a compilazione:</p> <pre><code>int c[] = {10, 20, 30}; // dimensione 3 dedotta dal compilatore\n</code></pre> <p>Gli array di caratteri sono spesso usati per rappresentare stringhe terminate dal carattere nullo <code>'\\0'</code>:</p> <pre><code>char nome[10] = \"ciao\"; // occuper\u00e0 5 celle: 'c','i','a','o','\\0'\n</code></pre> <p>Negli ambienti embedded gli array vengono utilizzati anche come buffer per la comunicazione (es. pacchetti CAN, UART). In questi casi \u00e8 fondamentale rispettare sempre la dimensione massima per evitare corruzione di memoria.</p> <p>Un array in C si comporta quasi sempre come un puntatore al suo primo elemento. Questo significa che se passo un array a una funzione, in realt\u00e0 passo l\u2019indirizzo della prima cella, non una copia dell\u2019intero array:</p> <pre><code>void stampa(int arr[], int n) {\n    for(int i = 0; i &lt; n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_base/#struct","title":"Struct","text":"<p>Una <code>struct</code> \u00e8 una struttura che permette di raggruppare variabili di tipi diversi sotto un unico nome. \u00c8 molto utile per rappresentare entit\u00e0 complesse:</p> <pre><code>struct Punto {\n    int x;\n    int y;\n};\n</code></pre> <p>Ora \u00e8 possibile dichiarare variabili di questo tipo:</p> <pre><code>struct Punto p1 = {10, 20};\n</code></pre> <p>Ogni campo si accede con l\u2019operatore <code>.</code>:</p> <pre><code>printf(\"%d\", p1.x);\n</code></pre> <p>Le struct possono contenere anche array o altre struct:</p> <pre><code>struct Rettangolo {\n    struct Punto vertici[4];\n};\n</code></pre> <p>Quando si lavora con puntatori a struct, si usa l\u2019operatore <code>-&gt;</code>:</p> <pre><code>struct Punto *pp = &amp;p1;\npp-&gt;x = 5; // equivalente a (*pp).x\n</code></pre> <p>\u00c8 possibile usare <code>typedef</code> per evitare di scrivere ogni volta <code>struct</code>:</p> <pre><code>typedef struct {\n    int x;\n    int y;\n} Punto;\n\nPunto p2 = {3, 4};\n</code></pre> <p>In embedded le struct sono spesso usate per definire i registri delle periferiche. In questo caso \u00e8 importante considerare il padding: il compilatore pu\u00f2 inserire byte di allineamento tra i campi per rispettare i vincoli dell\u2019architettura. Questo significa che due struct con gli stessi campi ma ordine diverso possono avere dimensioni diverse. Per controllare queste situazioni si usano attributi come <code>__attribute__((packed))</code> o le opzioni del compilatore.</p> <p>Le struct possono anche essere annidate e usate come contenitori per dati condivisi tra task in un sistema operativo real-time. \u00c8 una buona pratica abbinarle a mutex o code quando pi\u00f9 parti del programma devono accedere alle stesse informazioni.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#enum","title":"Enum","text":"<p>Una <code>enum</code> definisce un insieme di valori simbolici associati a numeri interi. \u00c8 utile per rendere pi\u00f9 leggibile il codice e per rappresentare stati, modalit\u00e0 o codici di errore.</p> <pre><code>enum Stato {\n    IDLE,\n    RUN,\n    ERROR\n};\n</code></pre> <p>Di default il primo valore parte da 0 e gli altri crescono di 1. Nell\u2019esempio, <code>IDLE = 0</code>, <code>RUN = 1</code>, <code>ERROR = 2</code>. \u00c8 possibile assegnare valori arbitrari:</p> <pre><code>enum Comando {\n    START = 10,\n    STOP = 20,\n    RESET = 30\n};\n</code></pre> <p>\u00c8 consigliato usare <code>typedef</code> per semplificare:</p> <pre><code>typedef enum {\n    LED_OFF = 0,\n    LED_ON = 1\n} LedState;\n</code></pre> <p>Le enum migliorano la leggibilit\u00e0:</p> <pre><code>LedState stato = LED_OFF;\n\nif (stato == LED_ON) {\n    // accendi il LED\n}\n</code></pre> <p>In embedded le enum sono molto utili per definire le macchine a stati finiti. Ogni stato della FSM corrisponde a un valore della enum, rendendo il codice pi\u00f9 chiaro e meno soggetto a errori rispetto all\u2019uso di costanti numeriche.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#union","title":"Union","text":"<p>Una <code>union</code> \u00e8 simile a una <code>struct</code>, ma con una differenza fondamentale: tutti i campi condividono lo stesso spazio di memoria. Questo significa che una union occupa tanta memoria quanta ne richiede il campo pi\u00f9 grande, e tutti i membri si sovrappongono.</p> <p>Esempio di dichiarazione:</p> <pre><code>union Valore {\n    uint32_t intero;\n    float reale;\n    uint8_t byte[4];\n};\n````\n\nIn questo caso `union Valore` occupa 4 byte, perch\u00e9 il campo pi\u00f9 grande (`uint32_t` e `float`) \u00e8 di 4 byte.  \nSe assegniamo un valore a `intero`, possiamo leggere la sua rappresentazione binaria attraverso l\u2019array `byte`:\n\n```c\nunion Valore v;\nv.intero = 0x12345678;\n\nprintf(\"%02X %02X %02X %02X\\n\", v.byte[0], v.byte[1], v.byte[2], v.byte[3]);\n</code></pre> <p>Il risultato dipender\u00e0 dall\u2019endianness del processore (little endian o big endian), perch\u00e9 determina l\u2019ordine dei byte in memoria.</p> <p>Le union sono molto potenti, ma bisogna usarle con attenzione: scrivere in un campo e leggere da un altro non sempre \u00e8 portabile al 100% secondo lo standard C, anche se in pratica nei sistemi embedded \u00e8 una tecnica comune.</p> <p>Esempi di utilizzo tipico nelle applicazioni embedded:</p> <ul> <li>Interpretare un pacchetto ricevuto su bus di comunicazione sia come array di byte che come valori numerici.</li> <li>Definire registri hardware in modo che un singolo registro possa essere letto intero oppure per campi pi\u00f9 piccoli.</li> <li>Effettuare \u201ctype punning\u201d (riutilizzare lo stesso blocco di memoria come tipi diversi) per ridurre l\u2019uso di memoria.</li> </ul> <p>Differenze rispetto a struct:</p> <ul> <li>In una <code>struct</code> ogni campo ha il suo spazio separato, e la dimensione totale \u00e8 almeno la somma delle dimensioni dei campi (pi\u00f9 eventuale padding).</li> <li>In una <code>union</code> tutti i campi condividono lo stesso spazio, e la dimensione totale \u00e8 uguale a quella del campo pi\u00f9 grande.</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_controllo/","title":"Strutture di controllo","text":""},{"location":"codice/lezioni_di_c/strutture_controllo/#strutture-di-controllo-condizionali-prendere-decisioni","title":"Strutture di Controllo Condizionali: Prendere Decisioni","text":"<p>Spesso, un programma deve comportarsi in modo diverso a seconda delle condizioni. \"Se l'utente ha inserito una password corretta, allora accedi. Altrimenti, mostra un errore\". Questo \u00e8 il ruolo delle strutture condizionali.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#if-else-if-else","title":"<code>if</code>, <code>else if</code>, <code>else</code>","text":"<p>La struttura <code>if-else</code> \u00e8 il modo pi\u00f9 basilare per eseguire un blocco di codice solo se una certa condizione \u00e8 vera.</p> <p>La sintassi \u00e8: <pre><code>if (condizione) {\n    // Blocco di codice da eseguire se la condizione \u00e8 VERA\n} else {\n    // Blocco di codice da eseguire se la condizione \u00e8 FALSA (opzionale)\n}\n</code></pre></p> <p>La <code>condizione</code> \u00e8 un'espressione che viene valutata come \"vera\" (qualsiasi valore diverso da 0) o \"falsa\" (0).</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int eta = 20;\n\n    if (eta &gt;= 18) {\n        printf(\"Sei maggiorenne. Puoi entrare.\\n\");\n    } else {\n        printf(\"Sei minorenne. Non puoi entrare.\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#switch","title":"<code>switch</code>","text":"<p>Quando devi controllare una singola variabile rispetto a una serie di valori costanti, usare una lunga catena di <code>if-else if</code> pu\u00f2 diventare goffo. In questi casi, lo <code>switch</code> \u00e8 una soluzione pi\u00f9 pulita e spesso pi\u00f9 efficiente.</p> <p>La sintassi \u00e8: <pre><code>switch (espressione) {\n    case valore1:\n        // Codice da eseguire se espressione == valore1\n        break; // L'istruzione 'break' \u00e8 cruciale!\n    case valore2:\n        // Codice da eseguire se espressione == valore2\n        break;\n    default:\n        // Codice da eseguire se nessun 'case' corrisponde (opzionale)\n}\n</code></pre></p> <p>Punti Chiave dello <code>switch</code>:</p> <ol> <li>L'<code>espressione</code> deve essere di tipo intero (inclusi i <code>char</code>).</li> <li>I <code>valore</code> dei <code>case</code> devono essere costanti.</li> <li>L'istruzione <code>break</code> \u00e8 fondamentale. Se omessa, l'esecuzione \"cadr\u00e0\" (fall-through) al <code>case</code> successivo, eseguendo anche il suo codice, fino a quando non incontrer\u00e0 un <code>break</code> o la fine dello <code>switch</code>. Questo a volte \u00e8 un comportamento desiderato, ma spesso \u00e8 fonte di bug.</li> <li>Il blocco <code>default</code> cattura tutti i casi non esplicitamente gestiti.</li> </ol> <p>Attenzione:  Lo <code>switch</code> possiede un unico contesto, nel senso che una variabile dichiarata in un case, se ridichiarata in un altro generer\u00e0 un errore di compilazione. In questo caso si utilizzano le parentesi graffe per separare i contesti.</p> <pre><code>case valore: {\n    // codice da eseguire\n    break;\n}\n</code></pre> <p>Esempio: Un menu. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char scelta = 'B';\n\n    printf(\"Menu:\\n\");\n    printf(\"A - Avvia\\n\");\n    printf(\"B - Salva\\n\");\n    printf(\"C - Esci\\n\");\n    printf(\"La tua scelta: %c\\n\", scelta);\n\n    switch (scelta) {\n        case 'A':\n            printf(\"Programma avviato.\\n\");\n            break;\n        case 'B':\n            printf(\"Salvataggio in corso...\\n\");\n            break;\n        case 'C':\n            printf(\"Uscita dal programma.\\n\");\n            break;\n        default:\n            printf(\"Scelta non valida!\\n\");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#loop-o-cicli-larte-della-ripetizione","title":"Loop (o Cicli): L'Arte della Ripetizione","text":"<p>I loop ci permettono di eseguire un blocco di codice pi\u00f9 volte, fino a quando una certa condizione di terminazione non viene soddisfatta. In C, abbiamo tre tipi principali di loop.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#while","title":"<code>while</code>","text":"<p>Il ciclo <code>while</code> \u00e8 il pi\u00f9 semplice. Esegue un blocco di codice fintanto che la sua condizione rimane vera. La condizione viene controllata prima di ogni esecuzione del blocco.</p> <p>Sintassi: <pre><code>while (condizione) {\n    // Blocco di codice da ripetere\n    // \u00c8 importante che qui dentro qualcosa modifichi la condizione,\n    // altrimenti si crea un ciclo infinito!\n}\n</code></pre></p> <p>Esempio: Un conto alla rovescia. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int contatore = 5;\n\n    while (contatore &gt; 0) {\n        printf(\"%d...\\n\", contatore);\n        contatore--; // Decremento il contatore per evitare un loop infinito\n    }\n\n    printf(\"Lancio!\\n\");\n    return 0;\n}\n</code></pre></p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#do-while-esegui-almeno-una-volta","title":"<code>do-while</code>: Esegui Almeno una Volta","text":"<p>Il <code>do-while</code> \u00e8 una variante del <code>while</code>. La sua caratteristica distintiva \u00e8 che la condizione viene controllata alla fine del blocco di codice. Questo garantisce che il codice all'interno del loop venga eseguito almeno una volta, indipendentemente dalla condizione.</p> <p>Sintassi: <pre><code>do {\n    // Blocco di codice da ripetere\n} while (condizione);\n</code></pre></p> <p>Esempio: Richiedere un input finch\u00e9 non \u00e8 valido. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int numero;\n\n    do {\n        printf(\"Inserisci un numero positivo: \");\n        scanf(\"%d\", &amp;numero);\n\n        if (numero &lt;= 0) {\n            printf(\"Errore: il numero deve essere positivo.\\n\");\n        }\n    } while (numero &lt;= 0); // Ripeti se il numero non \u00e8 valido\n\n    printf(\"Hai inserito il numero valido: %d\\n\", numero);\n    return 0;\n}\n</code></pre></p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#for-il-ciclo-strutturato","title":"<code>for</code>: Il Ciclo Strutturato","text":"<p>Il ciclo <code>for</code> \u00e8 ideale quando si conosce in anticipo il numero di iterazioni da eseguire (es. \"ripeti 10 volte\" o \"scorri tutti gli elementi di un array\"). Condensa in una sola riga l'inizializzazione, la condizione e l'incremento del contatore.</p> <p>Sintassi: <pre><code>for (inizializzazione; condizione; aggiornamento) {\n    // Blocco di codice da ripetere\n}\n</code></pre></p> <ul> <li>Inizializzazione: Eseguita una sola volta, all'inizio del ciclo.</li> <li>Condizione: Controllata prima di ogni iterazione. Se \u00e8 falsa, il ciclo termina.</li> <li>Aggiornamento: Eseguito alla fine di ogni iterazione.</li> </ul> <p>Esempio: Stampare i primi 10 numeri e la loro somma. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int somma = 0;\n\n    for (int i = 1; i &lt;= 10; i++) {\n        printf(\"Numero: %d\\n\", i);\n        somma += i;\n    }\n\n    printf(\"La somma totale \u00e8: %d\\n\", somma);\n    return 0;\n}\n</code></pre></p> <p>Tuttavia, il linguaggio C non obbliga a specificare tutte e tre queste parti. Ognuna di esse \u00e8 opzionale. L'unica cosa che non pu\u00f2 mancare sono le due parentesi <code>()</code> e i due punti e virgola <code>;</code> al loro interno, che agiscono come separatori.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#1-omettere-linizializzazione","title":"1. Omettere l'Inizializzazione","text":"<p>Se la variabile contatore \u00e8 gi\u00e0 stata inizializzata prima del ciclo, o se il ciclo non dipende da un nuovo contatore, possiamo lasciare vuota la prima parte.</p> <p>Quando \u00e8 utile?</p> <ul> <li>Quando il valore iniziale della variabile di controllo dipende da calcoli precedenti.    </li> <li>Quando si vuole riutilizzare una variabile esistente.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int inizio;\n    printf(\"Da che numero vuoi iniziare il conto alla rovescia? \");\n    scanf(\"%d\", &amp;inizio);\n\n    // 'inizio' \u00e8 gi\u00e0 stata inizializzata dall'utente.\n    // La prima sezione del 'for' \u00e8 vuota.\n    for ( ; inizio &gt;= 0; inizio--) {\n        printf(\"%d...\\n\", inizio);\n    }\n\n    printf(\"Finito!\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#2-omettere-laggiornamento","title":"2. Omettere l'Aggiornamento","text":"<p>Possiamo omettere la terza parte se l'aggiornamento della variabile di controllo avviene all'interno del corpo del ciclo.</p> <p>Quando \u00e8 utile?</p> <ul> <li>Quando l'aggiornamento non \u00e8 un semplice incremento/decremento (es. <code>i++</code>, <code>i--</code>).</li> <li>Quando l'aggiornamento deve avvenire solo al verificarsi di una certa condizione all'interno del ciclo.</li> </ul> <p>Esempio: Scorrere una lista concatenata fino alla fine. L'aggiornamento consiste nel passare al nodo successivo, un'operazione che si fa all'interno del ciclo.</p> <pre><code>// Ipotizzando di avere una struttura Nodo e una lista gi\u00e0 creata\n// struct Nodo { int dato; struct Nodo* next; };\n// Nodo* testa; // puntatore al primo nodo\n\n// Il puntatore 'corrente' viene aggiornato nel corpo del ciclo\nfor (Nodo* corrente = testa; corrente != NULL; ) {\n    printf(\"%d -&gt; \", corrente-&gt;dato);\n    corrente = corrente-&gt;next; // Aggiornamento manuale\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#3-omettere-la-condizione","title":"3. Omettere la Condizione","text":"<p>Questa \u00e8 la situazione pi\u00f9 interessante e potenzialmente pericolosa. Se si omette la condizione (la parte centrale), il C la considera sempre vera. Questo crea un ciclo infinito.</p> <p>Quando \u00e8 utile? Un ciclo infinito non \u00e8 sempre un errore. \u00c8 la base per programmi che devono rimanere in esecuzione continua fino a un intervento esterno, come sistemi operativi, server, o programmi embedded. L'uscita dal ciclo viene gestita internamente con un <code>break</code>, un <code>return</code> o una chiamata a <code>exit()</code>.</p> <p>Esempio: Un menu interattivo che continua a funzionare finch\u00e9 l'utente non sceglie di uscire.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char scelta;\n\n    for ( ; ; ) { // Ciclo infinito: mancano tutte e tre le parti\n        printf(\"\\n--- MENU ---\\n\");\n        printf(\"1. Stampa 'Ciao'\\n\");\n        printf(\"2. Stampa 'Mondo'\\n\");\n        printf(\"3. Esci\\n\");\n        printf(\"Scelta: \");\n        scanf(\" %c\", &amp;scelta); // Nota lo spazio prima di %c per consumare newline\n\n        if (scelta == '1') {\n            printf(\"Ciao\\n\");\n        } else if (scelta == '2') {\n            printf(\"Mondo\\n\");\n        } else if (scelta == '3') {\n            printf(\"Uscita in corso...\\n\");\n            break; // Uscita controllata dal ciclo infinito\n        } else {\n            printf(\"Scelta non valida.\\n\");\n        }\n    }\n\n    printf(\"Programma terminato.\\n\");\n    return 0;\n}\n</code></pre> <p>La forma <code>for(;;)</code> \u00e8 una convenzione molto comune in C per indicare un ciclo infinito intenzionale. \u00c8 funzionalmente identico a <code>while(1)</code>. Viene utilizzato per creare loop infiniti per le task di freertos.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#controllare-i-loop-break-e-continue","title":"Controllare i Loop: <code>break</code> e <code>continue</code>","text":"<p>A volte abbiamo bisogno di un controllo pi\u00f9 fine sul comportamento di un loop.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#break","title":"<code>break</code>","text":"<p>L'istruzione <code>break</code> (gi\u00e0 vista nello <code>switch</code>) interrompe immediatamente l'esecuzione del loop (<code>for</code>, <code>while</code>, <code>do-while</code>) in cui si trova, e il programma prosegue con l'istruzione successiva al loop.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#continue","title":"<code>continue</code>","text":"<p>L'istruzione <code>continue</code> salta il resto dell'iterazione corrente e passa direttamente all'iterazione successiva del loop.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/","title":"Visibilit\u00e0 e organizzazione del codice in C","text":"<p>Oltre a sapere cos\u2019\u00e8 una variabile, \u00e8 fondamentale capire dove \u00e8 visibile e come organizzare i file in un progetto embedded.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#file-c-e-h","title":"File <code>.c</code> e <code>.h</code>","text":"<p>In un progetto in C i file sono generalmente divisi in due categorie:</p> <ul> <li>File <code>.c</code> \u2192 contengono il codice implementativo (funzioni, logica).  </li> <li>File <code>.h</code> \u2192 contengono le dichiarazioni (prototipi di funzioni, definizioni di strutture, costanti, variabili globali).  </li> </ul>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#esempio","title":"Esempio","text":"<p>sensore.h <pre><code>#ifndef SENSORE_H\n#define SENSORE_H\n\nvoid sensore_init(void);\nint sensore_leggi(void);\n\n#endif\n````\n\n**sensore.c**\n\n```c\n#include \"sensore.h\"\n\nvoid sensore_init(void) {\n    // inizializzazione hardware\n}\n\nint sensore_leggi(void) {\n    return 42; // valore di esempio\n}\n</code></pre></p> <p>Cos\u00ec il modulo <code>sensore</code> pu\u00f2 essere usato anche da altri file senza duplicare il codice.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#visibilita-delle-variabili","title":"Visibilit\u00e0 delle variabili","text":"<p>La visibilit\u00e0 definisce in quali file o funzioni una variabile \u00e8 accessibile.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#variabili-locali","title":"Variabili locali","text":"<p>Dichiarate dentro una funzione \u2192 visibili solo l\u00ec, allocate nello stack.</p> <pre><code>void funzione() {\n    int x = 10; // visibile solo dentro questa funzione\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#variabili-globali","title":"Variabili globali","text":"<p>Dichiarate fuori da ogni funzione \u2192 visibili in tutto il file <code>.c</code>.</p> <pre><code>int contatore = 0; // visibile in tutto il file\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#cose-extern","title":"Cos\u2019\u00e8 extern","text":"<p>La keyword <code>extern</code> in C serve a dichiarare una variabile o funzione definita in un altro file, cos\u00ec che il compilatore sappia che esiste e che verr\u00e0 risolta in fase di linking.</p> <p>In pratica:</p> <ul> <li><code>dichiarazione</code> = dire \u201cquesta variabile/funzione esiste da qualche parte\u201d.</li> <li><code>definizione</code> = riservare davvero memoria o scrivere il codice.</li> </ul> <p><code>extern</code> riguarda solo le variabili globali (anche se si pu\u00f2 usare pure con funzioni, ma l\u00ec \u00e8 implicito).</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#senza-extern-definizione","title":"Senza <code>extern</code> (definizione)","text":"<p>Se scrivi:</p> <pre><code>int counter = 0;\n</code></pre> <p>questa \u00e8 una definizione: il compilatore alloca spazio in memoria per <code>counter</code>.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#con-extern-dichiarazione","title":"Con <code>extern</code> (dichiarazione)","text":"<p>Se scrivi:</p> <pre><code>extern int counter;\n</code></pre> <p>questa \u00e8 solo una dichiarazione: non alloca memoria, dice solo \u201cda qualche parte esiste un <code>int counter</code>\u201d. In questo modo puoi usare <code>counter</code> anche in un file diverso da quello in cui \u00e8 stato definito.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#esempio-pratico-con-piu-file","title":"Esempio pratico con pi\u00f9 file","text":"<p>file1.c</p> <pre><code>#include &lt;stdio.h&gt;\n\nint counter = 42;   // definizione (memoria allocata qui)\n\nvoid printCounter(void) {\n    printf(\"counter = %d\\n\", counter);\n}\n</code></pre> <p>file2.c</p> <pre><code>#include &lt;stdio.h&gt;\n\nextern int counter;  // dichiarazione (nessuna memoria allocata)\n\nvoid increment(void) {\n    counter++;\n}\n</code></pre> <p>main.c</p> <pre><code>void printCounter(void);\nvoid increment(void);\n\nint main(void) {\n    printCounter();  // counter = 42\n    increment();\n    printCounter();  // counter = 43\n    return 0;\n}\n</code></pre> <p>Compilando tutti e tre insieme funziona perch\u00e9 il linker trova <code>counter</code> definito in <code>file1.c</code>:</p> <pre><code>gcc file1.c file2.c main.c -o program\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#casi-tipici-in-embedded","title":"Casi tipici in Embedded","text":"<p>Noi <code>extern</code> lo usiamo per:</p> <ul> <li>Variabili globali condivise tra pi\u00f9 moduli (es. uno stato della macchina, un buffer CAN, una coda FreeRTOS).</li> <li>Funzioni scritte in un file ma richiamate da altri, anche se l\u00ec l\u2019<code>extern</code> \u00e8 implicito.</li> <li>Header file: metti <code>extern</code> l\u00ec, la definizione vera sta nel <code>.c</code>.</li> </ul> <p>Esempio:</p> <pre><code>// uart.h\n#ifndef UART_H\n#define UART_H\n\nextern QueueHandle_t uartQueue;   // dichiarazione, visibile a tutti i .c\n\nvoid UART_Init(void);\n\n#endif\n</code></pre> <pre><code>// uart.c\n#include \"uart.h\"\n\nQueueHandle_t uartQueue;          // definizione vera (memoria allocata qui)\n\nvoid UART_Init(void) {\n    uartQueue = xQueueCreate(10, sizeof(uint8_t));\n}\n</code></pre> <p>Cos\u00ec ogni modulo che include <code>uart.h</code> sa che esiste <code>uartQueue</code>, ma la memoria viene allocata una volta sola in <code>uart.c</code>.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#il-ruolo-di-static","title":"Il ruolo di <code>static</code>","text":"<p>La parola chiave <code>static</code> ha due significati diversi a seconda del contesto. Il primo caso sono le variabili locali statiche, che mantengono il loro valore tra pi\u00f9 chiamate della funzione.</p> <pre><code>void funzione() {\n    static int chiamate = 0;\n    chiamate++;\n    printf(\"%d\\n\", chiamate);\n}\n</code></pre> <p>Ogni volta che chiamo <code>funzione()</code>, la variabile non si azzera ma \u201cricorda\u201d il valore precedente. il secondo caso sono le variabili e funzioni a livello di file, che limitano la visibilit\u00e0 al solo file <code>.c</code> (non esportate).</p> <pre><code>static int interno = 5;\n\nstatic void helper() {\n    // usata solo in questo file\n}\n</code></pre> <p>Questo \u00e8 molto utile per l\u2019incapsulamento, evitando che variabili o funzioni \u201cinterne\u201d inquinino lo spazio globale del progetto.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#buone-pratiche","title":"Buone pratiche","text":"<ul> <li>Le variabili devono essere il pi\u00f9 locali possibile.</li> <li>Le globali vanno usate solo se davvero necessarie.</li> <li>Usare <code>static</code> per tutto ci\u00f2 che \u00e8 interno a un modulo (<code>.c</code>).</li> <li>Negli header <code>.h</code> mettere solo:<ul> <li>prototipi delle funzioni pubbliche,</li> <li>definizioni di costanti/struct/enum,</li> <li>dichiarazioni <code>extern</code> se serve condividere una variabile globale.</li> </ul> </li> </ul> <p>Cos\u00ec il progetto rimane ordinato, modulare e pi\u00f9 facile da manutenere.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/","title":"Binary tree","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#introduzione-e-terminologia","title":"Introduzione e terminologia","text":"<p>Mentre le liste sono strutture lineari, gli Alberi sono strutture gerarchiche. L'Albero Binario \u00e8 una delle strutture dinamiche non lineari pi\u00f9 importanti per la ricerca, l'inserimento e la cancellazione efficienti.</p> <p>Un Albero Binario \u00e8 una struttura dati gerarchica composta da nodi. La caratteristica fondamentale \u00e8 il vincolo strutturale: ogni nodo pu\u00f2 avere al massimo due figli, storicamente chiamati figlio sinistro e figlio destro.</p> <p>Il nodo di partenza \u00e8 la radice (root), che non ha antenati. I nodi senza figli sono chiamati foglie (leaves). La sequenza di nodi da un punto all'altro si chiama cammino, e la lunghezza del cammino dalla radice a un nodo \u00e8 la sua profondit\u00e0 (depth). L'altezza dell'albero \u00e8 la profondit\u00e0 massima di qualsiasi nodo foglia.</p> <p>Termini fondamentali:</p> <ul> <li>Nodo: elemento con valore e puntatori a figli.</li> <li>Radice (root): nodo senza genitore.</li> <li>Foglia (leaf): nodo senza figli.   </li> <li>Altezza di un nodo: lunghezza del percorso pi\u00f9 lungo fino a una foglia (numero di archi).</li> <li>Profondit\u00e0/level: distanza dalla radice (root level = 0).</li> <li>Sottalbero: albero formato da un nodo e tutti i suoi discendenti.</li> </ul> <p>Forme speciali:</p> <ul> <li>Albero pieno (full/proper): ogni nodo ha 0 o 2 figli.</li> <li>Albero perfetto (perfect): pieno e tutti i livelli sono completi; ha <code>2^{h+1}-1</code> nodi (h = altezza).</li> <li>Albero completo (complete): tutti i livelli compresi (tranne l'ultimo) sono pieni, e i nodi dell'ultimo sono a sinistra.</li> <li>Albero bilanciato: altezza <code>O(log n)</code>; definizione pu\u00f2 variare (AVL, Red\u2011Black, B\u2011Tree per multiway ecc.).</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#tipologie-di-alberi-binari","title":"Tipologie di alberi binari","text":"<ul> <li>Binary Tree: generico.</li> <li>Binary Search Tree (BST): per ogni nodo, <code>left-&gt;key &lt; node-&gt;key &lt; right-&gt;key</code> (chiave univoca o gestire duplicati).</li> <li>AVL tree: BST auto\u2011bilanciato con fattore di bilanciamento <code>height(left)-height(right)</code> \u2208 {-1,0,1}; rotazioni per mantenere bilanciamento.</li> <li>Red\u2011Black tree: BST bilanciato che garantisce altezza <code>O(log n)</code> usando colori e rotazioni.</li> <li>Splay tree: BST auto\u2011adattivo che porta l'ultimo elemento accesso in radice (good for locality).</li> <li>Treap / Cartesian tree: BST con priorit\u00e0 casuali (heap property) \u2014 utile per implementazioni probabilisticamente bilanciate.</li> <li>Binary Heap: struttura completa rappresentata con array; utile per priority queue; non \u00e8 un BST.</li> <li>Threaded binary tree: usa puntatori \"thread\" al successore/predecessore inorder per traversal senza stack/ricorsione.</li> <li>Albero di espressione: nodi interni sono operatori, foglie sono operandi; valutazione postfix/infix.</li> <li>Segment tree / interval tree: alberi binari (implicitamente) per query su intervalli (range sum/min/max) con aggiornamenti.</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#traversal-algoritmi-e-implementazioni","title":"Traversal: algoritmi e implementazioni","text":"<p>Quando si parla di visita di un albero binario, ci si riferisce all\u2019ordine con cui vengono \u201ctoccati\u201d i nodi. Esistono due grandi famiglie: la visita in profondit\u00e0 (DFS, Depth-First Search) e la visita in ampiezza (BFS, Breadth-First Search).</p> <p>Le tre visite DFS classiche</p> <ol> <li> <p>Preorder     Si parte sempre dal nodo corrente (la radice, se \u00e8 la prima volta), lo si visita subito e poi si scende prima nel sottoalbero sinistro e poi nel destro.     \u00c8 come se il padre avesse la priorit\u00e0: lo guardi subito, prima di interessarti ai figli.     Questo tipo di visita \u00e8 molto utile, ad esempio, se vuoi salvare o clonare la struttura dell\u2019albero, perch\u00e9 mantieni prima l\u2019informazione del nodo e poi dei suoi discendenti.</p> </li> <li> <p>Inorder     In questo caso l\u2019ordine \u00e8: prima il sottoalbero sinistro, poi il nodo corrente e infine il sottoalbero destro.     \u00c8 la visita pi\u00f9 importante quando si parla di alberi binari di ricerca (BST), perch\u00e9 restituisce gli elementi in ordine crescente.     \u00c8 come leggere un libro da sinistra a destra: prima quello che c\u2019\u00e8 a sinistra, poi il centro, poi la parte destra.</p> </li> <li> <p>Postorder     Qui invece si visita prima il sottoalbero sinistro, poi il destro e solo per ultimo il nodo corrente.     \u00c8 come dire: \u201cprima mi occupo dei figli e solo dopo del padre\u201d.     Questo ordine \u00e8 molto comodo quando bisogna cancellare un albero dalla memoria, perch\u00e9 si eliminano prima i nodi pi\u00f9 in basso e solo alla fine le radici. Allo stesso modo, viene usato negli alberi di espressioni per calcolare il valore: prima si calcolano i termini elementari e solo alla fine l\u2019operazione principale.</p> </li> </ol> <p>BFS \u2014 Level Order</p> <p>Diverso \u00e8 il caso della visita in ampiezza (BFS), detta anche \u201cper livelli\u201d. Qui non si scende in profondit\u00e0 subito, ma si procede un livello alla volta: prima la radice, poi tutti i figli della radice, poi i figli di quei figli, e cos\u00ec via. \u00c8 un po\u2019 come leggere l\u2019albero riga per riga, da sinistra a destra. Questa modalit\u00e0 viene spesso usata quando serve dare priorit\u00e0 alla distanza dalla radice, ad esempio per calcolare la profondit\u00e0 minima o per trovare il cammino pi\u00f9 breve in alberi o grafi.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#traversal-ricorsivi-c","title":"Traversal ricorsivi (C)","text":"<pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct Node {\n    int key;\n    struct Node *left, *right;\n} Node;\n\nvoid preorder(Node* r){\n    if(!r) return;\n    printf(\"%d \", r-&gt;key);\n    preorder(r-&gt;left);\n    preorder(r-&gt;right);\n}\n\nvoid inorder(Node* r){\n    if(!r) return;\n    inorder(r-&gt;left);\n    printf(\"%d \", r-&gt;key);\n    inorder(r-&gt;right);\n}\n\nvoid postorder(Node* r){\n    if(!r) return;\n    postorder(r-&gt;left);\n    postorder(r-&gt;right);\n    printf(\"%d \", r-&gt;key);\n}\n</code></pre> <p>I traversal ricorsivi sono semplici ma usano stack di chiamate <code>O(h)</code> (altezza). In sistemi embedded bisogna fare attenzione alla profondit\u00e0 dello stack.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#traversal-iterativi-con-stack","title":"Traversal iterativi con stack","text":"<pre><code>#include &lt;stdlib.h&gt;\n\ntypedef struct StackNode {\n    Node* t;\n    struct StackNode* next;\n} StackNode;\n\nvoid push(StackNode** top, Node* t) { \n    StackNode* n = malloc(sizeof(StackNode));\n    n-&gt;t=t;\n    n-&gt;next=*top;\n    *top=n;\n}\n\nNode* pop(StackNode** top) {\n    if(!*top) return NULL;\n    StackNode* n=*top;\n    Node* t=n-&gt;t;\n    *top = n-&gt;next;\n    free(n);\n    return t;\n}\n\nint empty(StackNode* top) {\n    return top==NULL;\n}\n\nvoid inorder_iter(Node* root){\n    StackNode* st = NULL;\n    Node* cur = root;\n    while(cur || !empty(st)){\n        while(cur){ push(&amp;st, cur); cur = cur-&gt;left; }\n        cur = pop(&amp;st);\n        printf(\"%d \", cur-&gt;key);\n        cur = cur-&gt;right;\n    }\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#morris-inorder-o1-space","title":"Morris Inorder (O(1) space)","text":"<p>Idea: usare collegamenti temporanei al predecessore inorder.</p> <pre><code>void inorder_morris(Node* root){\n    Node* cur = root;\n    while(cur){\n        if(!cur-&gt;left){\n            printf(\"%d \", cur-&gt;key);\n            cur = cur-&gt;right;\n        } else {\n            Node* pred = cur-&gt;left;\n            while(pred-&gt;right &amp;&amp; pred-&gt;right != cur) pred = pred-&gt;right;\n            if(!pred-&gt;right){\n                pred-&gt;right = cur; // thread\n                cur = cur-&gt;left;\n            } else {\n                pred-&gt;right = NULL; // restore\n                printf(\"%d \", cur-&gt;key);\n                cur = cur-&gt;right;\n            }\n        }\n    }\n}\n</code></pre> <p>Morris \u00e8 utile quando la memoria \u00e8 critica; modifica temporaneamente la struttura e la ripristina.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#levelorder-bfs","title":"Level\u2011order (BFS)","text":"<p>Usa una coda (queue):</p> <pre><code>#include &lt;stdlib.h&gt;\n\ntypedef struct QNode {\n  Node* t;\n  struct QNode* next;\n} QNode;\n\ntypedef struct Queue {\n  QNode *head, *tail;\n} Queue;\n\nvoid qpush(Queue* q, Node* t) {\n  QNode* n = malloc(sizeof(QNode));\n  n-&gt;t = t;\n  n-&gt;next = NULL;\n  if (!q-&gt;tail)\n    q-&gt;head = q-&gt;tail = n;\n  else {\n    q-&gt;tail-&gt;next = n;\n    q-&gt;tail = n;\n  }\n}\n\nNode* qpop(Queue* q) {\n  if (!q-&gt;head) return NULL;\n  QNode* n = q-&gt;head;\n  Node* t = n-&gt;t;\n  q-&gt;head = n-&gt;next;\n  if (!q-&gt;head) q-&gt;tail = NULL;\n  free(n);\n  return t;\n}\n\nint qempty(Queue* q) { return q-&gt;head == NULL; }\n\nvoid level_order(Node* root) {\n  if (!root) return;\n  Queue q = {0};\n  qpush(&amp;q, root);\n  while (!qempty(&amp;q)) {\n    Node* n = qpop(&amp;q);\n    printf(\"%d \", n-&gt;key);\n    if (n-&gt;left) qpush(&amp;q, n-&gt;left);\n    if (n-&gt;right) qpush(&amp;q, n-&gt;right);\n  }\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#bst-binary-search-tree","title":"BST (Binary Search Tree)","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#proprieta-e-complessita","title":"Propriet\u00e0 e complessit\u00e0","text":"<p>Le operazioni fondamentali su un albero binario di ricerca, cio\u00e8 ricerca, inserimento e cancellazione, hanno una complessit\u00e0 che dipende fortemente dalla forma dell\u2019albero. Nel caso \u201cideale\u201d, quando l\u2019albero \u00e8 bilanciato, ogni livello \u00e8 riempito in modo abbastanza uniforme e quindi l\u2019altezza dell\u2019albero cresce come il logaritmo del numero di nodi. Questo significa che in media la ricerca, l\u2019inserimento e la cancellazione richiedono un numero di passi proporzionale a <code>log n</code>, dove <code>n</code> \u00e8 il numero di elementi.</p> <p>Tuttavia, il BST di per s\u00e9 non garantisce il bilanciamento. Se, ad esempio, i dati vengono inseriti in ordine crescente, l\u2019albero tende a degenerare in una semplice linked list: ogni nodo ha solo il figlio destro, e l\u2019altezza diventa <code>n</code>. In questa situazione, tutte le operazioni fondamentali (ricerca, inserimento, cancellazione) peggiorano fino a richiedere tempo lineare <code>O(n)</code>.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#implementazione-base-in-c-ricorsiva","title":"Implementazione base in C (ricorsiva)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct Node {\n  int key;\n  struct Node *left, *right;\n} Node;\n\nNode* new_node(int key) {\n  Node* n = malloc(sizeof(Node));\n  if (!n) return NULL;\n  n-&gt;key = key;\n  n-&gt;left = n-&gt;right = NULL;\n  return n;\n}\n\nNode* bst_insert(Node* root, int key) {\n  if (!root) return new_node(key);\n  if (key &lt; root-&gt;key)\n    root-&gt;left = bst_insert(root-&gt;left, key);\n  else if (key &gt; root-&gt;key)\n    root-&gt;right = bst_insert(root-&gt;right, key);\n  // se permetti duplicati, scegli una policy\n  return root;\n}\n\nNode* bst_search(Node* root, int key) {\n  while (root &amp;&amp; root-&gt;key != key)\n    root = (key &lt; root-&gt;key) ? root-&gt;left : root-&gt;right;\n  return root;\n}\n\nNode* bst_find_min(Node* root) {\n  while (root &amp;&amp; root-&gt;left) root = root-&gt;left;\n  return root;\n}\n\nNode* bst_delete(Node* root, int key) {\n  if (!root) return NULL;\n  if (key &lt; root-&gt;key)\n    root-&gt;left = bst_delete(root-&gt;left, key);\n  else if (key &gt; root-&gt;key)\n    root-&gt;right = bst_delete(root-&gt;right, key);\n  else {\n    if (!root-&gt;left) {\n      Node* r = root-&gt;right;\n      free(root);\n      return r;\n    } else if (!root-&gt;right) {\n      Node* l = root-&gt;left;\n      free(root);\n      return l;\n    } else {\n      Node* succ = bst_find_min(root-&gt;right);\n      root-&gt;key = succ-&gt;key;\n      root-&gt;right = bst_delete(root-&gt;right, succ-&gt;key);\n    }\n  }\n  return root;\n}\n</code></pre> <p><code>bst_delete</code> gestisce i tre casi (0, 1, 2 figli). L'approccio mostrato copia la chiave del successore e cancella il successore.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#bilanciamento-avl-e-redblack","title":"Bilanciamento: AVL e Red\u2011Black","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#avl-dettagli-pratici","title":"AVL (dettagli pratici)","text":"<p>Gli alberi AVL sono alberi binari di ricerca che mantengono sempre un buon livello di equilibrio. Per fare questo, ad ogni nodo viene associato un numero chiamato fattore di bilanciamento (Balance Factor, BF), che non \u00e8 altro che la differenza tra l\u2019altezza del sottoalbero sinistro e quella del sottoalbero destro. Finch\u00e9 questo valore rimane compreso tra \u22121 e +1, l\u2019albero \u00e8 considerato bilanciato. Se invece un\u2019operazione di inserimento o cancellazione fa s\u00ec che in qualche nodo il fattore di bilanciamento esca da questo intervallo, bisogna riequilibrare la struttura tramite una o pi\u00f9 rotazioni.</p> <p>Le rotazioni sono semplici ristrutturazioni locali dell\u2019albero che ne modificano la forma ma non l\u2019ordinamento dei dati. Esistono quattro casi principali:</p> <ul> <li> <p>Se l\u2019albero \u00e8 troppo \u201cpesante\u201d a sinistra (BF &gt; 1) perch\u00e9 il nuovo nodo \u00e8 stato inserito a sua volta nel ramo sinistro del figlio sinistro, si esegue una rotazione a destra. Questo caso \u00e8 chiamato LL.</p> </li> <li> <p>Al contrario, se \u00e8 troppo sbilanciato a destra (BF &lt; \u22121) e il nuovo nodo si trova nel ramo destro del figlio destro, la soluzione \u00e8 una rotazione a sinistra: il caso RR.</p> </li> <li> <p>Le cose diventano leggermente pi\u00f9 complesse se lo sbilanciamento deriva da un inserimento \u201cincrociato\u201d. Se il nodo \u00e8 andato a finire nel ramo destro del figlio sinistro, prima si fa una rotazione a sinistra sul figlio sinistro e poi una rotazione a destra sulla radice: questo \u00e8 il caso LR.</p> </li> <li> <p>Infine, se il nodo \u00e8 nel ramo sinistro del figlio destro, la correzione \u00e8 simmetrica: prima una rotazione a destra sul figlio destro e poi una rotazione a sinistra sulla radice, cio\u00e8 il caso RL.</p> </li> </ul> <p>Con queste quattro operazioni si riesce a riportare sempre l\u2019albero entro i limiti di bilanciamento. In questo modo, gli alberi AVL garantiscono che le operazioni fondamentali come ricerca, inserimento e cancellazione restino sempre efficienti, con complessit\u00e0 <code>O(log n)</code> anche nei casi peggiori.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#codice-essenziale-avl-insert-rotazioni","title":"Codice essenziale (AVL insert + rotazioni)","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\ntypedef struct AVLNode { int key; int height; struct AVLNode *left, *right; } AVLNode;\n\nint max(int a,int b){ return a&gt;b?a:b; }\nint height(AVLNode* n){ return n ? n-&gt;height : 0; }\n\nAVLNode* new_avl_node(int key){ AVLNode* n = malloc(sizeof(AVLNode)); if(!n) return NULL; n-&gt;key=key; n-&gt;left=n-&gt;right=NULL; n-&gt;height=1; return n; }\n\nAVLNode* right_rotate(AVLNode* y){\n    AVLNode* x = y-&gt;left;\n    AVLNode* T2 = x-&gt;right;\n    x-&gt;right = y;\n    y-&gt;left = T2;\n    y-&gt;height = 1 + max(height(y-&gt;left), height(y-&gt;right));\n    x-&gt;height = 1 + max(height(x-&gt;left), height(x-&gt;right));\n    return x; // nuova radice\n}\n\nAVLNode* left_rotate(AVLNode* x){\n    AVLNode* y = x-&gt;right;\n    AVLNode* T2 = y-&gt;left;\n    y-&gt;left = x;\n    x-&gt;right = T2;\n    x-&gt;height = 1 + max(height(x-&gt;left), height(x-&gt;right));\n    y-&gt;height = 1 + max(height(y-&gt;left), height(y-&gt;right));\n    return y;\n}\n\nAVLNode* avl_insert(AVLNode* node, int key){\n    if(!node) return new_avl_node(key);\n    if(key &lt; node-&gt;key) node-&gt;left = avl_insert(node-&gt;left, key);\n    else if(key &gt; node-&gt;key) node-&gt;right = avl_insert(node-&gt;right, key);\n    else return node; // duplicati non gestiti\n\n    node-&gt;height = 1 + max(height(node-&gt;left), height(node-&gt;right));\n    int balance = height(node-&gt;left) - height(node-&gt;right);\n\n    // LL\n    if(balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) return right_rotate(node);\n    // RR\n    if(balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key) return left_rotate(node);\n    // LR\n    if(balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key){ node-&gt;left = left_rotate(node-&gt;left); return right_rotate(node); }\n    // RL\n    if(balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key){ node-&gt;right = right_rotate(node-&gt;right); return left_rotate(node); }\n\n    return node;\n}\n</code></pre> <p>L'implementazione della cancellazione in AVL \u00e8 pi\u00f9 lunga (si applicano rotazioni dopo la cancellazione per ribilanciare). L'idea \u00e8 la stessa: dopo ogni modifica si aggiorna <code>height</code> e si controlla il <code>balance</code>.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#52-redblack-concetti","title":"5.2 Red\u2011Black (concetti)","text":"<p>Gli alberi Red-Black sono un\u2019altra famiglia di alberi binari di ricerca bilanciati. L\u2019idea alla base \u00e8 un po\u2019 diversa rispetto agli AVL: invece di tenere sotto controllo con precisione l\u2019altezza di ogni nodo, si assegna a ciascun nodo un colore, che pu\u00f2 essere rosso o nero, e si impongono alcune regole che garantiscono che l\u2019albero resti \u201cabbastanza\u201d bilanciato.</p> <p>Le regole fondamentali sono queste:</p> <ul> <li> <p>Ogni nodo deve essere colorato in rosso o in nero.</p> </li> <li> <p>La radice dell\u2019albero \u00e8 sempre nera.</p> </li> <li> <p>Le foglie vuote (i nodi NIL) vengono considerate nere.</p> </li> <li> <p>Non possono esserci due nodi rossi consecutivi: se un nodo \u00e8 rosso, allora i suoi figli devono per forza essere neri.</p> </li> <li> <p>Qualunque percorso che parte da un nodo e arriva a una foglia NIL deve attraversare lo stesso numero di nodi neri. Questo valore prende il nome di black height e garantisce che i cammini nell\u2019albero non possano divergere troppo in lunghezza.</p> </li> </ul> <p>Grazie a queste propriet\u00e0, l\u2019albero Red-Black resta sempre bilanciato in modo \u201clasco\u201d: non perfettamente come un AVL, ma comunque con altezza proporzionale a <code>log n</code>. Questo significa che operazioni come inserimento, ricerca e cancellazione restano sempre efficienti.</p> <p>Naturalmente, mantenere queste regole non \u00e8 automatico. Dopo un\u2019operazione di inserimento o di cancellazione pu\u00f2 capitare che alcune propriet\u00e0 vengano violate. In questi casi bisogna aggiustare la struttura con una combinazione di rotazioni (come negli AVL) e cambi di colore. L\u2019algoritmo \u00e8 un po\u2019 pi\u00f9 articolato rispetto agli AVL, ma la garanzia \u00e8 che dopo pochi passi l\u2019albero torna valido.</p> <p>Proprio per la loro efficienza e stabilit\u00e0, gli alberi Red-Black vengono usati molto spesso in librerie e sistemi reali. Ad esempio, le strutture dati <code>map</code> e <code>set</code> della libreria standard del C++ sono basate su alberi Red-Black, cos\u00ec come molte implementazioni interne nei kernel dei sistemi operativi.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#binary-heap-array-e-heapsort","title":"Binary Heap (array) e Heapsort","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#rappresentazione","title":"Rappresentazione","text":"<p>Un binary heap \u00e8 una struttura dati molto efficiente che si pu\u00f2 rappresentare in modo estremamente semplice utilizzando un array. L\u2019idea \u00e8 che l\u2019albero binario non venga memorizzato tramite puntatori, ma piuttosto sfruttando la posizione degli elementi nell\u2019array per ricostruire i legami padre-figlio.</p> <p>Se consideriamo un array <code>A[0..n-1]</code>, le relazioni sono fisse:</p> <ul> <li>il padre di un nodo che si trova in posizione <code>i</code> si calcola come <code>(i - 1) / 2</code>;</li> <li>il figlio sinistro \u00e8 in <code>2*i + 1</code>;</li> <li>il figlio destro \u00e8 in <code>2*i + 2</code>.</li> </ul> <p>In questo modo, non serve memorizzare puntatori espliciti: basta l\u2019indice.</p> <p>Ci sono due varianti principali di heap: min-heap e max-heap. Nel max-heap, che \u00e8 quello pi\u00f9 spesso utilizzato, la propriet\u00e0 da rispettare \u00e8 che ogni nodo sia maggiore o uguale ai propri figli. In altre parole, il valore nella posizione del padre deve sempre essere almeno grande quanto quello dei suoi figli. Grazie a questa regola, l\u2019elemento massimo dell\u2019intera struttura si trova sempre nella radice, cio\u00e8 nella cella <code>A[0]</code>. Nel caso del min-heap, invece, vale la propriet\u00e0 opposta: il minimo si trova sempre in cima.</p> <p>Questa rappresentazione permette di gestire in maniera molto veloce operazioni come inserimento, estrazione del massimo/minimo e costruzione di un heap a partire da un array. Inoltre, proprio grazie alla sua semplicit\u00e0, l\u2019heap binario \u00e8 alla base di un algoritmo di ordinamento molto famoso: l\u2019heapsort.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#operazioni-principali","title":"Operazioni principali","text":"<p>Le operazioni fondamentali che permettono di lavorare con un binary heap sono poche ma molto potenti.</p> <p>Quando si vuole inserire un nuovo elemento nell\u2019heap, lo si mette inizialmente in fondo all\u2019array, cio\u00e8 nella prima posizione libera. A questo punto per\u00f2 l\u2019elemento potrebbe violare la propriet\u00e0 dell\u2019heap (ad esempio, in un max-heap potrebbe essere pi\u00f9 grande del suo padre). Per ristabilire l\u2019ordine, si esegue l\u2019operazione chiamata sift up: in pratica, si confronta il nodo con il suo padre e, se \u00e8 maggiore, i due vengono scambiati. Questo controllo continua a salire lungo l\u2019albero finch\u00e9 la propriet\u00e0 dell\u2019heap non \u00e8 di nuovo rispettata.</p> <p>L\u2019operazione opposta avviene quando si vuole estrarre l\u2019elemento massimo (nel max-heap). In questo caso si prende la radice, cio\u00e8 <code>A[0]</code>, che contiene sempre il valore pi\u00f9 grande. Per non lasciare un buco, l\u2019ultimo elemento dell\u2019array viene spostato provvisoriamente in cima. A questo punto per\u00f2 \u00e8 probabile che la propriet\u00e0 dell\u2019heap non sia rispettata, quindi bisogna farlo \u201cscendere\u201d nel posto giusto. Questo si fa con l\u2019operazione di sift down: si confronta il nodo con i figli e, se uno dei figli \u00e8 pi\u00f9 grande, si scambia con quello pi\u00f9 grande dei due. L\u2019operazione continua finch\u00e9 il nodo non si trova in una posizione che rispetta le regole.</p> <p>Infine, c\u2019\u00e8 l\u2019operazione di build heap, che costruisce un heap partendo da un array arbitrario di <code>n</code> elementi. Un metodo ingenuo sarebbe inserire gli elementi uno alla volta e fare <code>sift up</code> ogni volta, ma questo porta a una complessit\u00e0 <code>O(n log n)</code>. In realt\u00e0, esiste un algoritmo pi\u00f9 efficiente: si parte dal basso e si applica <code>sift down</code> solo ai nodi interni (cio\u00e8 quelli che hanno figli). In questo modo si riesce a trasformare l\u2019intero array in un heap in tempo lineare <code>O(n)</code>.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#codice-e-heapsort","title":"Codice e heapsort","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid swap(int *a,int *b){ int t=*a; *a=*b; *b=t; }\n\nvoid sift_down(int *A, int n, int i){\n    int largest = i;\n    int l = 2*i+1, r = 2*i+2;\n    if(l &lt; n &amp;&amp; A[l] &gt; A[largest]) largest = l;\n    if(r &lt; n &amp;&amp; A[r] &gt; A[largest]) largest = r;\n    if(largest != i){ swap(&amp;A[i], &amp;A[largest]); sift_down(A, n, largest); }\n}\n\nvoid build_heap(int *A, int n){\n    for(int i = n/2 - 1; i &gt;= 0; --i) sift_down(A, n, i);\n}\n\nvoid heapsort(int *A, int n){\n    build_heap(A, n);\n    for(int i = n-1; i &gt; 0; --i){ swap(&amp;A[0], &amp;A[i]); sift_down(A, i, 0); }\n}\n</code></pre> <p><code>heapsort</code> \u00e8 <code>O(n log n)</code> worst/average; uso in\u2011place, stabile? non stabile.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#tree-sort","title":"Tree sort","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#cose-il-treesort","title":"Cos\u2019\u00e8 il TreeSort","text":"<p>Il TreeSort \u00e8 un algoritmo di ordinamento che sfrutta un albero binario di ricerca (BST). L\u2019idea \u00e8 molto semplice:</p> <ol> <li>Si parte da una sequenza di numeri non ordinati.</li> <li>Si inseriscono tutti gli elementi in un BST.<ul> <li>L\u2019inserimento segue la regola del BST: i valori minori vanno a sinistra, i maggiori a destra.</li> </ul> </li> <li>Una volta costruito l\u2019albero, si esegue una visita inorder.<ul> <li>Ricorda che in un BST la visita inorder restituisce sempre gli elementi in ordine crescente.</li> </ul> </li> </ol> <p>Il risultato finale sar\u00e0 la sequenza ordinata.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#complessita","title":"Complessit\u00e0","text":"<ul> <li>Caso medio (albero bilanciato):<ul> <li>Inserire <code>n</code> elementi costa <code>O(n log n)</code> (perch\u00e9 ogni inserimento richiede log n).</li> <li>La visita inorder costa <code>O(n)</code>.</li> <li>Complessivamente: O(n log n).</li> </ul> </li> <li>Caso peggiore (albero degenerato):<ul> <li>Se i dati sono gi\u00e0 ordinati e si usa un BST semplice (non bilanciato), l\u2019albero diventa una lista.</li> <li>Ogni inserimento costa <code>O(n)</code> \u2192 tempo totale <code>O(n\u00b2)</code>.</li> </ul> </li> </ul> <p>Per questo, in pratica il TreeSort \u00e8 efficiente solo se si utilizza un albero bilanciato (AVL, Red-Black). Con un AVL, ad esempio, si garantisce sempre <code>O(n log n)</code>.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Nodo dell\u2019albero\ntypedef struct Node {\n    int key;\n    struct Node *left, *right;\n} Node;\n\n// Creazione nuovo nodo\nNode* newNode(int key) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node-&gt;key = key;\n    node-&gt;left = node-&gt;right = NULL;\n    return node;\n}\n\n// Inserimento nel BST\nNode* insert(Node* root, int key) {\n    if (root == NULL) return newNode(key);\n    if (key &lt; root-&gt;key)\n        root-&gt;left = insert(root-&gt;left, key);\n    else\n        root-&gt;right = insert(root-&gt;right, key);\n    return root;\n}\n\n// Visita inorder (stampa ordinata)\nvoid inorder(Node* root) {\n    if (root != NULL) {\n        inorder(root-&gt;left);\n        printf(\"%d \", root-&gt;key);\n        inorder(root-&gt;right);\n    }\n}\n\n// TreeSort: costruisce BST e stampa ordinato\nvoid treeSort(int arr[], int n) {\n    Node* root = NULL;\n\n    // Costruzione albero\n    for (int i = 0; i &lt; n; i++) {\n        root = insert(root, arr[i]);\n    }\n\n    // Stampa ordinata con inorder\n    inorder(root);\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {5, 3, 7, 2, 8, 1, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Array ordinato: \");\n    treeSort(arr, n);\n\n    return 0;\n}\n</code></pre> <p>TreeSort \u00e8 elegante perch\u00e9 sfrutta direttamente le propriet\u00e0 del BST. Tuttavia, nella pratica viene usato poco rispetto a QuickSort o HeapSort, proprio perch\u00e9 senza bilanciamento rischia di degradare a <code>O(n\u00b2)</code>.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#alberi-threaded","title":"Alberi Threaded","text":"<p>Un problema degli alberi binari tradizionali \u00e8 che spesso contengono molti puntatori NULL (quando un nodo non ha figlio sinistro o destro). Un threaded binary tree sfrutta questi puntatori vuoti per contenere invece riferimenti speciali che collegano i nodi tra loro in modo da facilitare la visita inorder.</p> <p>In pratica, se un nodo non ha figlio destro, il puntatore right viene usato per collegarlo direttamente al \u201csuccessore inorder\u201d. Allo stesso modo, se non ha figlio sinistro, left pu\u00f2 puntare al \u201cpredecessore inorder\u201d. Grazie a questi collegamenti (\u201cthreads\u201d), \u00e8 possibile attraversare l\u2019albero senza ricorsione n\u00e9 stack, scorrendo i nodi in ordine.</p> <p>Esempio minimo in C: <pre><code>typedef struct Node {\n    int key;\n    struct Node *left, *right;\n    int ltag, rtag; // 0 = figlio, 1 = thread\n} Node;\n</code></pre></p> <p>Il traversal inorder diventa una semplice camminata seguendo i thread quando non ci sono figli.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#alberi-di-espressione","title":"Alberi di espressione","text":"<p>Un expression tree rappresenta un\u2019espressione aritmetica come albero binario: - Le foglie contengono operandi (numeri o variabili). - I nodi interni contengono operatori (+, -, *, /).</p> <p>Esempio: l\u2019espressione <code>(3 + 5) * (2 - 1)</code> si rappresenta cos\u00ec: - Radice = <code>*</code> - Figlio sinistro = <code>+</code> con figli <code>3</code> e <code>5</code> - Figlio destro = <code>-</code> con figli <code>2</code> e <code>1</code></p> <p>La valutazione si fa con una visita postorder: prima si calcolano i sottoalberi, poi si applica l\u2019operatore.</p> <p>Snippet in C per valutazione: <pre><code>typedef struct Node {\n    char op; // operatore o '\\0' se foglia\n    int value;\n    struct Node *left, *right;\n} Node;\n\nint eval(Node* root) {\n    if (root-&gt;op == '\\0') return root-&gt;value; // foglia\n    int l = eval(root-&gt;left);\n    int r = eval(root-&gt;right);\n    switch(root-&gt;op) {\n        case '+': return l + r;\n        case '-': return l - r;\n        case '*': return l * r;\n        case '/': return l / r;\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#segment-tree","title":"## Segment Tree","text":"<p>Il segment tree \u00e8 un albero che permette di rispondere in modo molto veloce a query su intervalli (es. somma, minimo, massimo su un sottoarray). L\u2019idea \u00e8 rappresentare un array <code>A[0..n-1]</code> in un albero binario dove ogni nodo memorizza l\u2019informazione aggregata di un segmento.</p> <ul> <li>La radice rappresenta l\u2019intero array.</li> <li>Ogni nodo viene diviso in due: sinistra = prima met\u00e0, destra = seconda met\u00e0.</li> <li>Le foglie corrispondono agli elementi singoli.</li> </ul> <p>Con questa struttura si ottengono: - Costruzione: <code>O(n)</code> - Query su intervallo: <code>O(log n)</code> - Aggiornamento: <code>O(log n)</code></p> <p>Esempio in C per segment tree che calcola somme: <pre><code>#define MAXN 1000\nint seg[4*MAXN];\n\nvoid build(int arr[], int idx, int l, int r) {\n    if (l == r) {\n        seg[idx] = arr[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(arr, 2*idx, l, mid);\n    build(arr, 2*idx+1, mid+1, r);\n    seg[idx] = seg[2*idx] + seg[2*idx+1];\n}\n\nint query(int idx, int l, int r, int ql, int qr) {\n    if (qr &lt; l || ql &gt; r) return 0; // fuori intervallo\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) return seg[idx]; // interamente dentro\n    int mid = (l + r) / 2;\n    return query(2*idx, l, mid, ql, qr) + query(2*idx+1, mid+1, r, ql, qr);\n}\n\nvoid update(int idx, int l, int r, int pos, int val) {\n    if (l == r) {\n        seg[idx] = val;\n        return;\n    }\n    int mid = (l + r) / 2;\n    if (pos &lt;= mid) update(2*idx, l, mid, pos, val);\n    else update(2*idx+1, mid+1, r, pos, val);\n    seg[idx] = seg[2*idx] + seg[2*idx+1];\n}\n</code></pre></p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#implementazione-per-sistemi-embedded","title":"Implementazione per sistemi embedded","text":"<p>Negli ambienti embedded non \u00e8 sempre possibile affidarsi al normale <code>malloc</code>/<code>free</code>, sia per motivi di frammentazione, sia perch\u00e9 spesso la memoria dinamica \u00e8 limitata o non affidabile. Una strategia molto usata \u00e8 il pool allocator: si riserva un array statico di nodi e si gestisce a mano l\u2019allocazione (assegnando nodi liberi da una lista interna). Questo elimina sorprese e rende prevedibili i consumi.</p> <p>Altro punto importante \u00e8 la ricorsione. Molti algoritmi sugli alberi si basano su chiamate ricorsive (inorder, inserimenti, balancing, ecc.), ma sugli MCU lo stack pu\u00f2 essere ridotto. Due approcci tipici:</p> <ul> <li>riscrivere le funzioni in modo iterativo usando uno stack esplicito o una coda circolare;</li> <li>usare strutture alternative (ad es. alberi threaded) per eliminare del tutto la ricorsione.</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#tabelle-di-complessita-e-casi-duso","title":"Tabelle di complessit\u00e0 e casi d\u2019uso","text":"<p>Una visione d\u2019insieme delle principali strutture:</p> Struttura Inserimento Ricerca Cancellazione Note d\u2019uso principali BST semplice O(log n) medio / O(n) peggiore O(log n) / O(n) O(log n) / O(n) Semplice, didattico, inefficiente se non bilanciato AVL O(log n) O(log n) O(log n) Ottimo per query molto frequenti, altezza minima garantita Red-Black O(log n) O(log n) O(log n) Usato in librerie e kernel, inserimenti/cancellazioni pi\u00f9 veloci di AVL Heap binario O(log n) inserimento / estrazione O(1) per massimo O(log n) Base di heapsort, ottimo per code di priorit\u00e0 Segment Tree O(log n) aggiornamento / query \u2014 \u2014 Query su intervalli e aggiornamenti veloci Expression Tree dipende dalla costruzione \u2014 \u2014 Usato per calcoli simbolici e compilatori Threaded Tree come BST come BST come BST Evita stack/ricorsione, traversal pi\u00f9 leggero"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#errori-comuni-debugging-e-best-practice","title":"Errori comuni, debugging e best practice","text":"<ul> <li>Puntatori NULL mal gestiti: la causa pi\u00f9 tipica di crash negli alberi. Conviene centralizzare la creazione e inizializzazione dei nodi in una funzione unica.</li> <li>Sbilanciamento non trattato: se usi BST puri senza bilanciamento, gli input gi\u00e0 ordinati creano liste, degradando a <code>O(n)</code>. Per debugging puoi stampare l\u2019altezza dopo ogni inserimento e controllare se cresce troppo velocemente.</li> <li>Memory leak: dimenticare di liberare i nodi alla cancellazione. Meglio scrivere funzioni di <code>destroy_tree()</code> (postorder) o usare pool allocator che riciclano i nodi.</li> <li>Ricorsione profonda: rischi di stack overflow in MCU. Riscrivi gli algoritmi con cicli e stack manuali.</li> <li>Debugging traversal: per capire lo stato di un albero, stampa sempre le visite preorder/inorder/postorder: danno una \u201cfirma\u201d utile. Ad esempio, inorder ti mostra se un BST \u00e8 ancora valido.</li> <li>Rotazioni sbagliate in AVL/RB: errori classici stanno nella mancata aggiornazione dei puntatori o dei fattori di bilanciamento. Conviene scrivere test unitari con piccoli alberi e disegnare i casi a mano.</li> </ul> <p>Best practice generali:</p> <ul> <li>Scrivi funzioni piccole e modulari (es. <code>rotate_left</code>, <code>update_height</code>, <code>fix_violation</code>).</li> <li>Inserisci assert o logging sui fattori di bilanciamento / colori per verificare le invarianti.</li> <li>Se lavori in embedded, considera la versione iterativa + pool allocator come default.    </li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\n#define MAX_NODES 32   // massimo numero di nodi gestibili\n#define STACK_SIZE_32\n\ntypedef struct Node {\n    int key;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\n// Pool statico\nstatic Node node_pool[MAX_NODES];\nstatic int free_list[MAX_NODES];   // stack di indici liberi\nstatic int free_top = -1;\n\n// Inizializza il pool\nvoid init_pool(void) {\n    for (int i = 0; i &lt; MAX_NODES; i++) {\n        free_list[++free_top] = i;  // tutti liberi all\u2019inizio\n    }\n}\n\n// Alloca un nodo dal pool\nNode* alloc_node(int key) {\n    if (free_top &lt; 0) {\n        return NULL; // pool esaurito\n    }\n    int idx = free_list[free_top--];\n    Node* n = &amp;node_pool[idx];\n    n-&gt;key = key;\n    n-&gt;left = NULL;\n    n-&gt;right = NULL;\n    return n;\n}\n\n// Rilascia un nodo (lo rimette nel pool)\nvoid free_node(Node* n) {\n    int idx = n - node_pool;   // calcola indice nell\u2019array\n    free_list[++free_top] = idx;\n}\n</code></pre> <p>Implementazione senza ricorsione: <pre><code>Node* insert_bst(Node* root, int key) {\n    Node* new_node = alloc_node(key);\n    if (!new_node) return root;  // pool pieno\n\n    if (root == NULL) {\n        return new_node; // primo nodo\n    }\n\n    Node* curr = root;\n    Node* parent = NULL;\n\n    while (curr != NULL) {\n        parent = curr;\n        if (key &lt; curr-&gt;key)\n            curr = curr-&gt;left;\n        else\n            curr = curr-&gt;right;\n    }\n\n    if (key &lt; parent-&gt;key)\n        parent-&gt;left = new_node;\n    else\n        parent-&gt;right = new_node;\n\n    return root;\n}\n\nvoid inorder_iter(Node* root) {\n    Node* stack[STACK_SIZE];\n    int top = -1;\n    Node* curr = root;\n\n    while (curr != NULL || top &gt;= 0) {\n        while (curr != NULL) {\n            stack[++top] = curr;\n            curr = curr-&gt;left;\n        }\n        curr = stack[top--];\n        printf(\"%d \", curr-&gt;key);\n        curr = curr-&gt;right;\n    }\n}\n</code></pre></p>"},{"location":"codice/lezioni_di_c/strutture_dati/linked_list/","title":"Linked list (Lista concatenata)","text":"<p>La Lista Concatenata \u00e8 la SDD pi\u00f9 fondamentale. \u00c8 una sequenza di elementi chiamati nodi, dove ogni nodo contiene il dato e un puntatore al nodo successivo.</p> <p>Struttura di un nodo <pre><code>typedef struct Nodo {\n    int dato;             // Il dato che il nodo deve memorizzare\n    struct Nodo* prossimo; // Puntatore al nodo successivo nella sequenza\n} Nodo;\n\n// Il puntatore alla testa della lista\ntypedef Nodo* Lista;\n</code></pre></p> <p>L'elemento <code>struct Nodo* prossimo;</code> rende la struttura autoreferenziale. Per gestire la lista, usiamo un puntatore principale, spesso chiamato testa (<code>Lista testa = NULL;</code>), che punta al primo nodo. Se la lista \u00e8 vuota, <code>testa</code> \u00e8 <code>NULL</code>.</p> <p>Inserimento in testa Questa \u00e8 l'operazione di inserimento pi\u00f9 semplice e veloce, con complessit\u00e0 temporale costante (O(1)).</p> <pre><code>Lista inserisciInTesta(Lista testa, int nuovo_dato) {\n    // 1. Alloca il nuovo nodo\n    Nodo* nuovo_nodo = (Nodo*)malloc(sizeof(Nodo));\n\n    // Controllo allocazione\n    if (nuovo_nodo == NULL) {\n        // Gestione errore\n        return testa;\n    }\n\n    // 2. Inserisce il dato\n    nuovo_nodo-&gt;dato = nuovo_dato;\n\n    // 3. Collega il nuovo nodo alla vecchia testa\n    nuovo_nodo-&gt;prossimo = testa;\n\n    // 4. Aggiorna la testa al nuovo nodo\n    return nuovo_nodo;\n}\n</code></pre> <p>Eliminazione dalla testa Operazione semplice come la recedente, fondamentale per deallocare la memoria.</p> <pre><code>// Funzione per eliminare il nodo in testa\nLista eliminaTesta(Lista testa) {\n    if (testa == NULL) {\n        return NULL; // La lista \u00e8 vuota\n    }\n\n    // 1. Salva il puntatore alla testa corrente\n    Nodo* temp = testa;\n\n    // 2. Sposta la testa al prossimo nodo\n    testa = testa-&gt;prossimo;\n\n    // 3. Dealloca il nodo precedente\n    free(temp);\n\n    // 4. Restituisce la nuova testa\n    return testa;\n}\n</code></pre> <p>Attraversamento e Stampa (Traversal) Per scorrere la lista, si parte dalla testa e si segue il puntatore <code>prossimo</code> con un ciclo finch\u00e9 non si arriva a <code>NULL</code>, ultimo elemento della lista.</p> <pre><code>void stampaLista(Lista testa) {\n    Nodo* corrente = testa; // Puntatore ausiliario per lo scorrimento\n    while (corrente != NULL) {\n        printf(\"%d -&gt; \", corrente-&gt;dato);\n        corrente = corrente-&gt;prossimo; // Passa al nodo successivo\n    }\n    printf(\"NULL\\n\");\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/linked_list/#derivazioni","title":"Derivazioni","text":"<p>Oltre alla lista semplicemente concatenata che abbiamo visto ci sono principalmente altre due strutture dati che vengono derivate da questa e sono:</p> <ul> <li>Lista doppiamente concatenata: ogni nodo ha un puntatore al successivo e uno al precedente. Permette di attraversare la lista in entrambe le direzioni e di eliminare un nodo in O(1) (una volta trovato) ma occupa pi\u00f9 memoria per il doppio puntatore.</li> <li>Lista circolare: L'ultimo nodo punta al primo, creando un ciclo. Utile per l'implementazione di buffer circolari o round-robin ma bisogna stare attenti a non ciclare all'infinito.</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/","title":"Strutture dati dinamiche","text":"<p>Le Strutture Dati Dinamiche (SDD) in C rappresentano un salto di qualit\u00e0 nella programmazione, permettendo di gestire in modo efficiente la memoria e adattarsi alle esigenze reali di un'applicazione. A differenza delle strutture statiche (come gli array, la cui dimensione \u00e8 fissata a tempo di compilazione), le SDD possono espandersi o ridursi durante l'esecuzione del programma.</p> <p>Questo \u00e8 reso possibile dall'uso combinato di due concetti fondamentali in C:</p> <ol> <li>Allocazione Dinamica della Memoria: L'uso di funzioni come <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> e <code>free()</code> per richiedere e rilasciare memoria sull'heap a tempo di esecuzione.</li> <li>Puntatori</li> </ol>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#allocazione-e-deallocazione-dinamica","title":"Allocazione e Deallocazione Dinamica","text":"<p>Per creare e gestire le SDD, se si lavora con un ambiente di sviluppo tipicamente desktop, si utilizzano le funzioni della libreria standard C (<code>stdlib.h</code>). Nei sistemi embedded spesso l'uso della libreria standard \u00e8 limitato o del tutto proibito, per questo \u00e8 necessario trovare delle soluzioni alternative.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#assenza-di-un-sistema-operativo-completo","title":"Assenza di un \"Sistema Operativo\" Completo","text":"<p>Le funzioni della CSL (specialmente I/O e gestione della memoria) assumono l'esistenza di un ambiente operativo completo, con:</p> <ul> <li>Un file system (per <code>fopen</code>, <code>fread</code>, <code>fprintf</code>, ecc.).</li> <li>Uno schermo/console ben definiti (per <code>printf</code>).</li> <li>Una gestione della memoria (Kernel) che gestisce l'heap in modo robusto.</li> </ul> <p>Nei sistemi embedded, la maggior parte di queste funzionalit\u00e0 \u00e8 assente o deve essere implementata \"da zero\" (o tramite driver minimi forniti dal produttore del chip).</p>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#problemi-con-le-funzioni-di-inputoutput-io","title":"Problemi con le Funzioni di Input/Output (I/O)","text":""},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#printf","title":"<code>printf()</code>","text":"<p>La funzione <code>printf()</code> \u00e8 molto complessa: deve interpretare la stringa di formato, convertire vari tipi di dati (float, interi lunghi), e infine scrivere l'output in un stream standard (che sia un terminale, una console seriale, o un file).</p> <ul> <li> <p>Dimensione del Codice (Footprint): L'implementazione completa di <code>printf</code> pu\u00f2 occupare decine di kilobyte di memoria Flash (ROM), che \u00e8 una quantit\u00e0 sproporzionata per un microcontrollore con 64KB totali.</p> </li> <li> <p>Reindirizzamento (Retargeting): La CSL non sa \"dove\" si trova la console. Per usare <code>printf</code>, lo sviluppatore deve \"reindirizzare\" le chiamate a una funzione a basso livello che gestisca la comunicazione hardware (es. UART o USB). Questo processo, chiamato retargeting, \u00e8 specifico per ogni hardware e RTOS.</p> </li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#gestione-dinamica-della-memoria-il-pericolo-di-malloc","title":"Gestione Dinamica della Memoria: Il Pericolo di <code>malloc()</code>","text":"<p>Questo \u00e8 l'aspetto pi\u00f9 critico e il motivo principale per cui <code>stdlib.h</code> viene spesso evitato.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#frammentazione-dellheap-e-determinismo","title":"Frammentazione dell'Heap e Determinismo","text":"<ul> <li> <p>Frammentazione: Nei sistemi che devono funzionare per molto tempo, l'uso ripetuto di <code>malloc()</code> e <code>free()</code> pu\u00f2 causare la frammentazione dell'heap (memoria libera divisa in piccoli blocchi non contigui). A lungo andare, una richiesta di memoria grande potrebbe fallire, anche se c'\u00e8 abbastanza memoria totale libera.</p> </li> <li> <p>Non Determinismo: Le implementazioni standard di <code>malloc()</code> e <code>free()</code> non sono pensate per l'ambiente real-time. Il tempo necessario per allocare un blocco di memoria pu\u00f2 variare drasticamente (dipende dalla ricerca di un blocco libero), violando i requisiti di determinismo temporale di un RTOS.</p> </li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#soluzione-di-freertos-heap-management-personalizzato","title":"Soluzione di FreeRTOS: Heap Management Personalizzato","text":"<p>FreeRTOS non usa l'implementazione standard di <code>malloc()</code> ma offre diversi schemi di gestione dell'heap (es. Heap_1, Heap_2, Heap_3, ecc.), progettati per:</p> <ul> <li> <p>Essere pi\u00f9 semplici e veloci delle implementazioni standard.</p> </li> <li> <p>Offrire un compromesso tra consumo di memoria e prevenzione della frammentazione, spesso a costo di non supportare tutte le operazioni standard.</p> </li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#sicurezza-e-thread-safety-task-safety","title":"Sicurezza e Thread Safety (Task Safety)","text":"<p>Molte funzioni della CSL (es. <code>strtok()</code>, le funzioni di gestione del tempo) non sono thread-safe.</p> <ul> <li>Variabili Statiche: Alcune funzioni C utilizzano variabili statiche interne o globali. Se due Task provano a chiamare la stessa funzione contemporaneamente, l'accesso concorrente a queste variabili pu\u00f2 portare a condizioni di gara (race conditions) e a risultati errati o crash del sistema.</li> </ul> <p>Nei sistemi FreeRTOS, si devono usare:</p> <ol> <li>Versioni Thread-Safe: Molti RTOS forniscono versioni re-entrant delle funzioni C (spesso chiamate con un suffisso come <code>_r</code> o richiedendo l'uso di un mutex).</li> <li>Primitive RTOS: Per tutte le operazioni critiche (I/O, allocazione, comunicazione), \u00e8 obbligatorio usare le API di FreeRTOS (code, semafori, ecc.) per garantire la sincronizzazione e l'integrit\u00e0 dei dati.</li> </ol>"},{"location":"hardware/battery/SOC/","title":"State Of Charge (SOC)","text":"<p>High voltage</p> <p>La batteria ha una tensione che oscilla tra 504V e 588V, \u00e8 una tensione letale. Osservare tutte le indicazioni di sicurezza prima di iniziare a lavorare sul pacco.</p> <p>Configurazione pacco</p> <p>Il nostro pacco batterie \u00e8 divisa in 14 moduli in serie con 10 celle ciascuno. Ogni cella ha il suo BMS Enepaq tinyAFE per ottenere informazioni riguardanti tensioni e temperature e bilanciare le singole celle.</p> <p>Le celle sono delle sony 4p, quindi la struttura totale della batteria \u00e8 140S 4P.</p> <p>Dato che i TinyAFE non sono dei veri e propri BMS, non possono calcolare autonomamente lo state of charge dei moduli, quindi si rendono necessari degli elementi esterni per fare i calcoli:</p> <ul> <li>Sensore di corrente</li> <li>Microcontrollore esterno</li> <li>Linea UART isolata</li> </ul> <p>Ci sono principalmente due metodi per stimare lo stato di carica delle batterie al litio, il primo \u00e8 basato sulla tensione, ma \u00e8 meno preciso e pu\u00f2 dare degli errori anche del 20% quando la batteria \u00e8 sotto carico, il secondo \u00e8 il Coulomb Counting.</p>"},{"location":"hardware/battery/SOC/#primo-metodo-tensioni","title":"Primo metodo: tensioni","text":"<p>\u00c8 il metodo pi\u00f9 facile e veloce, ma meno preciso. Lo useremo per calibrare il BMS Master all'accensione della vettura.</p> <p>Le celle utilizzate all'interno dei moduli sono delle Sony/Murata VTC6-4 (chimica NMC) e hanno una curva di scarica caratteristica fornita dal costruttore e mostrata nell'immagine qua sotto.</p> <p></p> <p>Bisogna mappare la tensione del pacco oppure una media delle celle lette dal TinyAFE a una percentuale, usando una tabella estratta dalla curva di scarica al pi\u00f9 basso carico. \u00c8 stato scelto il carico pi\u00f9 basso del grafico e non 0 perch\u00e9 ci sono dei componenti, come ad esempio le pompe di raffreddamento, che attingono energia direttamente dal pacco e rischiano di rovinare le celle se si permette l'accensione ad un livello basso senza contare questi consumi. La tensione di fine scarica \u00e8 stata alzata a 2.80V per motivi di sicurezza e per preservare l'integrit\u00e0 delle celle.</p> SoC (%) Capacit\u00e0 Residua (mAh) Tensione Cella (V) Note Visive dal Grafico 100% 3000 4.20 V Carica completa 90% 2700 4.08 V Caduta iniziale rapida 80% 2400 4.00 V Inizio zona lineare 70% 2100 3.91 V 60% 1800 3.82 V 50% 1500 3.72 V Met\u00e0 grafico (Asse X = 1500) 40% 1200 3.62 V 30% 900 3.52 V La curva si accentua 20% 600 3.40 V 10% 300 3.20 V Ginocchio della curva (scarica rapida) 5% 150 3.05 V Zona critica 0% 0 &lt; 2.80 V Cutoff di sicurezza Questo metodo fallisce quando il pacco \u00e8 sotto carico per via del fatto che la tensione scende a causa della resistenza interna. Il ragionamento vale ugualmente anche quando il pacco \u00e8 in carica solo che invece che scendere, la tensione sale."},{"location":"hardware/battery/SOC/#secondo-metodo-coulomb-counting","title":"Secondo metodo: Coulomb Counting","text":"<p>Il Coulomb Counting \u00e8 metodo semplice per stimare lo Stato di Carica (SOC) di una batteria, misurando e\u00a0integrando nel tempo la corrente\u00a0che entra o esce dalla batteria (Ampere-ora) per calcolare la carica rimanente, partendo da un SOC iniziale noto. La formula dell'algoritmo \u00e8 la seguente:</p> \\[SoC(t) = SoC(t_0) - \\frac{1}{C_{tot}} \\int_{t_0}^{t} I(\\tau) d\\tau\\] <p>Dove:</p> <ul> <li>\\(SoC(t_0)\\) \u00e8 lo stato di carica iniziale calcolato attraverso il primo metodo delle tensioni.</li> <li>\\(C_{tot}\\) \u00e8 la capacit\u00e0 totale delle celle. Le nostre sono da \\(3000mAh\\) e ne abbiamo 4 in parallelo, risulta che la capacit\u00e0 vale \\(12000mAh\\).</li> <li>\\(I(\\tau)\\) \u00e8 la corrente fornita o sottratta in un lasso di tempo</li> </ul> <p>Parlando concretamente dobbiamo discretizzare la formula per renderla compatibile con un sistema a tempo discreto come un microcontrollore, allo scopo di effettuare il calcolo ad una frequenza fissa (\\(10Hz\\))</p> \\[Q(t) = Q(t-1) + (I_{inst} \\times \\Delta t)\\] <p>dove:</p> <ul> <li>\\(Q(t)\\) \u00e8 la carica attuale</li> <li>\\(I_{inst}\\) \u00e8 la corrente istantanea letta dal sensore (positiva se \u00e8 in carica e negativa se \u00e8 in scarica)</li> <li>\\(\\Delta t\\) \u00e8 il lasso di tempo passato dall'ultima lettura, a \\(10Hz\\) vale \\(\\frac{1}{10}s = 100ms\\) </li> </ul> <p>Deriva</p> <p>Il sensore di corrente avr\u00e0 per forza uno scostamento rispetto al valore reale a causa di interferenze elettromagnetiche e quant'altro, falsando il calcolo a lungo andare. Per correggere bisogna forzare il SOC al 100% vicino al massimo e allo 0% vicino al minimo.</p> <p>La frequenza di campionamento \u00e8 stata impostata a 100ms perch\u00e9 i TinyAFE ci mettono un certo lasso di tempo a rispondere alla chiamata del master e sono 14, una frequenza superiore rischia di falsare il risultato usando valori vecchi.</p>"},{"location":"hardware/centralina_fae/adc/","title":"ADC (Analog to Digital Converter)","text":"<p>Un convertitore analogico-digitale (ADC) \u00e8 un dispositivo elettronico la cui funzione \u00e8 trasformare un segnale analogico, continuo nel tempo e nell'ampiezza, in un segnale digitale, discreto sia nel tempo che nell'ampiezza. Questo processo di \"traduzione\" \u00e8 fondamentale per l'interfacciamento tra i sensori del mondo reale e i sistemi di elaborazione numerica (come microcontrollori o computer).</p> <p>L'intero processo si fonda su due operazioni concettuali distinte e sequenziali: il campionamento (discretizzazione nel tempo) e la quantizzazione (discretizzazione nell'ampiezza). Queste operazioni teoriche sono implementate da specifiche architetture hardware.</p>"},{"location":"hardware/centralina_fae/adc/#il-campionamento-e-il-circuito-di-sample-and-hold-sh","title":"Il Campionamento e il Circuito di Sample and Hold (S/H)","text":"<p>Il primo passo \u00e8 la discretizzazione temporale. Un segnale analogico \\(v_{in}(t)\\) ha un valore definito per ogni istante di tempo \\(t\\). Un sistema digitale non pu\u00f2 acquisire un'infinit\u00e0 di valori in un dato intervallo; deve \"fotografare\" il segnale a intervalli di tempo specifici. Questo processo \u00e8 il campionamento.</p>"},{"location":"hardware/centralina_fae/adc/#teoria-il-teorema-di-nyquist-shannon","title":"Teoria: Il Teorema di Nyquist-Shannon","text":"<p>La teoria fondamentale del campionamento stabilisce che, per poter ricostruire fedelmente un segnale analogico a partire dai suoi campioni, la frequenza di campionamento \\(f_s\\) deve essere rigorosamente maggiore del doppio della massima frequenza contenuta nel segnale stesso, \\(f_{max}\\).</p> \\[f_s &gt; 2 \\cdot f_{max}\\] <p>Questa condizione \u00e8 nota come criterio di Nyquist. Se il criterio non \u00e8 rispettato, si verifica un fenomeno distorsivo chiamato aliasing, in cui le componenti spettrali del segnale a frequenze superiori a \\(f_s/2\\) (la frequenza di Nyquist) si \"ripiegano\" nella banda di interesse, apparendo come segnali a frequenza pi\u00f9 bassa e corrompendo irrimediabilmente l'informazione. Per questo motivo, un ADC \u00e8 quasi sempre preceduto da un filtro anti-aliasing, un filtro passa-basso analogico che elimina le componenti spettrali oltre \\(f_{max}\\) prima che il segnale raggiunga il campionatore.</p>"},{"location":"hardware/centralina_fae/adc/#hardware-il-circuito-di-sample-and-hold-sh","title":"Hardware: Il Circuito di Sample and Hold (S/H)","text":"<p>A livello hardware, il campionamento non \u00e8 un'operazione istantanea. Il processo di quantizzazione richiede un certo tempo per essere completato, e durante questo tempo il segnale d'ingresso non deve variare. Se il segnale variasse durante la quantizzazione, il risultato digitale sarebbe indefinito e affetto da errore.</p> <p>Per risolvere questo problema, si utilizza un circuito fondamentale chiamato Sample and Hold (S/H), o talvolta Track and Hold.</p> <p>Questo circuito \u00e8 concettualmente semplice:</p> <ol> <li>Un interruttore analogico (tipicamente un MOSFET).</li> <li>Un condensatore di hold (o di campionamento), \\(C_H\\).</li> <li>Un buffer (amplificatore operazionale in configurazione voltage follower) per isolare il condensatore dal resto del circuito.</li> </ol> <p>Il suo funzionamento avviene in due fasi:</p> <ul> <li> <p>Fase di Sample (o Track): L'interruttore \u00e8 chiuso. Il condensatore \\(C_H\\) si carica (o scarica) per seguire la tensione di ingresso \\(v_{in}(t)\\). Il tempo necessario affinch\u00e9 la tensione ai capi del condensatore, \\(v_C\\), raggiunga un valore sufficientemente prossimo a \\(v_{in}\\) (entro una frazione di LSB) \u00e8 chiamato Tempo di Acquisizione (\\(t_{acq}\\)). Questo tempo dipende dalla resistenza dell'interruttore (\\(R_{on}\\)) e dalla capacit\u00e0 \\(C_H\\) (costante di tempo \\(\\tau = R_{on} \\cdot C_H\\)).</p> </li> <li> <p>Fase di Hold: L'interruttore viene aperto istantaneamente (in teoria). La carica accumulata su \\(C_H\\) non ha pi\u00f9 un percorso a bassa impedenza per scaricarsi. Il condensatore \"mantiene\" quindi la tensione \\(v_C\\) costante al valore che \\(v_{in}(t)\\) aveva nell'istante esatto dell'apertura. Questa tensione stabile \u00e8 ora disponibile per il blocco di quantizzazione.</p> </li> </ul> <p>Nella realt\u00e0, l'apertura non \u00e8 istantanea. Il breve intervallo in cui l'interruttore passa da chiuso ad aperto \u00e8 il tempo di apertura (aperture time). L'incertezza statistica su quando esattamente avviene questa transizione \u00e8 il jitter di apertura, una fonte critica di rumore e errore nelle conversioni ad alta frequenza. Durante la fase di Hold, inoltre, la tensione non rimane perfettamente costante a causa di correnti di perdita (correnti di leakage dell'interruttore e correnti di bias del buffer), provocando un leggero decadimento della tensione (droop rate).</p>"},{"location":"hardware/centralina_fae/adc/#la-quantizzazione-e-lerrore-di-quantizzazione","title":"La Quantizzazione e l'Errore di Quantizzazione","text":"<p>Una volta che il circuito S/H ha \"congelato\" un valore di tensione analogica \\(v_C\\), inizia il secondo processo: la quantizzazione. Questa \u00e8 la discretizzazione dell'ampiezza. La quantizzazione consiste nell'associare il valore analogico \\(v_C\\) (che appartiene a un intervallo continuo) a uno tra un numero finito di livelli digitali. Il numero di questi livelli \u00e8 determinato dalla risoluzione dell'ADC, espressa in bit (\\(N\\)).</p> <p>Un ADC a \\(N\\) bit pu\u00f2 produrre \\(2^N\\) codici digitali distinti. Ad esempio, un ADC a 8 bit ha \\(2^8 = 256\\) livelli; un ADC a 12 bit ne ha \\(2^{12} = 4096\\).</p>"},{"location":"hardware/centralina_fae/adc/#hardware-il-riferimento-di-tensione-v_ref","title":"Hardware: Il Riferimento di Tensione (\\(V_{ref}\\))","text":"<p>L'hardware che definisce l'intervallo di tensioni che l'ADC pu\u00f2 misurare \u00e8 il riferimento di tensione (\\(V_{ref}\\)). Questo \u00e8 uno dei componenti pi\u00f9 critici per l'accuratezza dell'ADC. L'ADC mappa l'intervallo di tensioni d'ingresso, definito come \\(V_{FS}\\) (Full-Scale Range), che solitamente va da una \\(V_{ref-}\\) (spesso 0V, o GND) a una \\(V_{ref+}\\) (spesso \\(V_{ref}\\) stessa), sull'intero insieme dei \\(2^N\\) codici digitali.</p> <p>L'ampiezza di un singolo livello discreto, ovvero la minima variazione di tensione che l'ADC \u00e8 teoricamente in grado di distinguere, \u00e8 chiamata quantum o LSB (Least Significant Bit). Il suo valore \u00e8:</p> \\[q = \\text{LSB} = \\frac{V_{FS}}{2^N} = \\frac{V_{ref+} - V_{ref-}}{2^N}\\] <p>Ad esempio, un ADC a 10 bit (\\(2^{10} = 1024\\) livelli) con un riferimento \\(V_{ref} = 5.0\\text{V}\\) (e \\(V_{ref-} = 0\\text{V}\\)) avr\u00e0 un LSB di \\(q = \\frac{5.0\\text{V}}{1024} \\approx 4.88\\text{mV}\\).</p>"},{"location":"hardware/centralina_fae/adc/#teoria-lerrore-di-quantizzazione","title":"Teoria: L'Errore di Quantizzazione","text":"<p>Il processo di quantizzazione \u00e8 intrinsecamente un'approssimazione. Qualsiasi tensione analogica \\(v_C\\) che cade tra due livelli di decisione \\(V_k\\) e \\(V_{k+1}\\) viene mappata a un singolo codice digitale (ad esempio, il codice \\(k\\)).</p> <p>Questa differenza tra il valore analogico reale campionato \\(v_C\\) e il valore digitale \\(V_{digitale}\\) che lo rappresenta \u00e8 un errore ineluttabile chiamato errore di quantizzazione (\\(e_q\\)).</p> \\[e_q = v_C - V_{digitale}\\] <p>Nel caso ideale, il circuito di quantizzazione assegna al campione analogico il codice digitale pi\u00f9 vicino. In questa situazione, l'errore di quantizzazione \u00e8 sempre limitato a met\u00e0 del gradino minimo.</p> \\[|e_q| \\leq \\frac{q}{2} \\text{ (ovvero } \\pm \\frac{1}{2} \\text{LSB)}\\] <p>Questo errore \u00e8 inevitabile e viene spesso modellato come una fonte di rumore (il rumore di quantizzazione), la cui potenza \u00e8 direttamente legata alla risoluzione \\(N\\). Aumentare la risoluzione (pi\u00f9 bit) riduce il \\(q\\) e, di conseguenza, riduce il rumore di quantizzazione, aumentando il rapporto segnale/rumore (SNR) dell'ADC.</p>"},{"location":"hardware/centralina_fae/adc/#il-ciclo-di-conversione-e-i-tempi-operativi","title":"Il Ciclo di Conversione e i Tempi Operativi","text":"<p>L'intero processo non \u00e8 istantaneo. L'operazione completa di un ADC si svolge in un ciclo che somma i tempi delle fasi viste finora.</p> <p>Il tempo totale per ottenere un singolo campione digitale \u00e8 il tempo di ciclo (\\(T_{cycle}\\)), dato dalla somma del tempo di acquisizione e del tempo di conversione:</p> \\[T_{cycle} = t_{acq} + t_{conv}\\] <ol> <li> <p>Tempo di Acquisizione (\\(t_{acq}\\)): \u00c8 il tempo, discusso prima, in cui il circuito S/H \u00e8 in fase \"Sample\" e il condensatore \\(C_H\\) si carica alla tensione di ingresso.</p> </li> <li> <p>Tempo di Conversione (\\(t_{conv}\\)): \u00c8 il tempo richiesto dall'hardware interno dell'ADC (che pu\u00f2 essere un'architettura SAR, Flash, Delta-Sigma, ecc.) per eseguire l'algoritmo di quantizzazione e codifica. \u00c8 il tempo che intercorre tra il comando di \"Hold\" e l'istante in cui il dato digitale \\(N\\)-bit \u00e8 valido e stabile sull'uscita.</p> </li> </ol> <p>La massima frequenza di campionamento \\(f_s\\) che l'ADC pu\u00f2 sostenere \u00e8 l'inverso del tempo di ciclo totale:</p> \\[f_s = \\frac{1}{T_{cycle}} = \\frac{1}{t_{acq} + t_{conv}}\\] <p>Questi parametri (\\(t_{acq}\\) e \\(t_{conv}\\)) sono fondamentali nei datasheet di un ADC e determinano il throughput (la velocit\u00e0) massimo del convertitore. Per esempio, un ADC \"pipeline\" pu\u00f2 iniziare l'acquisizione di un nuovo campione mentre sta ancora convertendo quello precedente, ottimizzando la velocit\u00e0 complessiva e disaccoppiando \\(f_s\\) dalla somma semplice dei due tempi. Tuttavia, per le architetture pi\u00f9 comuni come il SAR (Successive Approximation Register), questo ciclo \\(t_{acq} + t_{conv}\\) definisce rigidamente la massima velocit\u00e0 operativa.</p>"},{"location":"hardware/centralina_fae/adc/#adc-sulla-centralina-fae","title":"ADC sulla centralina FAE","text":"<p>Nell'immagine in alto \u00e8 descritto il circuito di condizionamento del segnale che si trova prima dell'ADC nella centralina FAE che al momento utilizziamo.</p> <p>Il suo compito \u00e8 prendere un segnale industriale \"grezzo\" (come un 0-5V o un 4-20mA), proteggere l'elettronica, filtrarlo e adattarlo affinch\u00e9 possa essere letto correttamente e in sicurezza da un pin di ingresso dell'ADC (presumibilmente un microcontrollore).</p> <p>Analizziamo il percorso del segnale, passo dopo passo, per un singolo canale (ad esempio, quello di sinistra, che \u00e8 identico a quello di destra).</p>"},{"location":"hardware/centralina_fae/adc/#1-stadio-di-ingresso-e-conversione-correntetensione-iv","title":"1. Stadio di Ingresso e Conversione Corrente/Tensione (I/V)","text":"<p>Il segnale entra dal connettore J38. Lo schema indica che questo ingresso accetta due tipi di segnali standard industriali: 0-5V (in tensione) o 4-20mA (in corrente).</p> <ul> <li>R471 (200 \\(\\Omega\\)): Questo \u00e8 il componente chiave per l'ingresso in corrente. \u00c8 un resistore di shunt (o burden resistor). Per la legge di Ohm (\\(V = I \\cdot R\\)), questo resistore converte la corrente che lo attraversa in una tensione.<ul> <li>Se l'ingresso \u00e8 4mA (minimo segnale): \\(V = 0.004 \\text{ A} \\times 200 \\text{ } \\Omega = \\mathbf{0.8 \\text{ V}}\\)</li> <li>Se l'ingresso \u00e8 20mA (massimo segnale): \\(V = 0.020 \\text{ A} \\times 200 \\text{ } \\Omega = \\mathbf{4.0 \\text{ V}}\\)</li> </ul> </li> <li>Se l'ingresso \u00e8 un segnale 0-5V, questo viene semplicemente applicato ai capi di questo resistore (e dei componenti a valle).</li> </ul> <p>Quindi, questo stadio unifica entrambi i tipi di segnale in un segnale di tensione.</p>"},{"location":"hardware/centralina_fae/adc/#2-stadio-di-protezione-clamping","title":"2. Stadio di Protezione (Clamping)","text":"<p>Il segnale in tensione (che, come abbiamo visto, pu\u00f2 arrivare fino a 4.0V o 5.0V) incontra subito il diodo D5 (BAT54SW).</p> <ul> <li>Questo \u00e8 un package contenente due diodi Schottky connessi in modo da realizzare un circuito di clamping.</li> <li>Il catodo del diodo superiore \u00e8 connesso all'alimentazione (<code>3V3_MAIN</code>, cio\u00e8 3.3 Volt).</li> <li>L'anodo del diodo inferiore \u00e8 connesso a massa (<code>GND_DIGITAL</code>).</li> <li>Il segnale di ingresso \u00e8 connesso al punto centrale.</li> </ul> <p>Funzione: Questo circuito \"blocca\" (delimita) la tensione per proteggere i componenti successivi.</p> <ul> <li> <p>Se la tensione di ingresso tenta di salire sopra i 3.3V, il diodo superiore entra in conduzione e \"scarica\" la tensione in eccesso verso l'alimentazione (limitando la tensione a circa \\(3.3\\text{V} + V_f \\approx 3.6\\text{V}\\)).</p> </li> <li> <p>Se la tensione di ingresso tenta di scendere sotto lo 0V (ad esempio a causa di un disturbo negativo), il diodo inferiore entra in conduzione e la \"ancora\" a massa (limitandola a circa \\(-V_f \\approx -0.3\\text{V}\\)).</p> </li> </ul> <p>Nota importante: Poich\u00e9 l'alimentazione \u00e8 a 3.3V, questo circuito clippa attivamente i segnali 4-20mA (che arrivano a 4.0V) e 0-5V. Ci\u00f2 significa che l'intervallo di misura effettivo del circuito \u00e8 limitato dalla tensione di alimentazione. Qualsiasi segnale che produce una tensione superiore a \\(\\approx 3.3\\text{V}\\) verr\u00e0 letto come \"fondo scala\" dall'ADC.</p>"},{"location":"hardware/centralina_fae/adc/#3-stadio-di-filtraggio-anti-aliasing-passa-basso","title":"3. Stadio di Filtraggio Anti-Aliasing (Passa-Basso)","text":"<p>Il segnale, ora protetto, passa attraverso un filtro RC passa-basso passivo. - R305 (\\(10\\text{k}\\Omega\\)) e C231 (1nF) formano questo filtro.</p> <p>Funzione: Questo \u00e8 il filtro anti-aliasing di cui abbiamo parlato nella teoria. Il suo compito \u00e8 eliminare le componenti di rumore ad alta frequenza dal segnale prima che questo venga campionato dall'ADC. Questo previene l'errore di aliasing. La sua frequenza di taglio \u00e8:</p> \\[f_c = \\frac{1}{2\\pi \\cdot R \\cdot C} = \\frac{1}{2\\pi \\cdot 10 \\cdot 10^3 \\text{ } \\Omega \\cdot 1 \\cdot 10^{-9} \\text{ F}} \\approx 15.9 \\text{ kHz}\\] <p>Qualsiasi rumore o segnale spuria con frequenza superiore a \\(\\approx 16\\text{kHz}\\) viene significativamente attenuato.</p>"},{"location":"hardware/centralina_fae/adc/#4-stadio-di-buffering-inseguitore-di-tensione","title":"4. Stadio di Buffering (Inseguitore di Tensione)","text":"<p>Il segnale filtrato entra nel componente U30 (AD8542). Questo \u00e8 un amplificatore operazionale (in package doppio).</p> <ul> <li>Il segnale entra nell'ingresso non-invertente (pin 3, <code>+INA</code>).</li> <li>L'uscita (pin 1, <code>OUTA</code>) \u00e8 collegata direttamente all'ingresso invertente (pin 2, <code>-INA</code>).</li> </ul> <p>Questa configurazione \u00e8 chiamata voltage follower (o inseguitore di tensione).</p> <p>Funzione: Questo stadio \u00e8 fondamentale e svolge un doppio ruolo:</p> <ol> <li> <p>Adattamento di Impedenza: L'op-amp ha un'impedenza di ingresso altissima. Ci\u00f2 significa che \"guarda\" il filtro RC (R305/C231) senza \"caricarlo\", ovvero senza assorbire corrente da esso, garantendo che il filtro funzioni come calcolato.</p> </li> <li> <p>ADC Driver: L'op-amp ha un'impedenza di uscita bassissima. Questo \u00e8 cruciale. L'ingresso dell'ADC (che non vediamo, ma che \u00e8 collegato a <code>ADC1_IN</code>) contiene il circuito di Sample and Hold (S/H). Quando l'S/H commuta per \"campionare\", il suo condensatore interno (\\(C_H\\)) deve caricarsi istantaneamente. L'op-amp, con la sua bassa impedenza di uscita, \u00e8 in grado di fornire la \"botta\" di corrente necessaria per caricare \\(C_H\\) rapidamente e senza far \"cadere\" la tensione del segnale.</p> </li> </ol>"},{"location":"hardware/centralina_fae/adc/#5-stadio-di-uscita-e-serbatoio-di-carica","title":"5. Stadio di Uscita e Serbatoio di Carica","text":"<p>L'uscita dall'op-amp (pin 1) non va direttamente all'ADC, ma passa attraverso un ultimo piccolo filtro. - R311 (\\(10\\Omega\\)) e C232 (1nF).</p> <p>Funzione: Anche questo stadio ha un doppio ruolo critico per l'integrit\u00e0 del segnale:</p> <ol> <li> <p>R311 (Resistore di Isolamento): Gli op-amp possono diventare instabili (oscillare) se pilotano un carico puramente capacitivo, come l'ingresso di un ADC. Questo piccolo resistore da 10\\(\\Omega\\) \"isola\" l'uscita dell'op-amp dalla capacit\u00e0 \\(C_{232}\\) e da quella dell'ADC, garantendo la stabilit\u00e0.</p> </li> <li> <p>C232 (Serbatoio di Carica): Questo condensatore, posto proprio vicino al pin dell'ADC, agisce come un \"mini-serbatoio\" di carica. Quando l'interruttore S/H dell'ADC si chiude, la maggior parte della carica istantanea necessaria a \\(C_H\\) proviene da C232 (che \u00e8 fisicamente vicino), non dall'op-amp (che \u00e8 \"pi\u00f9 lontano\", elettricamente parlando, attraverso R311). Questo minimizza il voltage droop (calo di tensione) istantaneo sul pin dell'ADC, permettendo un campionamento molto pi\u00f9 accurato.</p> </li> </ol> <p>Il segnale finale, <code>ADC1_IN</code>, \u00e8 ora pulito, filtrato, protetto, bufferizzato e pronto per essere convertito in un numero digitale. L'intero circuito \u00e8 duplicato per gestire un secondo canale analogico.</p>"},{"location":"hardware/inverter/gestione_termica/","title":"Gestione termica/potenza","text":"<p>La massimizzazione della coppia erogabile \u00e8 limitata dai vincoli termici del motore, tutti forniti dal datasheet del produttore del relativo modello. Il datasheet del motore AMK DD5-14-10-POW (in uso dal nostro team) indica una corrente nominale di stallo continuativo \\(I_0\\) pari a 53,1 Arms. Tuttavia, per garantire la coppia richiesta per le accelerazioni repentine e per le alte velocit\u00e0, \u00e8 necessario operare in regime di sovraccarico, sfruttando correnti di picco fino a 105 Arms \\(I_{max}\\), che consentono di raggiungere valori di coppia significativamente superiori al valore nominale, nel nostro caso 21 Nm contro i 9,8 Nm nominali.</p> <p>Il problema fondamentale risiede nella natura transitoria del sovraccarico. L'utilizzo di correnti superiori a \\(I_0\\) genera un accumulo termico per effetto Joule che il sistema di raffreddamento non \u00e8 in grado di smaltire istantaneamente. Se tale condizione persiste oltre un tempo critico, si rischia il danneggiamento irreversibile degli avvolgimenti o la smagnetizzazione dei magneti permanenti.</p> <p>Per controllare questi limiti si utilizza l'algoritmo \\(I^2t\\), anche detto integrale termico. Tale modello permette di stimare in tempo reale l'energia termica accumulata nel motore, consentendo di sfruttare l'intera capacit\u00e0 di sovraccarico per periodi limitati, intervenendo con una riduzione della coppia solo all'approssimarsi della soglia critica definita dal costruttore.</p>"},{"location":"hardware/inverter/gestione_termica/#algoritmo-i2t-integrale-termico","title":"Algoritmo \\(I^2t\\) (integrale termico)","text":"<p>Prima di cominciare a pensare all'algoritmo \u00e8 bene tenere a mente alcuni dati importanti strettamente correlati al modello di motore impiegato:</p> <ul> <li>Coppia nominale: 9,8 Nm</li> <li>Corrente di stallo continuo: \\(I_{cont}\\) = 53,1 A, \u00e8 la corrente che il motore pu\u00f2 reggere e dissipare per un tempo indefinito perch\u00e9 il calore viene dissipato in tempo utile. Corrisponde ad una coppia nominale</li> <li>Coppia massima: 21 Nm</li> <li>Corrente massima: \\(I_{max}\\) = 105 A, picco massimo assoluto consentito.</li> <li>Tempo massimo \\(T_{lim}\\) a \\(I_{max}\\) = 1,24 s. Quanto tempo il motore sopravvive al picco massimo.</li> </ul> <p>![[tempo.png|500]]</p> <p>L'algoritmo opera utilizzando come riferimento un bucket termico, che racchiude l'energia termica che viene contenuta nel motore. Il secchio ha una larghezza massima che rappresenta la quantit\u00e0 di calore che il motore riesce a sopportare prima di subire danni irrisolvibili e la smagnetizzazione dei magneti permanenti. L'unita di misura del budget termico \u00e8 in \\(A^2s\\) e si calcola come:</p> \\[E_{max}=(I^2_{max}-I^2_{cont})\\times t_{lim}\\] <p>Sostituendo i valori si ha \\((105^2-53,1^2)\\times1,24 = \\mathbf{10.175 \\, A^2s}\\), valore che pu\u00f2 raggiungere l'integratore prima che il motore si consideri surriscaldato.</p> <p>Dopo aver calcolato il budget termico si inizia a misurare effettivamente il budget utilizzato secondo la stessa formula. Dato che il microcontrollore all'interno della vettura \u00e8 un dispositivo a tempo discreto \u00e8 opportuno definire un intervallo di tempo (\\(\\Delta t\\)) a cui eseguire la funzione che calcola l'energia termica generata o dissipata nel motore. Una frequenza che ci risulta ottimale \u00e8 100 Hz, quindi 10 ms tra una misura e l'altra.</p> <p>Per il calcolo serve la corrente media erogata durante quel tempo, \\(I_{feedback}\\)</p> \\[\\Delta_{term}=(I^2_{feedback}-I^2_{cont})\\times \\Delta t\\] <p>Se \\(I_{feedback}\\) \u00e8 minore di \\(I_{cont}\\), l'energia risulter\u00e0 negativa, quindi il motore sta dissipando il calore. Come ultimo passo si aggiorna l'integratore:</p> \\[\\text{thermal\\_integrator} = \\text{thermal\\_integrator} + \\Delta_{term}\\]"},{"location":"hardware/inverter/gestione_termica/#derating","title":"Derating","text":"<p>Non vogliamo che la coppia massima cali drasticamente dal massimo alla coppia nominale quando l'integratore arriva al 100%, ma si deve ridurre dolcemente la potenza erogata.</p> <p>Ci sono principalmente due soglie importanti:</p> <ul> <li>La soglia warning contraddistingue il limite al quale si inizia a tagliare la coppia e corrisponde all'80% di \\(E_{max}\\)</li> <li>Soglia critica di stop: il bucket \u00e8 pieno e il motore non pu\u00f2 permettersi di accumulare altro calore per evitare danni permanenti, la coppia va tagliata al di sotto della nominale per permettere anche un raffreddamento</li> </ul> <p>Allo scopo di implementare il derating bisogna calcolare il limite \\(I_{limit}\\) ia ogni ciclo utilizzando le soglie.</p> <ul> <li>Se l'integratore \u00e8 sotto all'80%, \\(I_{limit}\\) = \\(I_{max}\\), quindi abbiamo la possibilit\u00e0 di erogare tutta la corrente disponibile.</li> <li>Se \u00e8 tra l'80% e il 100% bisogna abbassare linearmente la corrente da 105 A a 53 A. Per l'interpolazione si usa: $\\(Factor = \\frac{\\text{integrator} - \\text{Soglia}_{warn}}{\\text{Soglia}_{crit} - \\text{Soglia}_{warn}}\\)$ Dove factor va d 0 a 1 man mano che il motore si scalda $\\(I_{limit} = I_{max} - Factor \\times (I_{max} - I_{cont})\\)$ ![[temperatura.png|500]]</li> </ul>"}]}