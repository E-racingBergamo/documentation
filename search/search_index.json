{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ERB documentation","text":""},{"location":"#introduzione","title":"Introduzione","text":"<p>Questa documentazione raccoglie tutte le informazioni necessarie per comprendere e lavorare sul progetto della centralina di controllo della macchina. \u00c8 pensata sia per i membri esperti del team sia per i nuovi ragazzi che iniziano a collaborare: fornisce quindi spiegazioni passo per passo, a partire dalle basi del linguaggio C fino ad arrivare ai dettagli di firmware, hardware e schede elettroniche.</p>"},{"location":"#obiettivi-della-documentazione","title":"Obiettivi della documentazione","text":"<ul> <li>Offrire una panoramica chiara del progetto nella sua interezza.  </li> <li>Fornire materiale di formazione per i nuovi membri, senza dare nulla per scontato.  </li> <li>Creare un manuale di riferimento tecnico per lo sviluppo e la manutenzione.  </li> <li>Centralizzare tutte le informazioni in un unico posto facilmente consultabile.  </li> </ul>"},{"location":"#cosa-troverai-in-queste-pagine","title":"Cosa troverai in queste pagine","text":"<ol> <li> <p>Fondamenti di programmazione in C    Per chi non ha mai programmato o ha bisogno di ripasso.  </p> </li> <li> <p>Embedded e microcontrollore    Spiegazione del funzionamento di un microcontrollore e degli strumenti di sviluppo.  </p> </li> <li> <p>FreeRTOS    Introduzione al sistema operativo real-time usato nel firmware.  </p> </li> <li> <p>Architettura software    Struttura del progetto: task, FSM, logging, parser CAN.  </p> </li> <li> <p>Hardware e schede elettroniche    Panoramica della centralina, dei sensori e delle altre PCB.  </p> </li> <li> <p>Comunicazioni    CAN bus, UART e telemetria.  </p> </li> <li> <p>Guide pratiche    Esempi passo per passo per aggiungere nuove funzionalit\u00e0 al sistema.  </p> </li> </ol>"},{"location":"#destinatari","title":"Destinatari","text":"<p>Questa documentazione \u00e8 rivolta a:</p> <ul> <li>Studenti e nuovi membri del team che devono imparare da zero.  </li> <li>Chi si occupa di sviluppo software e firmware.  </li> <li>Chi lavora sull\u2019hardware o sull\u2019integrazione dei sistemi.  </li> </ul>"},{"location":"#come-utilizzare-la-documentazione","title":"Come utilizzare la documentazione","text":"<p>Ti consigliamo di partire dalla sezione Fondamenti di C, per poi proseguire con le parti embedded e gradualmente arrivare alle implementazioni specifiche della macchina. Ogni capitolo \u00e8 indipendente e pu\u00f2 essere letto anche separatamente come riferimento tecnico.</p>"},{"location":"codice/centralina/","title":"Centralina","text":"<p>Questa sezione documenta il software sviluppato per la centralina.</p>"},{"location":"codice/centralina/#architettura-generale","title":"Architettura generale","text":"<p>Il codice \u00e8 organizzato in pi\u00f9 moduli, ciascuno con responsabilit\u00e0 precise:</p> <ul> <li>CAN controller: codifica e decodifica di messaggi sulla linea CAN.</li> <li>ADC controller: gestisce i sensori analogici.</li> <li>Digital I/O: per ingressi e uscite digitali.</li> <li>Hall sensors: legge i sensori a effetto Hall.</li> <li>Inverter: comunicazione con inverter e motori</li> <li>Telemetry: formatta i messaggi di telemetria e li mette in coda per essere spediti su una periferica a scelta.</li> <li>Ticker: sincronizza le task periodiche come la lettura dei sensori o l'esecuzione della macchina a stati dell'inverter.</li> <li>Tractive system manager: gestisce la macchina a stati complessiva della macchina e fornisce le autorizzazioni per accendere gli inverter.</li> </ul>"},{"location":"codice/centralina/#freertos","title":"FreeRTOS","text":"<p>FreeRTOS \u00e8 un sistema operativo real-time open source progettato per microcontrollori. Offre meccanismi per:</p> <ul> <li>Creare e gestire task che vengono eseguiti in modo concorrente.</li> <li>Sincronizzare l\u2019esecuzione tramite code, semafori e mutex.</li> <li>Pianificare attivit\u00e0 periodiche con timer software.</li> </ul> <p>Il suo utilizzo permette di strutturare il firmware in moduli indipendenti e ben organizzati, migliorando la scalabilit\u00e0 e la manutenibilit\u00e0 del progetto.</p>"},{"location":"codice/centralina/#macchine-a-stati","title":"Macchine a stati","text":"<p>Le FSM sono implementate in C utilizzando la struttura <code>switch-case</code>. Ogni stato rappresenta una fase di funzionamento, ad esempio:</p> <pre><code>switch (state) {\n    case INIT:\n        // Inizializzazione\n        break;\n    case RUN:\n        // Esecuzione principale\n        break;\n    case ERROR:\n        // Gestione errori\n        break;\n}\n</code></pre>"},{"location":"codice/centralina/#logging","title":"Logging","text":"<p>Il logging \u00e8 gestito tramite UART con code di output. Caratteristiche principali:</p> <ul> <li>Supporto a pi\u00f9 livelli di log (INFO, WARN, ERROR).</li> <li>Invio asincrono dei messaggi.</li> </ul> <p>Esempio di utilizzo:</p> <pre><code>LOG_INFO(\"Sistema inizializzato correttamente\");\nLOG_ERROR(\"Errore durante la trasmissione CAN\");\n</code></pre>"},{"location":"codice/centralina/#comunicazioni","title":"Comunicazioni","text":""},{"location":"codice/centralina/#can","title":"CAN","text":"<ul> <li>Supporto a due linee can.</li> <li>Callback per la gestione asincrona dei messaggi.</li> </ul>"},{"location":"codice/centralina/#uart","title":"UART","text":"<ul> <li>Utilizzata per logging e debug.</li> <li>Interfaccia DMA per migliorare le prestazioni.</li> </ul>"},{"location":"codice/centralina/#moduli-futuri","title":"Moduli futuri","text":"<ul> <li>Telemetria: invio dati in tempo reale a un server esterno.</li> <li>Strategie di controllo avanzate: da integrare in base agli sviluppi del progetto.</li> </ul>"},{"location":"codice/lezioni_di_c/funzioni/","title":"Funzioni e modularit\u00e0","text":"<p>Le funzioni sono blocchi di codice riutilizzabili che eseguono un compito specifico. La loro corretta progettazione \u00e8 fondamentale per la modularit\u00e0 di un progetto, soprattutto in ambienti embedded dove il firmware viene suddiviso in moduli separati e ben organizzati.</p>"},{"location":"codice/lezioni_di_c/funzioni/#dichiarazione-e-definizione","title":"Dichiarazione e definizione","text":"<p>Una funzione si dichiara indicando il tipo di ritorno, il nome e i parametri:</p> <pre><code>int somma(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>Qui <code>somma</code> prende due interi e restituisce un intero. Il tipo di ritorno pu\u00f2 essere qualsiasi tipo valido: <code>int</code>, <code>float</code>, <code>char</code>, <code>struct</code>, oppure <code>void</code> se non deve restituire nulla.</p>"},{"location":"codice/lezioni_di_c/funzioni/#parametri-per-valore-e-per-riferimento","title":"Parametri per valore e per riferimento","text":"<ul> <li>Per valore: viene passata una copia della variabile, modifiche dentro la funzione non influenzano l\u2019originale.</li> <li>Per riferimento: si passa l\u2019indirizzo della variabile tramite un puntatore, e quindi la funzione pu\u00f2 modificare l\u2019originale.</li> </ul> <pre><code>void incrementa_valore(int x) {\n    x++;\n}\n\nvoid incrementa_riferimento(int *x) {\n    (*x)++;\n}\n</code></pre> <p>In questo caso il simbolo <code>*</code> viene chiamato operatore di dereference, che consente di modificare direttamente il valore della variabile a partire dal suo puntatore. Se nel secondo caso si facesse <code>x++</code> si andrebbe ad incrementare il puntatore alla variabile, rischiando di andare oltre la sua area di memoria con operazioni successive e corrompere altre variabili o funzioni.</p>"},{"location":"codice/lezioni_di_c/funzioni/#tipi-di-funzioni","title":"Tipi di funzioni","text":"<ol> <li>Funzioni con ritorno e parametri <code>c     int moltiplica(int a, int b) {         return a * b;     }</code></li> <li>Funzioni senza parametri <code>c     int leggi_sensore(void) {         return 42;     }</code></li> <li>Funzioni senza ritorno (<code>void</code>) <code>c     void stampa_valore(int v) {         printf(\"%d\\n\", v);     }</code></li> <li>Funzioni inline     Suggeriscono al compilatore di espandere la funzione al posto della chiamata (ottimizzazione). In poche parole la funzione viene copiata al posto della chiamata. E' consigliabile usarlo solo con funzioni piccole, cio\u00e8 che fanno una semplice operazione aritmetica o chiamata a funzione.     <code>c     inline int quadrato(int x) {         return x * x;     }</code></li> <li>Funzioni static     Se dichiarate <code>static</code> a livello di file <code>.c</code>, la loro visibilit\u00e0 \u00e8 limitata solo a quel file, impedendo che siano richiamabili da altri moduli.     <code>c     static void reset_interno(void) {         // codice interno     }</code></li> </ol> <p>E utile conoscere anche la combinazione di static e inline, che permette al compilatore di poter scegliere quando utilizzare inline o quando invece serve avere una definizione della funzione vera e propria.</p>"},{"location":"codice/lezioni_di_c/funzioni/#modularita-con-file-c-e-h","title":"Modularit\u00e0 con file <code>.c</code> e <code>.h</code>","text":"<p>Per mantenere il codice ordinato:</p> <ul> <li>nel file <code>.c</code> si mettono le definizioni delle funzioni,</li> <li>nel file <code>.h</code> si mettono i prototipi (cio\u00e8 la firma senza corpo).</li> </ul> <p>Esempio:</p> <p>math_utils.h</p> <pre><code>#ifndef MATH_UTILS_H\n#define MATH_UTILS_H\n\nint somma(int a, int b);\nint moltiplica(int a, int b);\n\n#endif\n</code></pre> <p>math_utils.c</p> <pre><code>#include \"math_utils.h\"\n\nint somma(int a, int b) {\n    return a + b;\n}\n\nint moltiplica(int a, int b) {\n    return a * b;\n}\n</code></pre> <p>Cos\u00ec gli altri moduli possono includere <code>math_utils.h</code> e usare le funzioni senza conoscere l\u2019implementazione.</p>"},{"location":"codice/lezioni_di_c/funzioni/#puntatori-a-funzioni","title":"Puntatori a funzioni","text":"<p>In C \u00e8 possibile memorizzare l\u2019indirizzo di una funzione in una variabile, e poi richiamarla attraverso questa. Questo meccanismo \u00e8 molto utile per callback e per realizzare codice flessibile.</p> <pre><code>int somma(int a, int b) { return a + b; }\nint moltiplica(int a, int b) { return a * b; }\n\nint calcola(int (*operazione)(int, int), int x, int y) {\n    return operazione(x, y);\n}\n\nint main(void) {\n    int r1 = calcola(somma, 2, 3);\n    int r2 = calcola(moltiplica, 2, 3);\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/funzioni/#typedef-per-puntatori-a-funzioni","title":"Typedef per puntatori a funzioni","text":"<p>Scrivere i prototipi di puntatori a funzioni pu\u00f2 diventare complicato, per questo si usa <code>typedef</code>.</p> <pre><code>typedef int (*Operazione)(int, int);\n\nint calcola(Operazione op, int x, int y) {\n    return op(x, y);\n}\n</code></pre> <p>Questo approccio \u00e8 molto comune in embedded, ad esempio per definire callback da registrare in un driver.</p>"},{"location":"codice/lezioni_di_c/funzioni/#lambda-in-c","title":"Lambda in C","text":"<p>Il C standard non supporta le lambda (funzioni anonime inline) come C++ o altri linguaggi. Alcuni compilatori (come GCC) offrono estensioni che permettono funzioni nidificate, ma non sono portabili e non sono consigliate in un progetto embedded.</p> <p>Per simulare lambde, in C si usano:</p> <ul> <li>puntatori a funzioni,</li> <li>funzioni statiche locali al file,</li> <li>closure manuali con struct che raggruppano stato e puntatore a funzione.</li> </ul>"},{"location":"codice/lezioni_di_c/funzioni/#funzioni-avanzate","title":"Funzioni avanzate","text":"<p>Ricorsione Una funzione ricorsiva \u00e8 una funzione che chiama se stessa per risolvere un problema pi\u00f9 grande suddividendolo in sottoproblemi pi\u00f9 semplici. Un esempio classico \u00e8 il calcolo del fattoriale:</p> <pre><code>int fattoriale(int n) {\n    if (n &lt;= 1)\n        return 1;\n    else\n        return n * fattoriale(n - 1);\n}\n</code></pre> <p>In questo caso la funzione continua a richiamarsi fino a quando raggiunge la condizione base (<code>n &lt;= 1</code>). La ricorsione \u00e8 potente, ma in ambiente embedded va usata con estrema cautela perch\u00e9 ogni chiamata aggiunge un nuovo frame nello stack. Poich\u00e9 lo stack nei microcontrollori \u00e8 tipicamente molto limitato, un uso eccessivo della ricorsione pu\u00f2 portare a stack overflow e comportamenti imprevedibili. In sistemi a risorse limitate, \u00e8 spesso preferibile convertire una ricorsione in un ciclo iterativo.</p> <p>Funzioni variadiche Alcune funzioni in C possono accettare un numero variabile di argomenti. L\u2019esempio pi\u00f9 noto \u00e8 <code>printf</code>. Per implementarle si utilizza la libreria <code>&lt;stdarg.h&gt;</code>, che fornisce i tipi e le macro necessarie per accedere agli argomenti aggiuntivi.</p> <p>Esempio semplificato di funzione che calcola la media di un numero variabile di interi:</p> <pre><code>#include &lt;stdarg.h&gt;\n#include &lt;stdio.h&gt;\n\ndouble media(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    int somma = 0;\n\n    for (int i = 0; i &lt; count; i++) {\n        somma += va_arg(args, int);\n    }\n\n    va_end(args);\n    return (double)somma / count;\n}\n</code></pre> <p>L\u2019uso di funzioni variadiche deve essere ponderato: gli argomenti non hanno un tipo esplicito e un errore nella gestione (ad esempio passare un tipo sbagliato) non viene rilevato dal compilatore.</p> <p>Funzioni inline vs macro Le macro (<code>#define</code>) permettono di definire frammenti di codice riutilizzabili che vengono sostituiti dal preprocessore. Ad esempio:</p> <pre><code>#define QUADRATO(x) ((x) * (x))\n</code></pre> <p>Il problema \u00e8 che le macro non hanno controllo sui tipi e possono introdurre errori difficili da individuare (ad esempio <code>QUADRATO(a+b)</code> si espande in <code>((a+b)*(a+b))</code>, che pu\u00f2 avere effetti collaterali inattesi se <code>x</code> \u00e8 un\u2019espressione con side-effect).</p> <p>Le funzioni <code>inline</code> sono un\u2019alternativa molto pi\u00f9 sicura:</p> <pre><code>inline int quadrato(int x) {\n    return x * x;\n}\n</code></pre> <p>Il compilatore pu\u00f2 sostituire la chiamata con il corpo della funzione (senza overhead di chiamata), mantenendo per\u00f2 il controllo sui tipi e la leggibilit\u00e0. Per questo motivo, in C moderno si preferisce sempre l\u2019uso di funzioni <code>inline</code> rispetto alle macro per operazioni semplici.</p> <p>Uso di <code>const</code> nei parametri La keyword <code>const</code> applicata ai parametri di funzione \u00e8 fondamentale per chiarire le intenzioni e prevenire modifiche indesiderate.</p> <p>Esempio senza <code>const</code>:</p> <pre><code>void stampa_stringa(char *str);\n</code></pre> <p>In questo caso non \u00e8 chiaro se la funzione modifichi o meno il contenuto della stringa.</p> <p>Con <code>const</code>:</p> <pre><code>void stampa_stringa(const char *str);\n</code></pre> <p>Ora il compilatore impedir\u00e0 qualsiasi modifica al contenuto di <code>str</code> all\u2019interno della funzione, e chi legge il codice capisce immediatamente che la funzione si limita a leggere la stringa senza alterarla.</p> <p>L\u2019uso di <code>const</code> \u00e8 particolarmente importante in ambienti embedded, dove la protezione contro modifiche indesiderate alla memoria (ad esempio buffer condivisi o registri di periferiche mappati in memoria) pu\u00f2 prevenire errori difficili da diagnosticare.</p>"},{"location":"codice/lezioni_di_c/puntatori/","title":"Approfondimento sui puntatori","text":"<p>I puntatori sono uno degli strumenti pi\u00f9 potenti e importanti del linguaggio C. Permettono di lavorare direttamente con indirizzi di memoria, rendendo possibile l\u2019accesso efficiente a variabili, array, strutture e periferiche hardware. Anche se li abbiamo introdotti nelle sezioni su variabili e funzioni, vale la pena dedicare un capitolo a parte per chiarire tutti i dettagli e i casi particolari.</p>"},{"location":"codice/lezioni_di_c/puntatori/#cose-un-puntatore","title":"Cos\u2019\u00e8 un puntatore","text":"<p>Quando dichiariamo una variabile, ad esempio <code>int numero = 10;</code>, il processore riserva una cella di memoria (o pi\u00f9 di una, a seconda del tipo di dato) per memorizzare il valore <code>10</code> e associa a questa casella il nome <code>numero</code>. L'indirizzo di questa casella \u00e8 la sua posizione fisica nella memoria.</p> <p>Un puntatore non \u00e8 altro che una variabile speciale il cui valore non \u00e8 un dato come un numero o un carattere, ma l'indirizzo di memoria di un'altra variabile. Invece di contenere il dato stesso, il puntatore \"punta\" alla casella di memoria che contiene quel dato. Dichiarazione:</p> <pre><code>int x = 10;\nint *p = &amp;x; // p contiene l\u2019indirizzo di x\n\nint *puntatore_a_intero;\nchar *puntatore_a_carattere;\nfloat *puntatore_a_float;\n</code></pre> <ul> <li><code>&amp;x</code> \u2192 (<code>&amp;</code> operatore di indirizzo) indirizzo della variabile <code>x</code></li> <li><code>*p</code> \u2192 (<code>*</code> operatore di dereferenziazione o indirezione) valore contenuto all\u2019indirizzo puntato da <code>p</code></li> </ul> <p>\u00c8 importante sottolineare il fatto che in queste variabili sono a tutti gli effetti salvati degli indirizzi di memoria, quindi il tipo di dato contenuto al loro interno \u00e8 un <code>unsigned int</code> che ha la dimensione del bus del processore. Sulle architetture a 32bit sar\u00e0 un <code>uint32</code> mentre in quelle a 64bit sar\u00e0 un <code>uint64</code>. Dichiarare un tipo diverso serve al processore per capire quanto \u00e8 grande il dato contenuto alla cella di memoria a cui si sta puntando e come interpretarlo.</p> <p>Attenzione: </p> <p>Quando si usano i puntatori, a meno che non si sia assolutamente sicuri che abbiano un valore valido, bisogna controllare che non sia nullo e che sia del tipo corretto rispetto al dato a cui si sta puntando. \u00c8 anche possibile assegnare <code>NULL</code> ad un puntatore, ma bisogna stare attenti a come lo si usa.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-e-costanti","title":"Puntatori e costanti","text":"<p>Esistono varie combinazioni di <code>const</code> con i puntatori:</p> <ol> <li>Puntatore a costante: il contenuto non pu\u00f2 essere modificato</li> </ol> <pre><code>const int *p = &amp;x;\n*p = 5; // ERRORE\np = &amp;y; // OK\n</code></pre> <ol> <li>Puntatore costante: il puntatore non pu\u00f2 cambiare, ma il contenuto pu\u00f2</li> </ol> <pre><code>int *const p = &amp;x;\n*p = 5; // OK\np = &amp;y; // ERRORE\n</code></pre> <ol> <li>Puntatore costante a costante: niente pu\u00f2 essere modificato</li> </ol> <pre><code>const int *const p = &amp;x;\n*p = 5; // ERRORE\np = &amp;y; // ERRORE\n</code></pre> <p>Questa distinzione \u00e8 fondamentale in embedded per proteggere buffer o registri di periferica.</p>"},{"location":"codice/lezioni_di_c/puntatori/#aritmetica-dei-puntatori","title":"Aritmetica dei puntatori","text":"<p>Quando incrementiamo (<code>++</code>) un puntatore, non stiamo aggiungendo 1 all'indirizzo di memoria. Stiamo invece spostando il puntatore in avanti della dimensione del tipo di dato a cui punta. Se <code>p_voti</code> \u00e8 un puntatore a <code>int</code> e un <code>int</code> occupa 4 byte, <code>p_voti++</code> aumenter\u00e0 l'indirizzo di 4, puntando cos\u00ec all'intero successivo.</p> <p>Le operazioni consentite sono:</p> <ul> <li>Incremento/Decremento: <code>p++</code>, <code>p--</code></li> <li>Somma/Sottrazione di un intero: <code>p + n</code>, <code>p - n</code></li> <li>Differenza tra due puntatori: Se <code>p1</code> e <code>p2</code> puntano a elementi dello stesso array, <code>p2 - p1</code> restituisce il numero di elementi tra di loro.</li> </ul> <pre><code>int a[3] = {10, 20, 30};\nint *p = a;\n\np++;        // ora punta a a[1]\nprintf(\"%d\\n\", *p); // stampa 20\n</code></pre> <p>L\u2019operatore <code>+</code> o <code>-</code> muove il puntatore di un numero di elementi, non di byte. La sottrazione tra puntatori restituisce il numero di elementi tra loro.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-e-array","title":"Puntatori e array","text":"<p>In C, c'\u00e8 una stretta relazione tra puntatori e array. Il nome di un array, usato in un'espressione, viene convertito in un puntatore al suo primo elemento.</p> <p>Questo significa che possiamo usare l'aritmetica dei puntatori per scorrere gli elementi di un array. Passare un array a una funzione significa passare un puntatore:</p> <pre><code>void stampa(int arr[], int n) {\n    for(int i = 0; i &lt; n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n</code></pre> <p>\u00c8 equivalente a:</p> <pre><code>void stampa(int *arr, int n) { ... }\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-a-struct","title":"Puntatori a struct","text":"<p>Quando si ha una struttura, \u00e8 spesso pi\u00f9 efficiente passare un puntatore:</p> <pre><code>struct Punto {\n    int x;\n    int y;\n};\n\nvoid sposta(struct Punto *p, int dx, int dy) {\n    p-&gt;x += dx;\n    p-&gt;y += dy;\n}\n</code></pre> <ul> <li><code>p-&gt;x</code> \u00e8 equivalente a <code>(*p).x</code></li> <li>I puntatori a struct permettono di risparmiare memoria e tempo di copia.</li> </ul>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-void","title":"Puntatori void","text":"<p><code>void *</code> \u00e8 un puntatore generico, senza tipo. Serve quando vogliamo passare un indirizzo di memoria senza sapere il tipo, ad esempio in buffer generici o callback.</p> <pre><code>void stampa_generico(void *ptr, char tipo) {\n    if(tipo == 'i') printf(\"%d\\n\", *(int *)ptr);\n    if(tipo == 'f') printf(\"%f\\n\", *(float *)ptr);\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#array-di-puntatori-e-puntatori-a-puntatori","title":"Array di puntatori e puntatori a puntatori","text":"<p>\u00c8 possibile avere array di puntatori:</p> <pre><code>char *nomi[] = {\"Mario\", \"Luigi\", \"Peach\"};\n</code></pre> <p>O puntatori a puntatori, utili ad esempio per gestire array dinamici di stringhe:</p> <pre><code>char **strs;\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#passaggio-per-riferimento-simulato","title":"Passaggio per Riferimento (Simulato)","text":"<p>Di default, il C passa gli argomenti alle funzioni \"per valore\", creando una copia della variabile. Qualsiasi modifica all'interno della funzione non influisce sulla variabile originale. Passando un puntatore a una funzione, possiamo simulare un \"passaggio per riferimento\", permettendo alla funzione di modificare la variabile originale.</p> <p>Esempio riassuntivo:</p> <pre><code>void incrementa(int *valore) {\n    (*valore)++; // Incrementa il valore a cui punta 'valore'\n}\n\nint main() {\n    int a = 10;\n    incrementa(&amp;a); // Passiamo l'indirizzo di 'a'\n    printf(\"Valore di a dopo l'incremento: %d\\n\", a); // Stampa 11\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#allocazione-dinamica-della-memoria","title":"Allocazione Dinamica della Memoria","text":"<p>Fino ad ora, la memoria per le nostre variabili veniva allocata staticamente dal compilatore. I puntatori ci permettono di gestire la memoria dinamicamente a runtime, ovvero di richiederne e liberarne blocchi quando ne abbiamo bisogno. Questo \u00e8 fondamentale per creare strutture dati la cui dimensione non \u00e8 nota a priori. Le funzioni si trovano nella libreria <code>&lt;stdlib.h&gt;</code>.</p> <ul> <li> <p><code>malloc(size_t size)</code>: Alloca un blocco di memoria della dimensione specificata in byte. Restituisce un puntatore <code>void*</code> all'inizio del blocco, o <code>NULL</code> se fallisce.</p> </li> <li> <p><code>calloc(size_t num, size_t size)</code>: Alloca memoria per un array di <code>num</code> elementi, ciascuno di dimensione <code>size</code>. La memoria viene inizializzata a zero.</p> </li> <li> <p><code>realloc(void *ptr, size_t new_size)</code>: Ridimensiona un blocco di memoria precedentemente allocato.</p> </li> <li> <p><code>free(void *ptr)</code>: Dealloca (libera) un blocco di memoria precedentemente allocato, rendendolo di nuovo disponibile al sistema.</p> </li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *array_dinamico;\n    int n = 5;\n\n    // Alloca memoria per 5 interi\n    array_dinamico = (int*) malloc(n * sizeof(int));\n\n    if (array_dinamico == NULL) {\n        printf(\"Allocazione di memoria fallita!\\n\");\n        return 1;\n    }\n\n    // Usa l'array come un normale array\n    for (int i = 0; i &lt; n; i++) {\n        array_dinamico[i] = i * 10;\n        printf(\"%d \", array_dinamico[i]);\n    }\n    printf(\"\\n\");\n\n    // \u00c8 FONDAMENTALE liberare la memoria quando non serve pi\u00f9\n    free(array_dinamico);\n    array_dinamico = NULL; // Buona pratica per evitare \"dangling pointers\"\n\n    return 0;\n}\n</code></pre> <p>Attenzione: Dimenticare di usare <code>free()</code> causa memory leak (perdita di memoria), un bug grave in cui il programma consuma memoria senza mai rilasciarla.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-a-puntatori","title":"Puntatori a Puntatori","text":"<p>Un puntatore a puntatore \u00e8 una variabile che contiene l'indirizzo di un altro puntatore. Si dichiara con un doppio asterisco (<code>**</code>).</p> <pre><code>int x = 10;\nint *p = &amp;x;\nint **pp = &amp;p;\n\nprintf(\"Valore di x: %d\\n\", x);\nprintf(\"Valore tramite p: %d\\n\", *p);\nprintf(\"Valore tramite pp: %d\\n\", **pp);\n</code></pre> <p>Sono utili, ad esempio, per creare array di stringhe o per modificare un puntatore all'interno di una funzione.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-a-funzioni","title":"Puntatori a Funzioni","text":"<p>Cos\u00ec come le variabili, anche le funzioni risiedono in memoria e hanno un indirizzo. Un puntatore a funzione pu\u00f2 memorizzare questo indirizzo, permettendoci di trattare le funzioni come dati: passarle ad altre funzioni, inserirle in array, ecc.</p> <p>La sintassi \u00e8 un po' ostica: <code>tipo_ritorno (*nome_puntatore)(lista_parametri);</code></p> <pre><code>int somma(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int (*operazione)(int, int); // Dichiara un puntatore a funzione\n    operazione = &amp;somma;\n\n    int risultato = operazione(5, 3); // Chiama la funzione 'somma' tramite il puntatore\n    printf(\"Risultato: %d\\n\", risultato); // Stampa 8\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/","title":"Sintassi base del C","text":"<p>Il linguaggio C \u00e8 alla base dello sviluppo embedded: \u00e8 semplice, efficiente e permette un controllo diretto sull\u2019hardware. In questa sezione vediamo le fondamenta che servono per scrivere e capire il codice della centralina.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#variabili","title":"Variabili","text":"<p>Una variabile \u00e8 uno spazio di memoria a cui diamo un nome e che contiene un valore.</p> <p>\u26a0\ufe0f Nota per l\u2019embedded: \u00c8 sempre consigliato evitare l\u2019allocazione dinamica con funzioni come <code>malloc()</code> o <code>alloca()</code>. Negli ambienti a risorse limitate (come i microcontrollori) queste chiamate possono causare memory leak, frammentazione o corruzione della memoria. Meglio usare variabili globali, statiche o allocate nello stack, che garantiscono maggiore stabilit\u00e0 e prevedibilit\u00e0.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#dichiarazione","title":"Dichiarazione","text":"<pre><code>int numero;        // variabile intera\nfloat temperatura; // variabile con virgola\nchar lettera;      // variabile carattere\n````\n\n### Inizializzazione\n\n```c\nint numero = 10;\nfloat temperatura = 36.5;\nchar lettera = 'A';\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#regole-sui-nomi","title":"Regole sui nomi","text":"<ul> <li>Devono iniziare con lettera o <code>_</code></li> <li>Possono contenere lettere, numeri e <code>_</code></li> <li>Sono case-sensitive (<code>variabile</code> \u2260 <code>Variabile</code>)</li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#tipi-di-dato-principali","title":"Tipi di dato principali","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#interi","title":"Interi","text":"<ul> <li><code>int</code> \u2192 intero base (dimensione dipende dal compilatore, spesso 32 bit)</li> <li><code>short</code> \u2192 intero corto (16 bit)</li> <li><code>long</code> \u2192 intero lungo (32 o 64 bit)</li> <li><code>unsigned</code> \u2192 versione senza segno (solo positivi)</li> </ul> <p>Esempio:</p> <pre><code>int a = -10;\nunsigned int b = 20;\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#numeri-decimali","title":"Numeri decimali","text":"<ul> <li><code>float</code> \u2192 virgola mobile a 32 bit (circa 6-7 cifre decimali)</li> <li><code>double</code> \u2192 virgola mobile a 64 bit (circa 15-16 cifre decimali)</li> </ul> <p>Esempio:</p> <pre><code>float x = 3.14f;\ndouble y = 2.718281828;\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#caratteri","title":"Caratteri","text":"<ul> <li><code>char</code> \u2192 memorizza un singolo carattere (es. 'A', 'b', '1')</li> <li>In realt\u00e0 \u00e8 un numero intero (ASCII)</li> </ul> <pre><code>char c = 'A';  // ASCII 65\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#booleani","title":"Booleani","text":"<p>In C puro non esisteva, ma da C99 si pu\u00f2 usare, bisogna includere la libreria <code>stdbool.h</code>:</p> <pre><code>#include &lt;stdbool.h&gt;\n\nbool flag = true;\n</code></pre> <p>Reminder: C \\(\\ne\\) C++, la libreria standard C \u00e8 definita da file chiamati <code>&lt;libreria&gt;.h</code> e non <code>&lt;libreria&gt;</code> e basta, bisogna mettere il .h </p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#costanti","title":"Costanti","text":"<p>Una costante \u00e8 un valore che non cambia.</p> <pre><code>const float PI = 3.14159;\n#define MAX_VALORE 100\n</code></pre> <ul> <li><code>const</code> \u2192 variabile costante</li> <li><code>#define</code> \u2192 macro gestita dal preprocessore</li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#operatori","title":"Operatori","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#aritmetici","title":"Aritmetici","text":"<pre><code>+   // addizione\n-   // sottrazione\n*   // moltiplicazione\n/   // divisione\n%   // resto (solo interi)\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#relazionali","title":"Relazionali","text":"<pre><code>==  // uguale\n!=  // diverso\n&gt;   // maggiore\n&lt;   // minore\n&gt;=  // maggiore o uguale\n&lt;=  // minore o uguale\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#logici","title":"Logici","text":"<pre><code>&amp;&amp;  // AND logico\n||  // OR logico\n!   // NOT logico\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#operatori-bitwise","title":"Operatori bitwise","text":"<pre><code>&lt;&lt;  // left shift\n&gt;&gt;  // right shift\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori","title":"Puntatori","text":"<p>Un puntatore \u00e8 una variabile che contiene l\u2019indirizzo di memoria di un\u2019altra variabile. Sono fondamentali in C perch\u00e9 permettono di accedere direttamente alla memoria, alle periferiche e ai registri.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#dichiarazione_1","title":"Dichiarazione","text":"<pre><code>int x = 10;\nint *p = &amp;x;   // p contiene l\u2019indirizzo di x\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#utilizzo","title":"Utilizzo","text":"<pre><code>printf(\"Valore di x: %d\\n\", x);   // stampa 10\nprintf(\"Indirizzo di x: %p\\n\", &amp;x);\nprintf(\"Valore tramite puntatore: %d\\n\", *p); // stampa 10\n</code></pre> <ul> <li><code>&amp;x</code> \u2192 indirizzo della variabile <code>x</code></li> <li><code>*p</code> \u2192 valore contenuto all\u2019indirizzo puntato da <code>p</code></li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori-e-array","title":"Puntatori e array","text":"<p>Un array \u00e8 strettamente legato ai puntatori.</p> <pre><code>int numeri[3] = {1, 2, 3};\nint *ptr = numeri;\n\nprintf(\"%d\\n\", *ptr);       // 1\nprintf(\"%d\\n\", *(ptr + 1)); // 2\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori-a-char-e-stringhe","title":"Puntatori a <code>char</code> e stringhe","text":"<p>In C una stringa \u00e8 un array di <code>char</code> terminato da <code>\\0</code>.</p> <pre><code>char saluto[] = \"Ciao\";\nchar *p = saluto;\n\nprintf(\"%s\\n\", p);   // stampa \"Ciao\"\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#tipi-definiti-dallutente","title":"Tipi definiti dall\u2019utente","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#struct","title":"<code>struct</code>","text":"<p>Serve per raggruppare variabili diverse in un\u2019unica entit\u00e0.</p> <pre><code>struct Sensore {\n    int id;\n    float valore;\n};\n\nstruct Sensore s1 = {1, 23.5};\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#typedef","title":"<code>typedef</code>","text":"<p>Permette di creare alias per tipi pi\u00f9 leggibili.</p> <pre><code>typedef unsigned int uint32_t;\n\nuint32_t counter = 100;\n</code></pre>"},{"location":"codice/lezioni_di_c/stdint/","title":"Tipi di <code>stdint.h</code>","text":"<p>In C la dimensione di tipi come <code>int</code>, <code>long</code>, <code>short</code> pu\u00f2 variare a seconda del compilatore e dell\u2019architettura. Per i microcontrollori questo \u00e8 un problema, perch\u00e9 dobbiamo sapere con certezza quanti bit occupa una variabile.</p> <p>Per questo si usa l\u2019header <code>&lt;stdint.h&gt;</code>, che definisce tipi con dimensione fissa.</p>"},{"location":"codice/lezioni_di_c/stdint/#tipi-interi-con-dimensione-precisa","title":"Tipi interi con dimensione precisa","text":"<ul> <li><code>int8_t</code> \u2192 intero con segno a 8 bit (da -128 a 127)  </li> <li><code>uint8_t</code> \u2192 intero senza segno a 8 bit (da 0 a 255)  </li> <li><code>int16_t</code> \u2192 intero con segno a 16 bit  </li> <li><code>uint16_t</code> \u2192 intero senza segno a 16 bit  </li> <li><code>int32_t</code> \u2192 intero con segno a 32 bit  </li> <li><code>uint32_t</code> \u2192 intero senza segno a 32 bit  </li> <li><code>int64_t</code> \u2192 intero con segno a 64 bit  </li> <li><code>uint64_t</code> \u2192 intero senza segno a 64 bit  </li> </ul> <p>Esempio:</p> <pre><code>uint16_t valore = 50000; // sicuro che \u00e8 16 bit senza segno\n````\n\n---\n\n## Tipi minimi e massimi\n\nOltre ai tipi a dimensione fissa, `stdint.h` fornisce anche tipi che garantiscono almeno una certa dimensione:\n\n- `int_least8_t` \u2192 almeno 8 bit con segno\n- `uint_least16_t` \u2192 almeno 16 bit senza segno\n- `int_fast32_t` \u2192 il tipo intero \u201cpi\u00f9 veloce\u201d con almeno 32 bit\n\nQuesti sono meno usati in embedded, ma possono tornare utili se non importa la dimensione esatta, ma solo la minima.\n\n---\n\n## Costanti con dimensione fissa\n\n`stdint.h` definisce anche **macro** per scrivere costanti con la dimensione giusta:\n\n```c\n#include &lt;stdint.h&gt;\n\nuint32_t mask = UINT32_C(0xFFFF0000);\n</code></pre> <p>Cos\u00ec evitiamo warning o errori quando usiamo numeri grandi.</p>"},{"location":"codice/lezioni_di_c/stdint/#buona-pratica","title":"Buona pratica","text":"<p>In un progetto embedded \u00e8 consigliato:</p> <ul> <li>usare sempre i tipi di <code>stdint.h</code> (<code>uint8_t</code>, <code>int32_t</code>, \u2026)</li> <li>evitare i tipi \u201cclassici\u201d (<code>int</code>, <code>long</code>, \u2026) perch\u00e9 non sempre hanno la stessa dimensione tra PC e microcontrollore</li> <li>abbinare <code>stdbool.h</code> e <code>stdint.h</code> per scrivere codice pi\u00f9 leggibile e portabile</li> </ul>"},{"location":"codice/lezioni_di_c/stdint/#confronto-tra-tipi-standard-e-tipi-di-stdinth","title":"Confronto tra tipi standard e tipi di <code>stdint.h</code>","text":"Tipo classico Dimensione (dipende da architettura) Possibili valori Equivalente <code>stdint.h</code> (fisso) <code>char</code> 8 bit (di solito) -128 \u2026 127 / 0 \u2026 255 <code>int8_t</code> / <code>uint8_t</code> <code>short</code> almeno 16 bit (spesso 16) -32.768 \u2026 32.767 <code>int16_t</code> <code>unsigned short</code> almeno 16 bit (spesso 16) 0 \u2026 65.535 <code>uint16_t</code> <code>int</code> almeno 16 bit (spesso 32 su ARM) dipende da piattaforma <code>int32_t</code> (se serve 32 bit certi) <code>unsigned int</code> almeno 16 bit (spesso 32) dipende da piattaforma <code>uint32_t</code> <code>long</code> almeno 32 bit (pu\u00f2 essere 32 o 64) dipende da compilatore <code>int32_t</code> o <code>int64_t</code> <code>unsigned long</code> almeno 32 bit (pu\u00f2 essere 32 o 64) dipende da compilatore <code>uint32_t</code> o <code>uint64_t</code>"},{"location":"codice/lezioni_di_c/stdint/#perche-e-importante","title":"Perch\u00e9 \u00e8 importante?","text":"<p>Su un PC a 64 bit: - <code>int</code> \u00e8 spesso 32 bit. - <code>long</code> \u00e8 64 bit (Linux) o 32 bit (Windows).  </p> <p>Su un microcontrollore ARM Cortex-M: - <code>int</code> \u00e8 quasi sempre 32 bit. - <code>long</code> \u00e8 32 bit (non 64!).  </p> <p>Quindi lo stesso codice scritto con <code>int</code> e <code>long</code> pu\u00f2 comportarsi in modo diverso a seconda di dove gira. Con <code>stdint.h</code> questo problema non esiste: la dimensione \u00e8 sempre quella dichiarata.</p>"},{"location":"codice/lezioni_di_c/strutture_base/","title":"Strutture dati minime","text":"<p>Nel linguaggio C le strutture dati fondamentali che si usano quasi ovunque sono gli array, le struct e le enum. Conoscerle a fondo \u00e8 essenziale per scrivere codice chiaro, efficiente e comprensibile.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#array","title":"Array","text":"<p>Un array \u00e8 una sequenza di elementi dello stesso tipo, memorizzati in celle di memoria contigue. Quando si dichiara un array, si deve indicare il tipo degli elementi e la dimensione:</p> <pre><code>int valori[10]; // array di 10 interi\n````\n\nQuesto significa che la variabile `valori` contiene 10 interi, indicizzati da `0` a `9`. L\u2019indice deve sempre essere compreso tra 0 e dimensione-1. Accedere a un indice fuori dai limiti produce un comportamento indefinito, cio\u00e8 errori difficili da individuare.\n\nGli array possono essere **inizializzati**:\n\n```c\nint a[5] = {1, 2, 3, 4, 5};\nint b[5] = {0}; // tutti inizializzati a zero\n</code></pre> <p>Se si forniscono meno valori rispetto alla dimensione, i restanti vengono messi a zero. \u00c8 possibile anche lasciare vuota la dimensione quando i valori sono noti a compilazione:</p> <pre><code>int c[] = {10, 20, 30}; // dimensione 3 dedotta dal compilatore\n</code></pre> <p>Gli array di caratteri sono spesso usati per rappresentare stringhe terminate dal carattere nullo <code>'\\0'</code>:</p> <pre><code>char nome[10] = \"ciao\"; // occuper\u00e0 5 celle: 'c','i','a','o','\\0'\n</code></pre> <p>Negli ambienti embedded gli array vengono utilizzati anche come buffer per la comunicazione (es. pacchetti CAN, UART). In questi casi \u00e8 fondamentale rispettare sempre la dimensione massima per evitare corruzione di memoria.</p> <p>Un array in C si comporta quasi sempre come un puntatore al suo primo elemento. Questo significa che se passo un array a una funzione, in realt\u00e0 passo l\u2019indirizzo della prima cella, non una copia dell\u2019intero array:</p> <pre><code>void stampa(int arr[], int n) {\n    for(int i = 0; i &lt; n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_base/#struct","title":"Struct","text":"<p>Una <code>struct</code> \u00e8 una struttura che permette di raggruppare variabili di tipi diversi sotto un unico nome. \u00c8 molto utile per rappresentare entit\u00e0 complesse:</p> <pre><code>struct Punto {\n    int x;\n    int y;\n};\n</code></pre> <p>Ora \u00e8 possibile dichiarare variabili di questo tipo:</p> <pre><code>struct Punto p1 = {10, 20};\n</code></pre> <p>Ogni campo si accede con l\u2019operatore <code>.</code>:</p> <pre><code>printf(\"%d\", p1.x);\n</code></pre> <p>Le struct possono contenere anche array o altre struct:</p> <pre><code>struct Rettangolo {\n    struct Punto vertici[4];\n};\n</code></pre> <p>Quando si lavora con puntatori a struct, si usa l\u2019operatore <code>-&gt;</code>:</p> <pre><code>struct Punto *pp = &amp;p1;\npp-&gt;x = 5; // equivalente a (*pp).x\n</code></pre> <p>\u00c8 possibile usare <code>typedef</code> per evitare di scrivere ogni volta <code>struct</code>:</p> <pre><code>typedef struct {\n    int x;\n    int y;\n} Punto;\n\nPunto p2 = {3, 4};\n</code></pre> <p>In embedded le struct sono spesso usate per definire i registri delle periferiche. In questo caso \u00e8 importante considerare il padding: il compilatore pu\u00f2 inserire byte di allineamento tra i campi per rispettare i vincoli dell\u2019architettura. Questo significa che due struct con gli stessi campi ma ordine diverso possono avere dimensioni diverse. Per controllare queste situazioni si usano attributi come <code>__attribute__((packed))</code> o le opzioni del compilatore.</p> <p>Le struct possono anche essere annidate e usate come contenitori per dati condivisi tra task in un sistema operativo real-time. \u00c8 una buona pratica abbinarle a mutex o code quando pi\u00f9 parti del programma devono accedere alle stesse informazioni.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#enum","title":"Enum","text":"<p>Una <code>enum</code> definisce un insieme di valori simbolici associati a numeri interi. \u00c8 utile per rendere pi\u00f9 leggibile il codice e per rappresentare stati, modalit\u00e0 o codici di errore.</p> <pre><code>enum Stato {\n    IDLE,\n    RUN,\n    ERROR\n};\n</code></pre> <p>Di default il primo valore parte da 0 e gli altri crescono di 1. Nell\u2019esempio, <code>IDLE = 0</code>, <code>RUN = 1</code>, <code>ERROR = 2</code>. \u00c8 possibile assegnare valori arbitrari:</p> <pre><code>enum Comando {\n    START = 10,\n    STOP = 20,\n    RESET = 30\n};\n</code></pre> <p>\u00c8 consigliato usare <code>typedef</code> per semplificare:</p> <pre><code>typedef enum {\n    LED_OFF = 0,\n    LED_ON = 1\n} LedState;\n</code></pre> <p>Le enum migliorano la leggibilit\u00e0:</p> <pre><code>LedState stato = LED_OFF;\n\nif (stato == LED_ON) {\n    // accendi il LED\n}\n</code></pre> <p>In embedded le enum sono molto utili per definire le macchine a stati finiti. Ogni stato della FSM corrisponde a un valore della enum, rendendo il codice pi\u00f9 chiaro e meno soggetto a errori rispetto all\u2019uso di costanti numeriche.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#union","title":"Union","text":"<p>Una <code>union</code> \u00e8 simile a una <code>struct</code>, ma con una differenza fondamentale: tutti i campi condividono lo stesso spazio di memoria. Questo significa che una union occupa tanta memoria quanta ne richiede il campo pi\u00f9 grande, e tutti i membri si sovrappongono.</p> <p>Esempio di dichiarazione:</p> <pre><code>union Valore {\n    uint32_t intero;\n    float reale;\n    uint8_t byte[4];\n};\n````\n\nIn questo caso `union Valore` occupa 4 byte, perch\u00e9 il campo pi\u00f9 grande (`uint32_t` e `float`) \u00e8 di 4 byte.  \nSe assegniamo un valore a `intero`, possiamo leggere la sua rappresentazione binaria attraverso l\u2019array `byte`:\n\n```c\nunion Valore v;\nv.intero = 0x12345678;\n\nprintf(\"%02X %02X %02X %02X\\n\", v.byte[0], v.byte[1], v.byte[2], v.byte[3]);\n</code></pre> <p>Il risultato dipender\u00e0 dall\u2019endianness del processore (little endian o big endian), perch\u00e9 determina l\u2019ordine dei byte in memoria.</p> <p>Le union sono molto potenti, ma bisogna usarle con attenzione: scrivere in un campo e leggere da un altro non sempre \u00e8 portabile al 100% secondo lo standard C, anche se in pratica nei sistemi embedded \u00e8 una tecnica comune.</p> <p>Esempi di utilizzo tipico nelle applicazioni embedded:</p> <ul> <li>Interpretare un pacchetto ricevuto su bus di comunicazione sia come array di byte che come valori numerici.</li> <li>Definire registri hardware in modo che un singolo registro possa essere letto intero oppure per campi pi\u00f9 piccoli.</li> <li>Effettuare \u201ctype punning\u201d (riutilizzare lo stesso blocco di memoria come tipi diversi) per ridurre l\u2019uso di memoria.</li> </ul> <p>Differenze rispetto a struct:</p> <ul> <li>In una <code>struct</code> ogni campo ha il suo spazio separato, e la dimensione totale \u00e8 almeno la somma delle dimensioni dei campi (pi\u00f9 eventuale padding).</li> <li>In una <code>union</code> tutti i campi condividono lo stesso spazio, e la dimensione totale \u00e8 uguale a quella del campo pi\u00f9 grande.</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_controllo/","title":"Strutture di controllo","text":""},{"location":"codice/lezioni_di_c/strutture_controllo/#strutture-di-controllo-condizionali-prendere-decisioni","title":"Strutture di Controllo Condizionali: Prendere Decisioni","text":"<p>Spesso, un programma deve comportarsi in modo diverso a seconda delle condizioni. \"Se l'utente ha inserito una password corretta, allora accedi. Altrimenti, mostra un errore\". Questo \u00e8 il ruolo delle strutture condizionali.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#if-else-if-else","title":"<code>if</code>, <code>else if</code>, <code>else</code>","text":"<p>La struttura <code>if-else</code> \u00e8 il modo pi\u00f9 basilare per eseguire un blocco di codice solo se una certa condizione \u00e8 vera.</p> <p>La sintassi \u00e8:</p> <pre><code>if (condizione) {\n    // Blocco di codice da eseguire se la condizione \u00e8 VERA\n} else {\n    // Blocco di codice da eseguire se la condizione \u00e8 FALSA (opzionale)\n}\n</code></pre> <p>La <code>condizione</code> \u00e8 un'espressione che viene valutata come \"vera\" (qualsiasi valore diverso da 0) o \"falsa\" (0).</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int eta = 20;\n\n    if (eta &gt;= 18) {\n        printf(\"Sei maggiorenne. Puoi entrare.\\n\");\n    } else {\n        printf(\"Sei minorenne. Non puoi entrare.\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#switch","title":"<code>switch</code>","text":"<p>Quando devi controllare una singola variabile rispetto a una serie di valori costanti, usare una lunga catena di <code>if-else if</code> pu\u00f2 diventare goffo. In questi casi, lo <code>switch</code> \u00e8 una soluzione pi\u00f9 pulita e spesso pi\u00f9 efficiente.</p> <p>La sintassi \u00e8:</p> <pre><code>switch (espressione) {\n    case valore1:\n        // Codice da eseguire se espressione == valore1\n        break; // L'istruzione 'break' \u00e8 cruciale!\n    case valore2:\n        // Codice da eseguire se espressione == valore2\n        break;\n    default:\n        // Codice da eseguire se nessun 'case' corrisponde (opzionale)\n}\n</code></pre> <p>Punti Chiave dello <code>switch</code>:</p> <ol> <li>L'<code>espressione</code> deve essere di tipo intero (inclusi i <code>char</code>).</li> <li>I <code>valore</code> dei <code>case</code> devono essere costanti.</li> <li>L'istruzione <code>break</code> \u00e8 fondamentale. Se omessa, l'esecuzione \"cadr\u00e0\" (fall-through) al <code>case</code> successivo, eseguendo anche il suo codice, fino a quando non incontrer\u00e0 un <code>break</code> o la fine dello <code>switch</code>. Questo a volte \u00e8 un comportamento desiderato, ma spesso \u00e8 fonte di bug.</li> <li>Il blocco <code>default</code> cattura tutti i casi non esplicitamente gestiti.</li> </ol> <p>Attenzione:  Lo <code>switch</code> possiede un unico contesto, nel senso che una variabile dichiarata in un case, se ridichiarata in un altro generer\u00e0 un errore di compilazione. In questo caso si utilizzano le parentesi graffe per separare i contesti.</p> <pre><code>case valore: {\n    // codice da eseguire\n    break;\n}\n</code></pre> <p>Esempio: Un menu.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char scelta = 'B';\n\n    printf(\"Menu:\\n\");\n    printf(\"A - Avvia\\n\");\n    printf(\"B - Salva\\n\");\n    printf(\"C - Esci\\n\");\n    printf(\"La tua scelta: %c\\n\", scelta);\n\n    switch (scelta) {\n        case 'A':\n            printf(\"Programma avviato.\\n\");\n            break;\n        case 'B':\n            printf(\"Salvataggio in corso...\\n\");\n            break;\n        case 'C':\n            printf(\"Uscita dal programma.\\n\");\n            break;\n        default:\n            printf(\"Scelta non valida!\\n\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#loop-o-cicli-larte-della-ripetizione","title":"Loop (o Cicli): L'Arte della Ripetizione","text":"<p>I loop ci permettono di eseguire un blocco di codice pi\u00f9 volte, fino a quando una certa condizione di terminazione non viene soddisfatta. In C, abbiamo tre tipi principali di loop.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#while","title":"<code>while</code>","text":"<p>Il ciclo <code>while</code> \u00e8 il pi\u00f9 semplice. Esegue un blocco di codice fintanto che la sua condizione rimane vera. La condizione viene controllata prima di ogni esecuzione del blocco.</p> <p>Sintassi:</p> <pre><code>while (condizione) {\n    // Blocco di codice da ripetere\n    // \u00c8 importante che qui dentro qualcosa modifichi la condizione,\n    // altrimenti si crea un ciclo infinito!\n}\n</code></pre> <p>Esempio: Un conto alla rovescia.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int contatore = 5;\n\n    while (contatore &gt; 0) {\n        printf(\"%d...\\n\", contatore);\n        contatore--; // Decremento il contatore per evitare un loop infinito\n    }\n\n    printf(\"Lancio!\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#do-while-esegui-almeno-una-volta","title":"<code>do-while</code>: Esegui Almeno una Volta","text":"<p>Il <code>do-while</code> \u00e8 una variante del <code>while</code>. La sua caratteristica distintiva \u00e8 che la condizione viene controllata alla fine del blocco di codice. Questo garantisce che il codice all'interno del loop venga eseguito almeno una volta, indipendentemente dalla condizione.</p> <p>Sintassi:</p> <pre><code>do {\n    // Blocco di codice da ripetere\n} while (condizione);\n</code></pre> <p>Esempio: Richiedere un input finch\u00e9 non \u00e8 valido.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int numero;\n\n    do {\n        printf(\"Inserisci un numero positivo: \");\n        scanf(\"%d\", &amp;numero);\n\n        if (numero &lt;= 0) {\n            printf(\"Errore: il numero deve essere positivo.\\n\");\n        }\n    } while (numero &lt;= 0); // Ripeti se il numero non \u00e8 valido\n\n    printf(\"Hai inserito il numero valido: %d\\n\", numero);\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#for-il-ciclo-strutturato","title":"<code>for</code>: Il Ciclo Strutturato","text":"<p>Il ciclo <code>for</code> \u00e8 ideale quando si conosce in anticipo il numero di iterazioni da eseguire (es. \"ripeti 10 volte\" o \"scorri tutti gli elementi di un array\"). Condensa in una sola riga l'inizializzazione, la condizione e l'incremento del contatore.</p> <p>Sintassi:</p> <pre><code>for (inizializzazione; condizione; aggiornamento) {\n    // Blocco di codice da ripetere\n}\n</code></pre> <ul> <li>Inizializzazione: Eseguita una sola volta, all'inizio del ciclo.</li> <li>Condizione: Controllata prima di ogni iterazione. Se \u00e8 falsa, il ciclo termina.</li> <li>Aggiornamento: Eseguito alla fine di ogni iterazione.</li> </ul> <p>Esempio: Stampare i primi 10 numeri e la loro somma.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int somma = 0;\n\n    for (int i = 1; i &lt;= 10; i++) {\n        printf(\"Numero: %d\\n\", i);\n        somma += i;\n    }\n\n    printf(\"La somma totale \u00e8: %d\\n\", somma);\n    return 0;\n}\n</code></pre> <p>Tuttavia, il linguaggio C non obbliga a specificare tutte e tre queste parti. Ognuna di esse \u00e8 opzionale. L'unica cosa che non pu\u00f2 mancare sono le due parentesi <code>()</code> e i due punti e virgola <code>;</code> al loro interno, che agiscono come separatori.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#1-omettere-linizializzazione","title":"1. Omettere l'Inizializzazione","text":"<p>Se la variabile contatore \u00e8 gi\u00e0 stata inizializzata prima del ciclo, o se il ciclo non dipende da un nuovo contatore, possiamo lasciare vuota la prima parte.</p> <p>Quando \u00e8 utile?</p> <ul> <li>Quando il valore iniziale della variabile di controllo dipende da calcoli precedenti.    </li> <li>Quando si vuole riutilizzare una variabile esistente.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int inizio;\n    printf(\"Da che numero vuoi iniziare il conto alla rovescia? \");\n    scanf(\"%d\", &amp;inizio);\n\n    // 'inizio' \u00e8 gi\u00e0 stata inizializzata dall'utente.\n    // La prima sezione del 'for' \u00e8 vuota.\n    for ( ; inizio &gt;= 0; inizio--) {\n        printf(\"%d...\\n\", inizio);\n    }\n\n    printf(\"Finito!\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#2-omettere-laggiornamento","title":"2. Omettere l'Aggiornamento","text":"<p>Possiamo omettere la terza parte se l'aggiornamento della variabile di controllo avviene all'interno del corpo del ciclo.</p> <p>Quando \u00e8 utile?</p> <ul> <li>Quando l'aggiornamento non \u00e8 un semplice incremento/decremento (es. <code>i++</code>, <code>i--</code>).</li> <li>Quando l'aggiornamento deve avvenire solo al verificarsi di una certa condizione all'interno del ciclo.</li> </ul> <p>Esempio: Scorrere una lista concatenata fino alla fine. L'aggiornamento consiste nel passare al nodo successivo, un'operazione che si fa all'interno del ciclo.</p> <pre><code>// Ipotizzando di avere una struttura Nodo e una lista gi\u00e0 creata\n// struct Nodo { int dato; struct Nodo* next; };\n// Nodo* testa; // puntatore al primo nodo\n\n// Il puntatore 'corrente' viene aggiornato nel corpo del ciclo\nfor (Nodo* corrente = testa; corrente != NULL; ) {\n    printf(\"%d -&gt; \", corrente-&gt;dato);\n    corrente = corrente-&gt;next; // Aggiornamento manuale\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_controllo/#3-omettere-la-condizione","title":"3. Omettere la Condizione","text":"<p>Questa \u00e8 la situazione pi\u00f9 interessante e potenzialmente pericolosa. Se si omette la condizione (la parte centrale), il C la considera sempre vera. Questo crea un ciclo infinito.</p> <p>Quando \u00e8 utile? Un ciclo infinito non \u00e8 sempre un errore. \u00c8 la base per programmi che devono rimanere in esecuzione continua fino a un intervento esterno, come sistemi operativi, server, o programmi embedded. L'uscita dal ciclo viene gestita internamente con un <code>break</code>, un <code>return</code> o una chiamata a <code>exit()</code>.</p> <p>Esempio: Un menu interattivo che continua a funzionare finch\u00e9 l'utente non sceglie di uscire.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char scelta;\n\n    for ( ; ; ) { // Ciclo infinito: mancano tutte e tre le parti\n        printf(\"\\n--- MENU ---\\n\");\n        printf(\"1. Stampa 'Ciao'\\n\");\n        printf(\"2. Stampa 'Mondo'\\n\");\n        printf(\"3. Esci\\n\");\n        printf(\"Scelta: \");\n        scanf(\" %c\", &amp;scelta); // Nota lo spazio prima di %c per consumare newline\n\n        if (scelta == '1') {\n            printf(\"Ciao\\n\");\n        } else if (scelta == '2') {\n            printf(\"Mondo\\n\");\n        } else if (scelta == '3') {\n            printf(\"Uscita in corso...\\n\");\n            break; // Uscita controllata dal ciclo infinito\n        } else {\n            printf(\"Scelta non valida.\\n\");\n        }\n    }\n\n    printf(\"Programma terminato.\\n\");\n    return 0;\n}\n</code></pre> <p>La forma <code>for(;;)</code> \u00e8 una convenzione molto comune in C per indicare un ciclo infinito intenzionale. \u00c8 funzionalmente identico a <code>while(1)</code>. Viene utilizzato per creare loop infiniti per le task di freertos.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#controllare-i-loop-break-e-continue","title":"Controllare i Loop: <code>break</code> e <code>continue</code>","text":"<p>A volte abbiamo bisogno di un controllo pi\u00f9 fine sul comportamento di un loop.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#break","title":"<code>break</code>","text":"<p>L'istruzione <code>break</code> (gi\u00e0 vista nello <code>switch</code>) interrompe immediatamente l'esecuzione del loop (<code>for</code>, <code>while</code>, <code>do-while</code>) in cui si trova, e il programma prosegue con l'istruzione successiva al loop.</p>"},{"location":"codice/lezioni_di_c/strutture_controllo/#continue","title":"<code>continue</code>","text":"<p>L'istruzione <code>continue</code> salta il resto dell'iterazione corrente e passa direttamente all'iterazione successiva del loop.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/","title":"Visibilit\u00e0 e organizzazione del codice in C","text":"<p>Oltre a sapere cos\u2019\u00e8 una variabile, \u00e8 fondamentale capire dove \u00e8 visibile e come organizzare i file in un progetto embedded.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#file-c-e-h","title":"File <code>.c</code> e <code>.h</code>","text":"<p>In un progetto in C i file sono generalmente divisi in due categorie:</p> <ul> <li>File <code>.c</code> \u2192 contengono il codice implementativo (funzioni, logica).  </li> <li>File <code>.h</code> \u2192 contengono le dichiarazioni (prototipi di funzioni, definizioni di strutture, costanti, variabili globali).  </li> </ul>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#esempio","title":"Esempio","text":"<p>sensore.h</p> <pre><code>#ifndef SENSORE_H\n#define SENSORE_H\n\nvoid sensore_init(void);\nint sensore_leggi(void);\n\n#endif\n````\n\n**sensore.c**\n\n```c\n#include \"sensore.h\"\n\nvoid sensore_init(void) {\n    // inizializzazione hardware\n}\n\nint sensore_leggi(void) {\n    return 42; // valore di esempio\n}\n</code></pre> <p>Cos\u00ec il modulo <code>sensore</code> pu\u00f2 essere usato anche da altri file senza duplicare il codice.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#visibilita-delle-variabili","title":"Visibilit\u00e0 delle variabili","text":"<p>La visibilit\u00e0 definisce in quali file o funzioni una variabile \u00e8 accessibile.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#variabili-locali","title":"Variabili locali","text":"<p>Dichiarate dentro una funzione \u2192 visibili solo l\u00ec, allocate nello stack.</p> <pre><code>void funzione() {\n    int x = 10; // visibile solo dentro questa funzione\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#variabili-globali","title":"Variabili globali","text":"<p>Dichiarate fuori da ogni funzione \u2192 visibili in tutto il file <code>.c</code>.</p> <pre><code>int contatore = 0; // visibile in tutto il file\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#cose-extern","title":"Cos\u2019\u00e8 extern","text":"<p>La keyword <code>extern</code> in C serve a dichiarare una variabile o funzione definita in un altro file, cos\u00ec che il compilatore sappia che esiste e che verr\u00e0 risolta in fase di linking.</p> <p>In pratica:</p> <ul> <li><code>dichiarazione</code> = dire \u201cquesta variabile/funzione esiste da qualche parte\u201d.</li> <li><code>definizione</code> = riservare davvero memoria o scrivere il codice.</li> </ul> <p><code>extern</code> riguarda solo le variabili globali (anche se si pu\u00f2 usare pure con funzioni, ma l\u00ec \u00e8 implicito).</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#senza-extern-definizione","title":"Senza <code>extern</code> (definizione)","text":"<p>Se scrivi:</p> <pre><code>int counter = 0;\n</code></pre> <p>questa \u00e8 una definizione: il compilatore alloca spazio in memoria per <code>counter</code>.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#con-extern-dichiarazione","title":"Con <code>extern</code> (dichiarazione)","text":"<p>Se scrivi:</p> <pre><code>extern int counter;\n</code></pre> <p>questa \u00e8 solo una dichiarazione: non alloca memoria, dice solo \u201cda qualche parte esiste un <code>int counter</code>\u201d. In questo modo puoi usare <code>counter</code> anche in un file diverso da quello in cui \u00e8 stato definito.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#esempio-pratico-con-piu-file","title":"Esempio pratico con pi\u00f9 file","text":"<p>file1.c</p> <pre><code>#include &lt;stdio.h&gt;\n\nint counter = 42;   // definizione (memoria allocata qui)\n\nvoid printCounter(void) {\n    printf(\"counter = %d\\n\", counter);\n}\n</code></pre> <p>file2.c</p> <pre><code>#include &lt;stdio.h&gt;\n\nextern int counter;  // dichiarazione (nessuna memoria allocata)\n\nvoid increment(void) {\n    counter++;\n}\n</code></pre> <p>main.c</p> <pre><code>void printCounter(void);\nvoid increment(void);\n\nint main(void) {\n    printCounter();  // counter = 42\n    increment();\n    printCounter();  // counter = 43\n    return 0;\n}\n</code></pre> <p>Compilando tutti e tre insieme funziona perch\u00e9 il linker trova <code>counter</code> definito in <code>file1.c</code>:</p> <pre><code>gcc file1.c file2.c main.c -o program\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#casi-tipici-in-embedded","title":"Casi tipici in Embedded","text":"<p>Noi <code>extern</code> lo usiamo per:</p> <ul> <li>Variabili globali condivise tra pi\u00f9 moduli (es. uno stato della macchina, un buffer CAN, una coda FreeRTOS).</li> <li>Funzioni scritte in un file ma richiamate da altri, anche se l\u00ec l\u2019<code>extern</code> \u00e8 implicito.</li> <li>Header file: metti <code>extern</code> l\u00ec, la definizione vera sta nel <code>.c</code>.</li> </ul> <p>Esempio:</p> <pre><code>// uart.h\n#ifndef UART_H\n#define UART_H\n\nextern QueueHandle_t uartQueue;   // dichiarazione, visibile a tutti i .c\n\nvoid UART_Init(void);\n\n#endif\n</code></pre> <pre><code>// uart.c\n#include \"uart.h\"\n\nQueueHandle_t uartQueue;          // definizione vera (memoria allocata qui)\n\nvoid UART_Init(void) {\n    uartQueue = xQueueCreate(10, sizeof(uint8_t));\n}\n</code></pre> <p>Cos\u00ec ogni modulo che include <code>uart.h</code> sa che esiste <code>uartQueue</code>, ma la memoria viene allocata una volta sola in <code>uart.c</code>.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#il-ruolo-di-static","title":"Il ruolo di <code>static</code>","text":"<p>La parola chiave <code>static</code> ha due significati diversi a seconda del contesto. Il primo caso sono le variabili locali statiche, che mantengono il loro valore tra pi\u00f9 chiamate della funzione.</p> <pre><code>void funzione() {\n    static int chiamate = 0;\n    chiamate++;\n    printf(\"%d\\n\", chiamate);\n}\n</code></pre> <p>Ogni volta che chiamo <code>funzione()</code>, la variabile non si azzera ma \u201cricorda\u201d il valore precedente. il secondo caso sono le variabili e funzioni a livello di file, che limitano la visibilit\u00e0 al solo file <code>.c</code> (non esportate).</p> <pre><code>static int interno = 5;\n\nstatic void helper() {\n    // usata solo in questo file\n}\n</code></pre> <p>Questo \u00e8 molto utile per l\u2019incapsulamento, evitando che variabili o funzioni \u201cinterne\u201d inquinino lo spazio globale del progetto.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#buone-pratiche","title":"Buone pratiche","text":"<ul> <li>Le variabili devono essere il pi\u00f9 locali possibile.</li> <li>Le globali vanno usate solo se davvero necessarie.</li> <li>Usare <code>static</code> per tutto ci\u00f2 che \u00e8 interno a un modulo (<code>.c</code>).</li> <li>Negli header <code>.h</code> mettere solo:<ul> <li>prototipi delle funzioni pubbliche,</li> <li>definizioni di costanti/struct/enum,</li> <li>dichiarazioni <code>extern</code> se serve condividere una variabile globale.</li> </ul> </li> </ul> <p>Cos\u00ec il progetto rimane ordinato, modulare e pi\u00f9 facile da manutenere.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/","title":"Binary tree","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#introduzione-e-terminologia","title":"Introduzione e terminologia","text":"<p>Mentre le liste sono strutture lineari, gli Alberi sono strutture gerarchiche. L'Albero Binario \u00e8 una delle strutture dinamiche non lineari pi\u00f9 importanti per la ricerca, l'inserimento e la cancellazione efficienti.</p> <p>Un Albero Binario \u00e8 una struttura dati gerarchica composta da nodi. La caratteristica fondamentale \u00e8 il vincolo strutturale: ogni nodo pu\u00f2 avere al massimo due figli, storicamente chiamati figlio sinistro e figlio destro.</p> <p>Il nodo di partenza \u00e8 la radice (root), che non ha antenati. I nodi senza figli sono chiamati foglie (leaves). La sequenza di nodi da un punto all'altro si chiama cammino, e la lunghezza del cammino dalla radice a un nodo \u00e8 la sua profondit\u00e0 (depth). L'altezza dell'albero \u00e8 la profondit\u00e0 massima di qualsiasi nodo foglia.</p> <p>Termini fondamentali:</p> <ul> <li>Nodo: elemento con valore e puntatori a figli.</li> <li>Radice (root): nodo senza genitore.</li> <li>Foglia (leaf): nodo senza figli.   </li> <li>Altezza di un nodo: lunghezza del percorso pi\u00f9 lungo fino a una foglia (numero di archi).</li> <li>Profondit\u00e0/level: distanza dalla radice (root level = 0).</li> <li>Sottalbero: albero formato da un nodo e tutti i suoi discendenti.</li> </ul> <p>Forme speciali:</p> <ul> <li>Albero pieno (full/proper): ogni nodo ha 0 o 2 figli.</li> <li>Albero perfetto (perfect): pieno e tutti i livelli sono completi; ha <code>2^{h+1}-1</code> nodi (h = altezza).</li> <li>Albero completo (complete): tutti i livelli compresi (tranne l'ultimo) sono pieni, e i nodi dell'ultimo sono a sinistra.</li> <li>Albero bilanciato: altezza <code>O(log n)</code>; definizione pu\u00f2 variare (AVL, Red\u2011Black, B\u2011Tree per multiway ecc.).</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#tipologie-di-alberi-binari","title":"Tipologie di alberi binari","text":"<ul> <li>Binary Tree: generico.</li> <li>Binary Search Tree (BST): per ogni nodo, <code>left-&gt;key &lt; node-&gt;key &lt; right-&gt;key</code> (chiave univoca o gestire duplicati).</li> <li>AVL tree: BST auto\u2011bilanciato con fattore di bilanciamento <code>height(left)-height(right)</code> \u2208 {-1,0,1}; rotazioni per mantenere bilanciamento.</li> <li>Red\u2011Black tree: BST bilanciato che garantisce altezza <code>O(log n)</code> usando colori e rotazioni.</li> <li>Splay tree: BST auto\u2011adattivo che porta l'ultimo elemento accesso in radice (good for locality).</li> <li>Treap / Cartesian tree: BST con priorit\u00e0 casuali (heap property) \u2014 utile per implementazioni probabilisticamente bilanciate.</li> <li>Binary Heap: struttura completa rappresentata con array; utile per priority queue; non \u00e8 un BST.</li> <li>Threaded binary tree: usa puntatori \"thread\" al successore/predecessore inorder per traversal senza stack/ricorsione.</li> <li>Albero di espressione: nodi interni sono operatori, foglie sono operandi; valutazione postfix/infix.</li> <li>Segment tree / interval tree: alberi binari (implicitamente) per query su intervalli (range sum/min/max) con aggiornamenti.</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#traversal-algoritmi-e-implementazioni","title":"Traversal: algoritmi e implementazioni","text":"<p>Quando si parla di visita di un albero binario, ci si riferisce all\u2019ordine con cui vengono \u201ctoccati\u201d i nodi. Esistono due grandi famiglie: la visita in profondit\u00e0 (DFS, Depth-First Search) e la visita in ampiezza (BFS, Breadth-First Search).</p> <p>Le tre visite DFS classiche</p> <ol> <li> <p>Preorder     Si parte sempre dal nodo corrente (la radice, se \u00e8 la prima volta), lo si visita subito e poi si scende prima nel sottoalbero sinistro e poi nel destro.     \u00c8 come se il padre avesse la priorit\u00e0: lo guardi subito, prima di interessarti ai figli.     Questo tipo di visita \u00e8 molto utile, ad esempio, se vuoi salvare o clonare la struttura dell\u2019albero, perch\u00e9 mantieni prima l\u2019informazione del nodo e poi dei suoi discendenti.</p> </li> <li> <p>Inorder     In questo caso l\u2019ordine \u00e8: prima il sottoalbero sinistro, poi il nodo corrente e infine il sottoalbero destro.     \u00c8 la visita pi\u00f9 importante quando si parla di alberi binari di ricerca (BST), perch\u00e9 restituisce gli elementi in ordine crescente.     \u00c8 come leggere un libro da sinistra a destra: prima quello che c\u2019\u00e8 a sinistra, poi il centro, poi la parte destra.</p> </li> <li> <p>Postorder     Qui invece si visita prima il sottoalbero sinistro, poi il destro e solo per ultimo il nodo corrente.     \u00c8 come dire: \u201cprima mi occupo dei figli e solo dopo del padre\u201d.     Questo ordine \u00e8 molto comodo quando bisogna cancellare un albero dalla memoria, perch\u00e9 si eliminano prima i nodi pi\u00f9 in basso e solo alla fine le radici. Allo stesso modo, viene usato negli alberi di espressioni per calcolare il valore: prima si calcolano i termini elementari e solo alla fine l\u2019operazione principale.</p> </li> </ol> <p>BFS \u2014 Level Order</p> <p>Diverso \u00e8 il caso della visita in ampiezza (BFS), detta anche \u201cper livelli\u201d. Qui non si scende in profondit\u00e0 subito, ma si procede un livello alla volta: prima la radice, poi tutti i figli della radice, poi i figli di quei figli, e cos\u00ec via. \u00c8 un po\u2019 come leggere l\u2019albero riga per riga, da sinistra a destra. Questa modalit\u00e0 viene spesso usata quando serve dare priorit\u00e0 alla distanza dalla radice, ad esempio per calcolare la profondit\u00e0 minima o per trovare il cammino pi\u00f9 breve in alberi o grafi.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#traversal-ricorsivi-c","title":"Traversal ricorsivi (C)","text":"<pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct Node {\n    int key;\n    struct Node *left, *right;\n} Node;\n\nvoid preorder(Node* r){\n    if(!r) return;\n    printf(\"%d \", r-&gt;key);\n    preorder(r-&gt;left);\n    preorder(r-&gt;right);\n}\n\nvoid inorder(Node* r){\n    if(!r) return;\n    inorder(r-&gt;left);\n    printf(\"%d \", r-&gt;key);\n    inorder(r-&gt;right);\n}\n\nvoid postorder(Node* r){\n    if(!r) return;\n    postorder(r-&gt;left);\n    postorder(r-&gt;right);\n    printf(\"%d \", r-&gt;key);\n}\n</code></pre> <p>I traversal ricorsivi sono semplici ma usano stack di chiamate <code>O(h)</code> (altezza). In sistemi embedded bisogna fare attenzione alla profondit\u00e0 dello stack.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#traversal-iterativi-con-stack","title":"Traversal iterativi con stack","text":"<pre><code>#include &lt;stdlib.h&gt;\n\ntypedef struct StackNode {\n    Node* t;\n    struct StackNode* next;\n} StackNode;\n\nvoid push(StackNode** top, Node* t) { \n    StackNode* n = malloc(sizeof(StackNode));\n    n-&gt;t=t;\n    n-&gt;next=*top;\n    *top=n;\n}\n\nNode* pop(StackNode** top) {\n    if(!*top) return NULL;\n    StackNode* n=*top;\n    Node* t=n-&gt;t;\n    *top = n-&gt;next;\n    free(n);\n    return t;\n}\n\nint empty(StackNode* top) {\n    return top==NULL;\n}\n\nvoid inorder_iter(Node* root){\n    StackNode* st = NULL;\n    Node* cur = root;\n    while(cur || !empty(st)){\n        while(cur){ push(&amp;st, cur); cur = cur-&gt;left; }\n        cur = pop(&amp;st);\n        printf(\"%d \", cur-&gt;key);\n        cur = cur-&gt;right;\n    }\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#morris-inorder-o1-space","title":"Morris Inorder (O(1) space)","text":"<p>Idea: usare collegamenti temporanei al predecessore inorder.</p> <pre><code>void inorder_morris(Node* root){\n    Node* cur = root;\n    while(cur){\n        if(!cur-&gt;left){\n            printf(\"%d \", cur-&gt;key);\n            cur = cur-&gt;right;\n        } else {\n            Node* pred = cur-&gt;left;\n            while(pred-&gt;right &amp;&amp; pred-&gt;right != cur) pred = pred-&gt;right;\n            if(!pred-&gt;right){\n                pred-&gt;right = cur; // thread\n                cur = cur-&gt;left;\n            } else {\n                pred-&gt;right = NULL; // restore\n                printf(\"%d \", cur-&gt;key);\n                cur = cur-&gt;right;\n            }\n        }\n    }\n}\n</code></pre> <p>Morris \u00e8 utile quando la memoria \u00e8 critica; modifica temporaneamente la struttura e la ripristina.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#levelorder-bfs","title":"Level\u2011order (BFS)","text":"<p>Usa una coda (queue):</p> <pre><code>#include &lt;stdlib.h&gt;\n\ntypedef struct QNode {\n  Node* t;\n  struct QNode* next;\n} QNode;\n\ntypedef struct Queue {\n  QNode *head, *tail;\n} Queue;\n\nvoid qpush(Queue* q, Node* t) {\n  QNode* n = malloc(sizeof(QNode));\n  n-&gt;t = t;\n  n-&gt;next = NULL;\n  if (!q-&gt;tail)\n    q-&gt;head = q-&gt;tail = n;\n  else {\n    q-&gt;tail-&gt;next = n;\n    q-&gt;tail = n;\n  }\n}\n\nNode* qpop(Queue* q) {\n  if (!q-&gt;head) return NULL;\n  QNode* n = q-&gt;head;\n  Node* t = n-&gt;t;\n  q-&gt;head = n-&gt;next;\n  if (!q-&gt;head) q-&gt;tail = NULL;\n  free(n);\n  return t;\n}\n\nint qempty(Queue* q) { return q-&gt;head == NULL; }\n\nvoid level_order(Node* root) {\n  if (!root) return;\n  Queue q = {0};\n  qpush(&amp;q, root);\n  while (!qempty(&amp;q)) {\n    Node* n = qpop(&amp;q);\n    printf(\"%d \", n-&gt;key);\n    if (n-&gt;left) qpush(&amp;q, n-&gt;left);\n    if (n-&gt;right) qpush(&amp;q, n-&gt;right);\n  }\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#bst-binary-search-tree","title":"BST (Binary Search Tree)","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#proprieta-e-complessita","title":"Propriet\u00e0 e complessit\u00e0","text":"<p>Le operazioni fondamentali su un albero binario di ricerca, cio\u00e8 ricerca, inserimento e cancellazione, hanno una complessit\u00e0 che dipende fortemente dalla forma dell\u2019albero. Nel caso \u201cideale\u201d, quando l\u2019albero \u00e8 bilanciato, ogni livello \u00e8 riempito in modo abbastanza uniforme e quindi l\u2019altezza dell\u2019albero cresce come il logaritmo del numero di nodi. Questo significa che in media la ricerca, l\u2019inserimento e la cancellazione richiedono un numero di passi proporzionale a <code>log n</code>, dove <code>n</code> \u00e8 il numero di elementi.</p> <p>Tuttavia, il BST di per s\u00e9 non garantisce il bilanciamento. Se, ad esempio, i dati vengono inseriti in ordine crescente, l\u2019albero tende a degenerare in una semplice linked list: ogni nodo ha solo il figlio destro, e l\u2019altezza diventa <code>n</code>. In questa situazione, tutte le operazioni fondamentali (ricerca, inserimento, cancellazione) peggiorano fino a richiedere tempo lineare <code>O(n)</code>.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#implementazione-base-in-c-ricorsiva","title":"Implementazione base in C (ricorsiva)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct Node {\n  int key;\n  struct Node *left, *right;\n} Node;\n\nNode* new_node(int key) {\n  Node* n = malloc(sizeof(Node));\n  if (!n) return NULL;\n  n-&gt;key = key;\n  n-&gt;left = n-&gt;right = NULL;\n  return n;\n}\n\nNode* bst_insert(Node* root, int key) {\n  if (!root) return new_node(key);\n  if (key &lt; root-&gt;key)\n    root-&gt;left = bst_insert(root-&gt;left, key);\n  else if (key &gt; root-&gt;key)\n    root-&gt;right = bst_insert(root-&gt;right, key);\n  // se permetti duplicati, scegli una policy\n  return root;\n}\n\nNode* bst_search(Node* root, int key) {\n  while (root &amp;&amp; root-&gt;key != key)\n    root = (key &lt; root-&gt;key) ? root-&gt;left : root-&gt;right;\n  return root;\n}\n\nNode* bst_find_min(Node* root) {\n  while (root &amp;&amp; root-&gt;left) root = root-&gt;left;\n  return root;\n}\n\nNode* bst_delete(Node* root, int key) {\n  if (!root) return NULL;\n  if (key &lt; root-&gt;key)\n    root-&gt;left = bst_delete(root-&gt;left, key);\n  else if (key &gt; root-&gt;key)\n    root-&gt;right = bst_delete(root-&gt;right, key);\n  else {\n    if (!root-&gt;left) {\n      Node* r = root-&gt;right;\n      free(root);\n      return r;\n    } else if (!root-&gt;right) {\n      Node* l = root-&gt;left;\n      free(root);\n      return l;\n    } else {\n      Node* succ = bst_find_min(root-&gt;right);\n      root-&gt;key = succ-&gt;key;\n      root-&gt;right = bst_delete(root-&gt;right, succ-&gt;key);\n    }\n  }\n  return root;\n}\n</code></pre> <p><code>bst_delete</code> gestisce i tre casi (0, 1, 2 figli). L'approccio mostrato copia la chiave del successore e cancella il successore.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#bilanciamento-avl-e-redblack","title":"Bilanciamento: AVL e Red\u2011Black","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#avl-dettagli-pratici","title":"AVL (dettagli pratici)","text":"<p>Gli alberi AVL sono alberi binari di ricerca che mantengono sempre un buon livello di equilibrio. Per fare questo, ad ogni nodo viene associato un numero chiamato fattore di bilanciamento (Balance Factor, BF), che non \u00e8 altro che la differenza tra l\u2019altezza del sottoalbero sinistro e quella del sottoalbero destro. Finch\u00e9 questo valore rimane compreso tra \u22121 e +1, l\u2019albero \u00e8 considerato bilanciato. Se invece un\u2019operazione di inserimento o cancellazione fa s\u00ec che in qualche nodo il fattore di bilanciamento esca da questo intervallo, bisogna riequilibrare la struttura tramite una o pi\u00f9 rotazioni.</p> <p>Le rotazioni sono semplici ristrutturazioni locali dell\u2019albero che ne modificano la forma ma non l\u2019ordinamento dei dati. Esistono quattro casi principali:</p> <ul> <li> <p>Se l\u2019albero \u00e8 troppo \u201cpesante\u201d a sinistra (BF &gt; 1) perch\u00e9 il nuovo nodo \u00e8 stato inserito a sua volta nel ramo sinistro del figlio sinistro, si esegue una rotazione a destra. Questo caso \u00e8 chiamato LL.</p> </li> <li> <p>Al contrario, se \u00e8 troppo sbilanciato a destra (BF &lt; \u22121) e il nuovo nodo si trova nel ramo destro del figlio destro, la soluzione \u00e8 una rotazione a sinistra: il caso RR.</p> </li> <li> <p>Le cose diventano leggermente pi\u00f9 complesse se lo sbilanciamento deriva da un inserimento \u201cincrociato\u201d. Se il nodo \u00e8 andato a finire nel ramo destro del figlio sinistro, prima si fa una rotazione a sinistra sul figlio sinistro e poi una rotazione a destra sulla radice: questo \u00e8 il caso LR.</p> </li> <li> <p>Infine, se il nodo \u00e8 nel ramo sinistro del figlio destro, la correzione \u00e8 simmetrica: prima una rotazione a destra sul figlio destro e poi una rotazione a sinistra sulla radice, cio\u00e8 il caso RL.</p> </li> </ul> <p>Con queste quattro operazioni si riesce a riportare sempre l\u2019albero entro i limiti di bilanciamento. In questo modo, gli alberi AVL garantiscono che le operazioni fondamentali come ricerca, inserimento e cancellazione restino sempre efficienti, con complessit\u00e0 <code>O(log n)</code> anche nei casi peggiori.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#codice-essenziale-avl-insert-rotazioni","title":"Codice essenziale (AVL insert + rotazioni)","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\ntypedef struct AVLNode { int key; int height; struct AVLNode *left, *right; } AVLNode;\n\nint max(int a,int b){ return a&gt;b?a:b; }\nint height(AVLNode* n){ return n ? n-&gt;height : 0; }\n\nAVLNode* new_avl_node(int key){ AVLNode* n = malloc(sizeof(AVLNode)); if(!n) return NULL; n-&gt;key=key; n-&gt;left=n-&gt;right=NULL; n-&gt;height=1; return n; }\n\nAVLNode* right_rotate(AVLNode* y){\n    AVLNode* x = y-&gt;left;\n    AVLNode* T2 = x-&gt;right;\n    x-&gt;right = y;\n    y-&gt;left = T2;\n    y-&gt;height = 1 + max(height(y-&gt;left), height(y-&gt;right));\n    x-&gt;height = 1 + max(height(x-&gt;left), height(x-&gt;right));\n    return x; // nuova radice\n}\n\nAVLNode* left_rotate(AVLNode* x){\n    AVLNode* y = x-&gt;right;\n    AVLNode* T2 = y-&gt;left;\n    y-&gt;left = x;\n    x-&gt;right = T2;\n    x-&gt;height = 1 + max(height(x-&gt;left), height(x-&gt;right));\n    y-&gt;height = 1 + max(height(y-&gt;left), height(y-&gt;right));\n    return y;\n}\n\nAVLNode* avl_insert(AVLNode* node, int key){\n    if(!node) return new_avl_node(key);\n    if(key &lt; node-&gt;key) node-&gt;left = avl_insert(node-&gt;left, key);\n    else if(key &gt; node-&gt;key) node-&gt;right = avl_insert(node-&gt;right, key);\n    else return node; // duplicati non gestiti\n\n    node-&gt;height = 1 + max(height(node-&gt;left), height(node-&gt;right));\n    int balance = height(node-&gt;left) - height(node-&gt;right);\n\n    // LL\n    if(balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) return right_rotate(node);\n    // RR\n    if(balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key) return left_rotate(node);\n    // LR\n    if(balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key){ node-&gt;left = left_rotate(node-&gt;left); return right_rotate(node); }\n    // RL\n    if(balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key){ node-&gt;right = right_rotate(node-&gt;right); return left_rotate(node); }\n\n    return node;\n}\n</code></pre> <p>L'implementazione della cancellazione in AVL \u00e8 pi\u00f9 lunga (si applicano rotazioni dopo la cancellazione per ribilanciare). L'idea \u00e8 la stessa: dopo ogni modifica si aggiorna <code>height</code> e si controlla il <code>balance</code>.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#52-redblack-concetti","title":"5.2 Red\u2011Black (concetti)","text":"<p>Gli alberi Red-Black sono un\u2019altra famiglia di alberi binari di ricerca bilanciati. L\u2019idea alla base \u00e8 un po\u2019 diversa rispetto agli AVL: invece di tenere sotto controllo con precisione l\u2019altezza di ogni nodo, si assegna a ciascun nodo un colore, che pu\u00f2 essere rosso o nero, e si impongono alcune regole che garantiscono che l\u2019albero resti \u201cabbastanza\u201d bilanciato.</p> <p>Le regole fondamentali sono queste:</p> <ul> <li> <p>Ogni nodo deve essere colorato in rosso o in nero.</p> </li> <li> <p>La radice dell\u2019albero \u00e8 sempre nera.</p> </li> <li> <p>Le foglie vuote (i nodi NIL) vengono considerate nere.</p> </li> <li> <p>Non possono esserci due nodi rossi consecutivi: se un nodo \u00e8 rosso, allora i suoi figli devono per forza essere neri.</p> </li> <li> <p>Qualunque percorso che parte da un nodo e arriva a una foglia NIL deve attraversare lo stesso numero di nodi neri. Questo valore prende il nome di black height e garantisce che i cammini nell\u2019albero non possano divergere troppo in lunghezza.</p> </li> </ul> <p>Grazie a queste propriet\u00e0, l\u2019albero Red-Black resta sempre bilanciato in modo \u201clasco\u201d: non perfettamente come un AVL, ma comunque con altezza proporzionale a <code>log n</code>. Questo significa che operazioni come inserimento, ricerca e cancellazione restano sempre efficienti.</p> <p>Naturalmente, mantenere queste regole non \u00e8 automatico. Dopo un\u2019operazione di inserimento o di cancellazione pu\u00f2 capitare che alcune propriet\u00e0 vengano violate. In questi casi bisogna aggiustare la struttura con una combinazione di rotazioni (come negli AVL) e cambi di colore. L\u2019algoritmo \u00e8 un po\u2019 pi\u00f9 articolato rispetto agli AVL, ma la garanzia \u00e8 che dopo pochi passi l\u2019albero torna valido.</p> <p>Proprio per la loro efficienza e stabilit\u00e0, gli alberi Red-Black vengono usati molto spesso in librerie e sistemi reali. Ad esempio, le strutture dati <code>map</code> e <code>set</code> della libreria standard del C++ sono basate su alberi Red-Black, cos\u00ec come molte implementazioni interne nei kernel dei sistemi operativi.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#binary-heap-array-e-heapsort","title":"Binary Heap (array) e Heapsort","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#rappresentazione","title":"Rappresentazione","text":"<p>Un binary heap \u00e8 una struttura dati molto efficiente che si pu\u00f2 rappresentare in modo estremamente semplice utilizzando un array. L\u2019idea \u00e8 che l\u2019albero binario non venga memorizzato tramite puntatori, ma piuttosto sfruttando la posizione degli elementi nell\u2019array per ricostruire i legami padre-figlio.</p> <p>Se consideriamo un array <code>A[0..n-1]</code>, le relazioni sono fisse:</p> <ul> <li>il padre di un nodo che si trova in posizione <code>i</code> si calcola come <code>(i - 1) / 2</code>;</li> <li>il figlio sinistro \u00e8 in <code>2*i + 1</code>;</li> <li>il figlio destro \u00e8 in <code>2*i + 2</code>.</li> </ul> <p>In questo modo, non serve memorizzare puntatori espliciti: basta l\u2019indice.</p> <p>Ci sono due varianti principali di heap: min-heap e max-heap. Nel max-heap, che \u00e8 quello pi\u00f9 spesso utilizzato, la propriet\u00e0 da rispettare \u00e8 che ogni nodo sia maggiore o uguale ai propri figli. In altre parole, il valore nella posizione del padre deve sempre essere almeno grande quanto quello dei suoi figli. Grazie a questa regola, l\u2019elemento massimo dell\u2019intera struttura si trova sempre nella radice, cio\u00e8 nella cella <code>A[0]</code>. Nel caso del min-heap, invece, vale la propriet\u00e0 opposta: il minimo si trova sempre in cima.</p> <p>Questa rappresentazione permette di gestire in maniera molto veloce operazioni come inserimento, estrazione del massimo/minimo e costruzione di un heap a partire da un array. Inoltre, proprio grazie alla sua semplicit\u00e0, l\u2019heap binario \u00e8 alla base di un algoritmo di ordinamento molto famoso: l\u2019heapsort.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#operazioni-principali","title":"Operazioni principali","text":"<p>Le operazioni fondamentali che permettono di lavorare con un binary heap sono poche ma molto potenti.</p> <p>Quando si vuole inserire un nuovo elemento nell\u2019heap, lo si mette inizialmente in fondo all\u2019array, cio\u00e8 nella prima posizione libera. A questo punto per\u00f2 l\u2019elemento potrebbe violare la propriet\u00e0 dell\u2019heap (ad esempio, in un max-heap potrebbe essere pi\u00f9 grande del suo padre). Per ristabilire l\u2019ordine, si esegue l\u2019operazione chiamata sift up: in pratica, si confronta il nodo con il suo padre e, se \u00e8 maggiore, i due vengono scambiati. Questo controllo continua a salire lungo l\u2019albero finch\u00e9 la propriet\u00e0 dell\u2019heap non \u00e8 di nuovo rispettata.</p> <p>L\u2019operazione opposta avviene quando si vuole estrarre l\u2019elemento massimo (nel max-heap). In questo caso si prende la radice, cio\u00e8 <code>A[0]</code>, che contiene sempre il valore pi\u00f9 grande. Per non lasciare un buco, l\u2019ultimo elemento dell\u2019array viene spostato provvisoriamente in cima. A questo punto per\u00f2 \u00e8 probabile che la propriet\u00e0 dell\u2019heap non sia rispettata, quindi bisogna farlo \u201cscendere\u201d nel posto giusto. Questo si fa con l\u2019operazione di sift down: si confronta il nodo con i figli e, se uno dei figli \u00e8 pi\u00f9 grande, si scambia con quello pi\u00f9 grande dei due. L\u2019operazione continua finch\u00e9 il nodo non si trova in una posizione che rispetta le regole.</p> <p>Infine, c\u2019\u00e8 l\u2019operazione di build heap, che costruisce un heap partendo da un array arbitrario di <code>n</code> elementi. Un metodo ingenuo sarebbe inserire gli elementi uno alla volta e fare <code>sift up</code> ogni volta, ma questo porta a una complessit\u00e0 <code>O(n log n)</code>. In realt\u00e0, esiste un algoritmo pi\u00f9 efficiente: si parte dal basso e si applica <code>sift down</code> solo ai nodi interni (cio\u00e8 quelli che hanno figli). In questo modo si riesce a trasformare l\u2019intero array in un heap in tempo lineare <code>O(n)</code>.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#codice-e-heapsort","title":"Codice e heapsort","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid swap(int *a,int *b){ int t=*a; *a=*b; *b=t; }\n\nvoid sift_down(int *A, int n, int i){\n    int largest = i;\n    int l = 2*i+1, r = 2*i+2;\n    if(l &lt; n &amp;&amp; A[l] &gt; A[largest]) largest = l;\n    if(r &lt; n &amp;&amp; A[r] &gt; A[largest]) largest = r;\n    if(largest != i){ swap(&amp;A[i], &amp;A[largest]); sift_down(A, n, largest); }\n}\n\nvoid build_heap(int *A, int n){\n    for(int i = n/2 - 1; i &gt;= 0; --i) sift_down(A, n, i);\n}\n\nvoid heapsort(int *A, int n){\n    build_heap(A, n);\n    for(int i = n-1; i &gt; 0; --i){ swap(&amp;A[0], &amp;A[i]); sift_down(A, i, 0); }\n}\n</code></pre> <p><code>heapsort</code> \u00e8 <code>O(n log n)</code> worst/average; uso in\u2011place, stabile? non stabile.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#tree-sort","title":"Tree sort","text":""},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#cose-il-treesort","title":"Cos\u2019\u00e8 il TreeSort","text":"<p>Il TreeSort \u00e8 un algoritmo di ordinamento che sfrutta un albero binario di ricerca (BST). L\u2019idea \u00e8 molto semplice:</p> <ol> <li>Si parte da una sequenza di numeri non ordinati.</li> <li>Si inseriscono tutti gli elementi in un BST.<ul> <li>L\u2019inserimento segue la regola del BST: i valori minori vanno a sinistra, i maggiori a destra.</li> </ul> </li> <li>Una volta costruito l\u2019albero, si esegue una visita inorder.<ul> <li>Ricorda che in un BST la visita inorder restituisce sempre gli elementi in ordine crescente.</li> </ul> </li> </ol> <p>Il risultato finale sar\u00e0 la sequenza ordinata.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#complessita","title":"Complessit\u00e0","text":"<ul> <li>Caso medio (albero bilanciato):<ul> <li>Inserire <code>n</code> elementi costa <code>O(n log n)</code> (perch\u00e9 ogni inserimento richiede log n).</li> <li>La visita inorder costa <code>O(n)</code>.</li> <li>Complessivamente: O(n log n).</li> </ul> </li> <li>Caso peggiore (albero degenerato):<ul> <li>Se i dati sono gi\u00e0 ordinati e si usa un BST semplice (non bilanciato), l\u2019albero diventa una lista.</li> <li>Ogni inserimento costa <code>O(n)</code> \u2192 tempo totale <code>O(n\u00b2)</code>.</li> </ul> </li> </ul> <p>Per questo, in pratica il TreeSort \u00e8 efficiente solo se si utilizza un albero bilanciato (AVL, Red-Black). Con un AVL, ad esempio, si garantisce sempre <code>O(n log n)</code>.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Nodo dell\u2019albero\ntypedef struct Node {\n    int key;\n    struct Node *left, *right;\n} Node;\n\n// Creazione nuovo nodo\nNode* newNode(int key) {\n    Node* node = (Node*) malloc(sizeof(Node));\n    node-&gt;key = key;\n    node-&gt;left = node-&gt;right = NULL;\n    return node;\n}\n\n// Inserimento nel BST\nNode* insert(Node* root, int key) {\n    if (root == NULL) return newNode(key);\n    if (key &lt; root-&gt;key)\n        root-&gt;left = insert(root-&gt;left, key);\n    else\n        root-&gt;right = insert(root-&gt;right, key);\n    return root;\n}\n\n// Visita inorder (stampa ordinata)\nvoid inorder(Node* root) {\n    if (root != NULL) {\n        inorder(root-&gt;left);\n        printf(\"%d \", root-&gt;key);\n        inorder(root-&gt;right);\n    }\n}\n\n// TreeSort: costruisce BST e stampa ordinato\nvoid treeSort(int arr[], int n) {\n    Node* root = NULL;\n\n    // Costruzione albero\n    for (int i = 0; i &lt; n; i++) {\n        root = insert(root, arr[i]);\n    }\n\n    // Stampa ordinata con inorder\n    inorder(root);\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {5, 3, 7, 2, 8, 1, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Array ordinato: \");\n    treeSort(arr, n);\n\n    return 0;\n}\n</code></pre> <p>TreeSort \u00e8 elegante perch\u00e9 sfrutta direttamente le propriet\u00e0 del BST. Tuttavia, nella pratica viene usato poco rispetto a QuickSort o HeapSort, proprio perch\u00e9 senza bilanciamento rischia di degradare a <code>O(n\u00b2)</code>.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#alberi-threaded","title":"Alberi Threaded","text":"<p>Un problema degli alberi binari tradizionali \u00e8 che spesso contengono molti puntatori NULL (quando un nodo non ha figlio sinistro o destro). Un threaded binary tree sfrutta questi puntatori vuoti per contenere invece riferimenti speciali che collegano i nodi tra loro in modo da facilitare la visita inorder.</p> <p>In pratica, se un nodo non ha figlio destro, il puntatore right viene usato per collegarlo direttamente al \u201csuccessore inorder\u201d. Allo stesso modo, se non ha figlio sinistro, left pu\u00f2 puntare al \u201cpredecessore inorder\u201d. Grazie a questi collegamenti (\u201cthreads\u201d), \u00e8 possibile attraversare l\u2019albero senza ricorsione n\u00e9 stack, scorrendo i nodi in ordine.</p> <p>Esempio minimo in C:</p> <pre><code>typedef struct Node {\n    int key;\n    struct Node *left, *right;\n    int ltag, rtag; // 0 = figlio, 1 = thread\n} Node;\n</code></pre> <p>Il traversal inorder diventa una semplice camminata seguendo i thread quando non ci sono figli.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#alberi-di-espressione","title":"Alberi di espressione","text":"<p>Un expression tree rappresenta un\u2019espressione aritmetica come albero binario: - Le foglie contengono operandi (numeri o variabili). - I nodi interni contengono operatori (+, -, *, /).</p> <p>Esempio: l\u2019espressione <code>(3 + 5) * (2 - 1)</code> si rappresenta cos\u00ec: - Radice = <code>*</code> - Figlio sinistro = <code>+</code> con figli <code>3</code> e <code>5</code> - Figlio destro = <code>-</code> con figli <code>2</code> e <code>1</code></p> <p>La valutazione si fa con una visita postorder: prima si calcolano i sottoalberi, poi si applica l\u2019operatore.</p> <p>Snippet in C per valutazione:</p> <pre><code>typedef struct Node {\n    char op; // operatore o '\\0' se foglia\n    int value;\n    struct Node *left, *right;\n} Node;\n\nint eval(Node* root) {\n    if (root-&gt;op == '\\0') return root-&gt;value; // foglia\n    int l = eval(root-&gt;left);\n    int r = eval(root-&gt;right);\n    switch(root-&gt;op) {\n        case '+': return l + r;\n        case '-': return l - r;\n        case '*': return l * r;\n        case '/': return l / r;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#segment-tree","title":"## Segment Tree","text":"<p>Il segment tree \u00e8 un albero che permette di rispondere in modo molto veloce a query su intervalli (es. somma, minimo, massimo su un sottoarray). L\u2019idea \u00e8 rappresentare un array <code>A[0..n-1]</code> in un albero binario dove ogni nodo memorizza l\u2019informazione aggregata di un segmento.</p> <ul> <li>La radice rappresenta l\u2019intero array.</li> <li>Ogni nodo viene diviso in due: sinistra = prima met\u00e0, destra = seconda met\u00e0.</li> <li>Le foglie corrispondono agli elementi singoli.</li> </ul> <p>Con questa struttura si ottengono: - Costruzione: <code>O(n)</code> - Query su intervallo: <code>O(log n)</code> - Aggiornamento: <code>O(log n)</code></p> <p>Esempio in C per segment tree che calcola somme:</p> <pre><code>#define MAXN 1000\nint seg[4*MAXN];\n\nvoid build(int arr[], int idx, int l, int r) {\n    if (l == r) {\n        seg[idx] = arr[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(arr, 2*idx, l, mid);\n    build(arr, 2*idx+1, mid+1, r);\n    seg[idx] = seg[2*idx] + seg[2*idx+1];\n}\n\nint query(int idx, int l, int r, int ql, int qr) {\n    if (qr &lt; l || ql &gt; r) return 0; // fuori intervallo\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) return seg[idx]; // interamente dentro\n    int mid = (l + r) / 2;\n    return query(2*idx, l, mid, ql, qr) + query(2*idx+1, mid+1, r, ql, qr);\n}\n\nvoid update(int idx, int l, int r, int pos, int val) {\n    if (l == r) {\n        seg[idx] = val;\n        return;\n    }\n    int mid = (l + r) / 2;\n    if (pos &lt;= mid) update(2*idx, l, mid, pos, val);\n    else update(2*idx+1, mid+1, r, pos, val);\n    seg[idx] = seg[2*idx] + seg[2*idx+1];\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#implementazione-per-sistemi-embedded","title":"## Implementazione per sistemi embedded","text":"<p>Negli ambienti embedded non \u00e8 sempre possibile affidarsi al normale <code>malloc</code>/<code>free</code>, sia per motivi di frammentazione, sia perch\u00e9 spesso la memoria dinamica \u00e8 limitata o non affidabile. Una strategia molto usata \u00e8 il pool allocator: si riserva un array statico di nodi e si gestisce a mano l\u2019allocazione (assegnando nodi liberi da una lista interna). Questo elimina sorprese e rende prevedibili i consumi.</p> <p>Altro punto importante \u00e8 la ricorsione. Molti algoritmi sugli alberi si basano su chiamate ricorsive (inorder, inserimenti, balancing, ecc.), ma sugli MCU lo stack pu\u00f2 essere ridotto. Due approcci tipici:</p> <ul> <li>riscrivere le funzioni in modo iterativo usando uno stack esplicito o una coda circolare;</li> <li>usare strutture alternative (ad es. alberi threaded) per eliminare del tutto la ricorsione.</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#tabelle-di-complessita-e-casi-duso","title":"Tabelle di complessit\u00e0 e casi d\u2019uso","text":"<p>Una visione d\u2019insieme delle principali strutture:</p> Struttura Inserimento Ricerca Cancellazione Note d\u2019uso principali BST semplice O(log n) medio / O(n) peggiore O(log n) / O(n) O(log n) / O(n) Semplice, didattico, inefficiente se non bilanciato AVL O(log n) O(log n) O(log n) Ottimo per query molto frequenti, altezza minima garantita Red-Black O(log n) O(log n) O(log n) Usato in librerie e kernel, inserimenti/cancellazioni pi\u00f9 veloci di AVL Heap binario O(log n) inserimento / estrazione O(1) per massimo O(log n) Base di heapsort, ottimo per code di priorit\u00e0 Segment Tree O(log n) aggiornamento / query \u2014 \u2014 Query su intervalli e aggiornamenti veloci Expression Tree dipende dalla costruzione \u2014 \u2014 Usato per calcoli simbolici e compilatori Threaded Tree come BST come BST come BST Evita stack/ricorsione, traversal pi\u00f9 leggero"},{"location":"codice/lezioni_di_c/strutture_dati/binary_tree/#errori-comuni-debugging-e-best-practice","title":"Errori comuni, debugging e best practice","text":"<ul> <li>Puntatori NULL mal gestiti: la causa pi\u00f9 tipica di crash negli alberi. Conviene centralizzare la creazione e inizializzazione dei nodi in una funzione unica.</li> <li>Sbilanciamento non trattato: se usi BST puri senza bilanciamento, gli input gi\u00e0 ordinati creano liste, degradando a <code>O(n)</code>. Per debugging puoi stampare l\u2019altezza dopo ogni inserimento e controllare se cresce troppo velocemente.</li> <li>Memory leak: dimenticare di liberare i nodi alla cancellazione. Meglio scrivere funzioni di <code>destroy_tree()</code> (postorder) o usare pool allocator che riciclano i nodi.</li> <li>Ricorsione profonda: rischi di stack overflow in MCU. Riscrivi gli algoritmi con cicli e stack manuali.</li> <li>Debugging traversal: per capire lo stato di un albero, stampa sempre le visite preorder/inorder/postorder: danno una \u201cfirma\u201d utile. Ad esempio, inorder ti mostra se un BST \u00e8 ancora valido.</li> <li>Rotazioni sbagliate in AVL/RB: errori classici stanno nella mancata aggiornazione dei puntatori o dei fattori di bilanciamento. Conviene scrivere test unitari con piccoli alberi e disegnare i casi a mano.</li> </ul> <p>Best practice generali:</p> <ul> <li>Scrivi funzioni piccole e modulari (es. <code>rotate_left</code>, <code>update_height</code>, <code>fix_violation</code>).</li> <li>Inserisci assert o logging sui fattori di bilanciamento / colori per verificare le invarianti.</li> <li>Se lavori in embedded, considera la versione iterativa + pool allocator come default.    </li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\n#define MAX_NODES 32   // massimo numero di nodi gestibili\n#define STACK_SIZE_32\n\ntypedef struct Node {\n    int key;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\n// Pool statico\nstatic Node node_pool[MAX_NODES];\nstatic int free_list[MAX_NODES];   // stack di indici liberi\nstatic int free_top = -1;\n\n// Inizializza il pool\nvoid init_pool(void) {\n    for (int i = 0; i &lt; MAX_NODES; i++) {\n        free_list[++free_top] = i;  // tutti liberi all\u2019inizio\n    }\n}\n\n// Alloca un nodo dal pool\nNode* alloc_node(int key) {\n    if (free_top &lt; 0) {\n        return NULL; // pool esaurito\n    }\n    int idx = free_list[free_top--];\n    Node* n = &amp;node_pool[idx];\n    n-&gt;key = key;\n    n-&gt;left = NULL;\n    n-&gt;right = NULL;\n    return n;\n}\n\n// Rilascia un nodo (lo rimette nel pool)\nvoid free_node(Node* n) {\n    int idx = n - node_pool;   // calcola indice nell\u2019array\n    free_list[++free_top] = idx;\n}\n</code></pre> <p>Implementazione senza ricorsione:</p> <pre><code>Node* insert_bst(Node* root, int key) {\n    Node* new_node = alloc_node(key);\n    if (!new_node) return root;  // pool pieno\n\n    if (root == NULL) {\n        return new_node; // primo nodo\n    }\n\n    Node* curr = root;\n    Node* parent = NULL;\n\n    while (curr != NULL) {\n        parent = curr;\n        if (key &lt; curr-&gt;key)\n            curr = curr-&gt;left;\n        else\n            curr = curr-&gt;right;\n    }\n\n    if (key &lt; parent-&gt;key)\n        parent-&gt;left = new_node;\n    else\n        parent-&gt;right = new_node;\n\n    return root;\n}\n\nvoid inorder_iter(Node* root) {\n    Node* stack[STACK_SIZE];\n    int top = -1;\n    Node* curr = root;\n\n    while (curr != NULL || top &gt;= 0) {\n        while (curr != NULL) {\n            stack[++top] = curr;\n            curr = curr-&gt;left;\n        }\n        curr = stack[top--];\n        printf(\"%d \", curr-&gt;key);\n        curr = curr-&gt;right;\n    }\n}\n\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/linked_list/","title":"Linked list (Lista concatenata)","text":"<p>La Lista Concatenata \u00e8 la SDD pi\u00f9 fondamentale. \u00c8 una sequenza di elementi chiamati nodi, dove ogni nodo contiene il dato e un puntatore al nodo successivo.</p> <p>Struttura di un nodo</p> <pre><code>typedef struct Nodo {\n    int dato;             // Il dato che il nodo deve memorizzare\n    struct Nodo* prossimo; // Puntatore al nodo successivo nella sequenza\n} Nodo;\n\n// Il puntatore alla testa della lista\ntypedef Nodo* Lista;\n</code></pre> <p>L'elemento <code>struct Nodo* prossimo;</code> rende la struttura autoreferenziale. Per gestire la lista, usiamo un puntatore principale, spesso chiamato testa (<code>Lista testa = NULL;</code>), che punta al primo nodo. Se la lista \u00e8 vuota, <code>testa</code> \u00e8 <code>NULL</code>.</p> <p>Inserimento in testa Questa \u00e8 l'operazione di inserimento pi\u00f9 semplice e veloce, con complessit\u00e0 temporale costante (O(1)).</p> <pre><code>Lista inserisciInTesta(Lista testa, int nuovo_dato) {\n    // 1. Alloca il nuovo nodo\n    Nodo* nuovo_nodo = (Nodo*)malloc(sizeof(Nodo));\n\n    // Controllo allocazione\n    if (nuovo_nodo == NULL) {\n        // Gestione errore\n        return testa;\n    }\n\n    // 2. Inserisce il dato\n    nuovo_nodo-&gt;dato = nuovo_dato;\n\n    // 3. Collega il nuovo nodo alla vecchia testa\n    nuovo_nodo-&gt;prossimo = testa;\n\n    // 4. Aggiorna la testa al nuovo nodo\n    return nuovo_nodo;\n}\n</code></pre> <p>Eliminazione dalla testa Operazione semplice come la recedente, fondamentale per deallocare la memoria.</p> <pre><code>// Funzione per eliminare il nodo in testa\nLista eliminaTesta(Lista testa) {\n    if (testa == NULL) {\n        return NULL; // La lista \u00e8 vuota\n    }\n\n    // 1. Salva il puntatore alla testa corrente\n    Nodo* temp = testa;\n\n    // 2. Sposta la testa al prossimo nodo\n    testa = testa-&gt;prossimo;\n\n    // 3. Dealloca il nodo precedente\n    free(temp);\n\n    // 4. Restituisce la nuova testa\n    return testa;\n}\n</code></pre> <p>Attraversamento e Stampa (Traversal) Per scorrere la lista, si parte dalla testa e si segue il puntatore <code>prossimo</code> con un ciclo finch\u00e9 non si arriva a <code>NULL</code>, ultimo elemento della lista.</p> <pre><code>void stampaLista(Lista testa) {\n    Nodo* corrente = testa; // Puntatore ausiliario per lo scorrimento\n    while (corrente != NULL) {\n        printf(\"%d -&gt; \", corrente-&gt;dato);\n        corrente = corrente-&gt;prossimo; // Passa al nodo successivo\n    }\n    printf(\"NULL\\n\");\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_dati/linked_list/#derivazioni","title":"Derivazioni","text":"<p>Oltre alla lista semplicemente concatenata che abbiamo visto ci sono principalmente altre due strutture dati che vengono derivate da questa e sono:</p> <ul> <li>Lista doppiamente concatenata: ogni nodo ha un puntatore al successivo e uno al precedente. Permette di attraversare la lista in entrambe le direzioni e di eliminare un nodo in O(1) (una volta trovato) ma occupa pi\u00f9 memoria per il doppio puntatore.</li> <li>Lista circolare: L'ultimo nodo punta al primo, creando un ciclo. Utile per l'implementazione di buffer circolari o round-robin ma bisogna stare attenti a non ciclare all'infinito.</li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/","title":"Strutture dati dinamiche","text":"<p>Le Strutture Dati Dinamiche (SDD) in C rappresentano un salto di qualit\u00e0 nella programmazione, permettendo di gestire in modo efficiente la memoria e adattarsi alle esigenze reali di un'applicazione. A differenza delle strutture statiche (come gli array, la cui dimensione \u00e8 fissata a tempo di compilazione), le SDD possono espandersi o ridursi durante l'esecuzione del programma.</p> <p>Questo \u00e8 reso possibile dall'uso combinato di due concetti fondamentali in C:</p> <ol> <li>Allocazione Dinamica della Memoria: L'uso di funzioni come <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> e <code>free()</code> per richiedere e rilasciare memoria sull'heap a tempo di esecuzione.</li> <li>Puntatori</li> </ol>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#allocazione-e-deallocazione-dinamica","title":"Allocazione e Deallocazione Dinamica","text":"<p>Per creare e gestire le SDD, se si lavora con un ambiente di sviluppo tipicamente desktop, si utilizzano le funzioni della libreria standard C (<code>stdlib.h</code>). Nei sistemi embedded spesso l'uso della libreria standard \u00e8 limitato o del tutto proibito, per questo \u00e8 necessario trovare delle soluzioni alternative.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#assenza-di-un-sistema-operativo-completo","title":"Assenza di un \"Sistema Operativo\" Completo","text":"<p>Le funzioni della CSL (specialmente I/O e gestione della memoria) assumono l'esistenza di un ambiente operativo completo, con:</p> <ul> <li>Un file system (per <code>fopen</code>, <code>fread</code>, <code>fprintf</code>, ecc.).</li> <li>Uno schermo/console ben definiti (per <code>printf</code>).</li> <li>Una gestione della memoria (Kernel) che gestisce l'heap in modo robusto.</li> </ul> <p>Nei sistemi embedded, la maggior parte di queste funzionalit\u00e0 \u00e8 assente o deve essere implementata \"da zero\" (o tramite driver minimi forniti dal produttore del chip).</p>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#problemi-con-le-funzioni-di-inputoutput-io","title":"Problemi con le Funzioni di Input/Output (I/O)","text":""},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#printf","title":"<code>printf()</code>","text":"<p>La funzione <code>printf()</code> \u00e8 molto complessa: deve interpretare la stringa di formato, convertire vari tipi di dati (float, interi lunghi), e infine scrivere l'output in un stream standard (che sia un terminale, una console seriale, o un file).</p> <ul> <li> <p>Dimensione del Codice (Footprint): L'implementazione completa di <code>printf</code> pu\u00f2 occupare decine di kilobyte di memoria Flash (ROM), che \u00e8 una quantit\u00e0 sproporzionata per un microcontrollore con 64KB totali.</p> </li> <li> <p>Reindirizzamento (Retargeting): La CSL non sa \"dove\" si trova la console. Per usare <code>printf</code>, lo sviluppatore deve \"reindirizzare\" le chiamate a una funzione a basso livello che gestisca la comunicazione hardware (es. UART o USB). Questo processo, chiamato retargeting, \u00e8 specifico per ogni hardware e RTOS.</p> </li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#gestione-dinamica-della-memoria-il-pericolo-di-malloc","title":"Gestione Dinamica della Memoria: Il Pericolo di <code>malloc()</code>","text":"<p>Questo \u00e8 l'aspetto pi\u00f9 critico e il motivo principale per cui <code>stdlib.h</code> viene spesso evitato.</p>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#frammentazione-dellheap-e-determinismo","title":"Frammentazione dell'Heap e Determinismo","text":"<ul> <li> <p>Frammentazione: Nei sistemi che devono funzionare per molto tempo, l'uso ripetuto di <code>malloc()</code> e <code>free()</code> pu\u00f2 causare la frammentazione dell'heap (memoria libera divisa in piccoli blocchi non contigui). A lungo andare, una richiesta di memoria grande potrebbe fallire, anche se c'\u00e8 abbastanza memoria totale libera.</p> </li> <li> <p>Non Determinismo: Le implementazioni standard di <code>malloc()</code> e <code>free()</code> non sono pensate per l'ambiente real-time. Il tempo necessario per allocare un blocco di memoria pu\u00f2 variare drasticamente (dipende dalla ricerca di un blocco libero), violando i requisiti di determinismo temporale di un RTOS.</p> </li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#soluzione-di-freertos-heap-management-personalizzato","title":"Soluzione di FreeRTOS: Heap Management Personalizzato","text":"<p>FreeRTOS non usa l'implementazione standard di <code>malloc()</code> ma offre diversi schemi di gestione dell'heap (es. Heap_1, Heap_2, Heap_3, ecc.), progettati per:</p> <ul> <li> <p>Essere pi\u00f9 semplici e veloci delle implementazioni standard.</p> </li> <li> <p>Offrire un compromesso tra consumo di memoria e prevenzione della frammentazione, spesso a costo di non supportare tutte le operazioni standard.</p> </li> </ul>"},{"location":"codice/lezioni_di_c/strutture_dati/strutture_dinamiche/#sicurezza-e-thread-safety-task-safety","title":"Sicurezza e Thread Safety (Task Safety)","text":"<p>Molte funzioni della CSL (es. <code>strtok()</code>, le funzioni di gestione del tempo) non sono thread-safe.</p> <ul> <li>Variabili Statiche: Alcune funzioni C utilizzano variabili statiche interne o globali. Se due Task provano a chiamare la stessa funzione contemporaneamente, l'accesso concorrente a queste variabili pu\u00f2 portare a condizioni di gara (race conditions) e a risultati errati o crash del sistema.</li> </ul> <p>Nei sistemi FreeRTOS, si devono usare:</p> <ol> <li>Versioni Thread-Safe: Molti RTOS forniscono versioni re-entrant delle funzioni C (spesso chiamate con un suffisso come <code>_r</code> o richiedendo l'uso di un mutex).</li> <li>Primitive RTOS: Per tutte le operazioni critiche (I/O, allocazione, comunicazione), \u00e8 obbligatorio usare le API di FreeRTOS (code, semafori, ecc.) per garantire la sincronizzazione e l'integrit\u00e0 dei dati.</li> </ol>"}]}