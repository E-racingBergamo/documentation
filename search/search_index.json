{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ERB documentation","text":""},{"location":"#introduzione","title":"Introduzione","text":"<p>Questa documentazione raccoglie tutte le informazioni necessarie per comprendere e lavorare sul progetto della centralina di controllo della macchina. \u00c8 pensata sia per i membri esperti del team sia per i nuovi ragazzi che iniziano a collaborare: fornisce quindi spiegazioni passo per passo, a partire dalle basi del linguaggio C fino ad arrivare ai dettagli di firmware, hardware e schede elettroniche.</p>"},{"location":"#obiettivi-della-documentazione","title":"Obiettivi della documentazione","text":"<ul> <li>Offrire una panoramica chiara del progetto nella sua interezza.  </li> <li>Fornire materiale di formazione per i nuovi membri, senza dare nulla per scontato.  </li> <li>Creare un manuale di riferimento tecnico per lo sviluppo e la manutenzione.  </li> <li>Centralizzare tutte le informazioni in un unico posto facilmente consultabile.  </li> </ul>"},{"location":"#cosa-troverai-in-queste-pagine","title":"Cosa troverai in queste pagine","text":"<ol> <li> <p>Fondamenti di programmazione in C    Per chi non ha mai programmato o ha bisogno di ripasso.  </p> </li> <li> <p>Embedded e microcontrollore    Spiegazione del funzionamento di un microcontrollore e degli strumenti di sviluppo.  </p> </li> <li> <p>FreeRTOS    Introduzione al sistema operativo real-time usato nel firmware.  </p> </li> <li> <p>Architettura software    Struttura del progetto: task, FSM, logging, parser CAN.  </p> </li> <li> <p>Hardware e schede elettroniche    Panoramica della centralina, dei sensori e delle altre PCB.  </p> </li> <li> <p>Comunicazioni    CAN bus, UART e telemetria.  </p> </li> <li> <p>Guide pratiche    Esempi passo per passo per aggiungere nuove funzionalit\u00e0 al sistema.  </p> </li> </ol>"},{"location":"#destinatari","title":"Destinatari","text":"<p>Questa documentazione \u00e8 rivolta a: - Studenti e nuovi membri del team che devono imparare da zero. - Chi si occupa di sviluppo software e firmware. - Chi lavora sull\u2019hardware o sull\u2019integrazione dei sistemi.  </p>"},{"location":"#come-utilizzare-la-documentazione","title":"Come utilizzare la documentazione","text":"<p>Ti consigliamo di partire dalla sezione Fondamenti di C, per poi proseguire con le parti embedded e gradualmente arrivare alle implementazioni specifiche della macchina. Ogni capitolo \u00e8 indipendente e pu\u00f2 essere letto anche separatamente come riferimento tecnico.</p>"},{"location":"codice/centralina/","title":"Centralina","text":"<p>Questa sezione documenta il software sviluppato per la centralina.</p>"},{"location":"codice/centralina/#architettura-generale","title":"Architettura generale","text":"<p>Il codice \u00e8 organizzato in pi\u00f9 moduli, ciascuno con responsabilit\u00e0 precise:</p> <ul> <li>CAN controller: codifica e decodifica di messaggi sulla linea CAN.</li> <li>ADC controller: gestisce i sensori analogici.</li> <li>Digital I/O: per ingressi e uscite digitali.</li> <li>Hall sensors: legge i sensori a effetto Hall.</li> <li>Inverter: comunicazione con inverter e motori</li> <li>Telemetry: formatta i messaggi di telemetria e li mette in coda per essere spediti su una periferica a scelta.</li> <li>Ticker: sincronizza le task periodiche come la lettura dei sensori o l'esecuzione della macchina a stati dell'inverter.</li> <li>Tractive system manager: gestisce la macchina a stati complessiva della macchina e fornisce le autorizzazioni per accendere gli inverter.</li> </ul>"},{"location":"codice/centralina/#freertos","title":"FreeRTOS","text":"<p>FreeRTOS \u00e8 un sistema operativo real-time open source progettato per microcontrollori. Offre meccanismi per:</p> <ul> <li>Creare e gestire task che vengono eseguiti in modo concorrente.</li> <li>Sincronizzare l\u2019esecuzione tramite code, semafori e mutex.</li> <li>Pianificare attivit\u00e0 periodiche con timer software.</li> </ul> <p>Il suo utilizzo permette di strutturare il firmware in moduli indipendenti e ben organizzati, migliorando la scalabilit\u00e0 e la manutenibilit\u00e0 del progetto.</p>"},{"location":"codice/centralina/#macchine-a-stati","title":"Macchine a stati","text":"<p>Le FSM sono implementate in C utilizzando la struttura <code>switch-case</code>. Ogni stato rappresenta una fase di funzionamento, ad esempio:</p> <pre><code>switch (state) {\n    case INIT:\n        // Inizializzazione\n        break;\n    case RUN:\n        // Esecuzione principale\n        break;\n    case ERROR:\n        // Gestione errori\n        break;\n}\n</code></pre>"},{"location":"codice/centralina/#logging","title":"Logging","text":"<p>Il logging \u00e8 gestito tramite UART con code di output. Caratteristiche principali:</p> <ul> <li>Supporto a pi\u00f9 livelli di log (INFO, WARN, ERROR).</li> <li>Invio asincrono dei messaggi.</li> </ul> <p>Esempio di utilizzo:</p> <pre><code>LOG_INFO(\"Sistema inizializzato correttamente\");\nLOG_ERROR(\"Errore durante la trasmissione CAN\");\n</code></pre>"},{"location":"codice/centralina/#comunicazioni","title":"Comunicazioni","text":""},{"location":"codice/centralina/#can","title":"CAN","text":"<ul> <li>Supporto a due linee can.</li> <li>Callback per la gestione asincrona dei messaggi.</li> </ul>"},{"location":"codice/centralina/#uart","title":"UART","text":"<ul> <li>Utilizzata per logging e debug.</li> <li>Interfaccia DMA per migliorare le prestazioni.</li> </ul>"},{"location":"codice/centralina/#moduli-futuri","title":"Moduli futuri","text":"<ul> <li>Telemetria: invio dati in tempo reale a un server esterno.</li> <li>Strategie di controllo avanzate: da integrare in base agli sviluppi del progetto.</li> </ul>"},{"location":"codice/lezioni_di_c/funzioni/","title":"Funzioni e modularit\u00e0","text":"<p>Le funzioni sono blocchi di codice riutilizzabili che eseguono un compito specifico. La loro corretta progettazione \u00e8 fondamentale per la modularit\u00e0 di un progetto, soprattutto in ambienti embedded dove il firmware viene suddiviso in moduli separati e ben organizzati.</p>"},{"location":"codice/lezioni_di_c/funzioni/#dichiarazione-e-definizione","title":"Dichiarazione e definizione","text":"<p>Una funzione si dichiara indicando il tipo di ritorno, il nome e i parametri:</p> <pre><code>int somma(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>Qui <code>somma</code> prende due interi e restituisce un intero. Il tipo di ritorno pu\u00f2 essere qualsiasi tipo valido: <code>int</code>, <code>float</code>, <code>char</code>, <code>struct</code>, oppure <code>void</code> se non deve restituire nulla.</p>"},{"location":"codice/lezioni_di_c/funzioni/#parametri-per-valore-e-per-riferimento","title":"Parametri per valore e per riferimento","text":"<ul> <li>Per valore: viene passata una copia della variabile, modifiche dentro la funzione non influenzano l\u2019originale.</li> <li>Per riferimento: si passa l\u2019indirizzo della variabile tramite un puntatore, e quindi la funzione pu\u00f2 modificare l\u2019originale.</li> </ul> <pre><code>void incrementa_valore(int x) {\n    x++;\n}\n\nvoid incrementa_riferimento(int *x) {\n    (*x)++;\n}\n</code></pre> <p>In questo caso il simbolo <code>*</code> viene chiamato operatore di dereference, che consente di modificare direttamente il valore della variabile a partire dal suo puntatore. Se nel secondo caso si facesse <code>x++</code> si andrebbe ad incrementare il puntatore alla variabile, rischiando di andare oltre la sua area di memoria con operazioni successive e corrompere altre variabili o funzioni.</p>"},{"location":"codice/lezioni_di_c/funzioni/#tipi-di-funzioni","title":"Tipi di funzioni","text":"<ol> <li>Funzioni con ritorno e parametri <code>c     int moltiplica(int a, int b) {         return a * b;     }</code></li> <li>Funzioni senza parametri <code>c     int leggi_sensore(void) {         return 42;     }</code></li> <li>Funzioni senza ritorno (<code>void</code>) <code>c     void stampa_valore(int v) {         printf(\"%d\\n\", v);     }</code></li> <li>Funzioni inline     Suggeriscono al compilatore di espandere la funzione al posto della chiamata (ottimizzazione). In poche parole la funzione viene copiata al posto della chiamata. E' consigliabile usarlo solo con funzioni piccole, cio\u00e8 che fanno una semplice operazione aritmetica o chiamata a funzione.     <code>c     inline int quadrato(int x) {         return x * x;     }</code></li> <li>Funzioni static     Se dichiarate <code>static</code> a livello di file <code>.c</code>, la loro visibilit\u00e0 \u00e8 limitata solo a quel file, impedendo che siano richiamabili da altri moduli.     <code>c     static void reset_interno(void) {         // codice interno     }</code></li> </ol> <p>E utile conoscere anche la combinazione di static e inline, che permette al compilatore di poter scegliere quando utilizzare inline o quando invece serve avere una definizione della funzione vera e propria.</p>"},{"location":"codice/lezioni_di_c/funzioni/#modularita-con-file-c-e-h","title":"Modularit\u00e0 con file <code>.c</code> e <code>.h</code>","text":"<p>Per mantenere il codice ordinato:</p> <ul> <li>nel file <code>.c</code> si mettono le definizioni delle funzioni,</li> <li>nel file <code>.h</code> si mettono i prototipi (cio\u00e8 la firma senza corpo).</li> </ul> <p>Esempio:</p> <p>math_utils.h</p> <pre><code>#ifndef MATH_UTILS_H\n#define MATH_UTILS_H\n\nint somma(int a, int b);\nint moltiplica(int a, int b);\n\n#endif\n</code></pre> <p>math_utils.c</p> <pre><code>#include \"math_utils.h\"\n\nint somma(int a, int b) {\n    return a + b;\n}\n\nint moltiplica(int a, int b) {\n    return a * b;\n}\n</code></pre> <p>Cos\u00ec gli altri moduli possono includere <code>math_utils.h</code> e usare le funzioni senza conoscere l\u2019implementazione.</p>"},{"location":"codice/lezioni_di_c/funzioni/#puntatori-a-funzioni","title":"Puntatori a funzioni","text":"<p>In C \u00e8 possibile memorizzare l\u2019indirizzo di una funzione in una variabile, e poi richiamarla attraverso questa. Questo meccanismo \u00e8 molto utile per callback e per realizzare codice flessibile.</p> <pre><code>int somma(int a, int b) { return a + b; }\nint moltiplica(int a, int b) { return a * b; }\n\nint calcola(int (*operazione)(int, int), int x, int y) {\n    return operazione(x, y);\n}\n\nint main(void) {\n    int r1 = calcola(somma, 2, 3);\n    int r2 = calcola(moltiplica, 2, 3);\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/funzioni/#typedef-per-puntatori-a-funzioni","title":"Typedef per puntatori a funzioni","text":"<p>Scrivere i prototipi di puntatori a funzioni pu\u00f2 diventare complicato, per questo si usa <code>typedef</code>.</p> <pre><code>typedef int (*Operazione)(int, int);\n\nint calcola(Operazione op, int x, int y) {\n    return op(x, y);\n}\n</code></pre> <p>Questo approccio \u00e8 molto comune in embedded, ad esempio per definire callback da registrare in un driver.</p>"},{"location":"codice/lezioni_di_c/funzioni/#lambda-in-c","title":"Lambda in C","text":"<p>Il C standard non supporta le lambda (funzioni anonime inline) come C++ o altri linguaggi. Alcuni compilatori (come GCC) offrono estensioni che permettono funzioni nidificate, ma non sono portabili e non sono consigliate in un progetto embedded.</p> <p>Per simulare lambde, in C si usano:</p> <ul> <li>puntatori a funzioni,</li> <li>funzioni statiche locali al file,</li> <li>closure manuali con struct che raggruppano stato e puntatore a funzione.</li> </ul>"},{"location":"codice/lezioni_di_c/funzioni/#funzioni-avanzate","title":"Funzioni avanzate","text":"<p>Ricorsione Una funzione ricorsiva \u00e8 una funzione che chiama se stessa per risolvere un problema pi\u00f9 grande suddividendolo in sottoproblemi pi\u00f9 semplici. Un esempio classico \u00e8 il calcolo del fattoriale:</p> <pre><code>int fattoriale(int n) {\n    if (n &lt;= 1)\n        return 1;\n    else\n        return n * fattoriale(n - 1);\n}\n</code></pre> <p>In questo caso la funzione continua a richiamarsi fino a quando raggiunge la condizione base (<code>n &lt;= 1</code>). La ricorsione \u00e8 potente, ma in ambiente embedded va usata con estrema cautela perch\u00e9 ogni chiamata aggiunge un nuovo frame nello stack. Poich\u00e9 lo stack nei microcontrollori \u00e8 tipicamente molto limitato, un uso eccessivo della ricorsione pu\u00f2 portare a stack overflow e comportamenti imprevedibili. In sistemi a risorse limitate, \u00e8 spesso preferibile convertire una ricorsione in un ciclo iterativo.</p> <p>Funzioni variadiche Alcune funzioni in C possono accettare un numero variabile di argomenti. L\u2019esempio pi\u00f9 noto \u00e8 <code>printf</code>. Per implementarle si utilizza la libreria <code>&lt;stdarg.h&gt;</code>, che fornisce i tipi e le macro necessarie per accedere agli argomenti aggiuntivi.</p> <p>Esempio semplificato di funzione che calcola la media di un numero variabile di interi:</p> <pre><code>#include &lt;stdarg.h&gt;\n#include &lt;stdio.h&gt;\n\ndouble media(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    int somma = 0;\n\n    for (int i = 0; i &lt; count; i++) {\n        somma += va_arg(args, int);\n    }\n\n    va_end(args);\n    return (double)somma / count;\n}\n</code></pre> <p>L\u2019uso di funzioni variadiche deve essere ponderato: gli argomenti non hanno un tipo esplicito e un errore nella gestione (ad esempio passare un tipo sbagliato) non viene rilevato dal compilatore.</p> <p>Funzioni inline vs macro Le macro (<code>#define</code>) permettono di definire frammenti di codice riutilizzabili che vengono sostituiti dal preprocessore. Ad esempio:</p> <pre><code>#define QUADRATO(x) ((x) * (x))\n</code></pre> <p>Il problema \u00e8 che le macro non hanno controllo sui tipi e possono introdurre errori difficili da individuare (ad esempio <code>QUADRATO(a+b)</code> si espande in <code>((a+b)*(a+b))</code>, che pu\u00f2 avere effetti collaterali inattesi se <code>x</code> \u00e8 un\u2019espressione con side-effect).</p> <p>Le funzioni <code>inline</code> sono un\u2019alternativa molto pi\u00f9 sicura:</p> <pre><code>inline int quadrato(int x) {\n    return x * x;\n}\n</code></pre> <p>Il compilatore pu\u00f2 sostituire la chiamata con il corpo della funzione (senza overhead di chiamata), mantenendo per\u00f2 il controllo sui tipi e la leggibilit\u00e0. Per questo motivo, in C moderno si preferisce sempre l\u2019uso di funzioni <code>inline</code> rispetto alle macro per operazioni semplici.</p> <p>Uso di <code>const</code> nei parametri La keyword <code>const</code> applicata ai parametri di funzione \u00e8 fondamentale per chiarire le intenzioni e prevenire modifiche indesiderate.</p> <p>Esempio senza <code>const</code>:</p> <pre><code>void stampa_stringa(char *str);\n</code></pre> <p>In questo caso non \u00e8 chiaro se la funzione modifichi o meno il contenuto della stringa.</p> <p>Con <code>const</code>:</p> <pre><code>void stampa_stringa(const char *str);\n</code></pre> <p>Ora il compilatore impedir\u00e0 qualsiasi modifica al contenuto di <code>str</code> all\u2019interno della funzione, e chi legge il codice capisce immediatamente che la funzione si limita a leggere la stringa senza alterarla.</p> <p>L\u2019uso di <code>const</code> \u00e8 particolarmente importante in ambienti embedded, dove la protezione contro modifiche indesiderate alla memoria (ad esempio buffer condivisi o registri di periferiche mappati in memoria) pu\u00f2 prevenire errori difficili da diagnosticare.</p>"},{"location":"codice/lezioni_di_c/puntatori/","title":"Approfondimento sui puntatori","text":"<p>I puntatori sono uno degli strumenti pi\u00f9 potenti e importanti del linguaggio C. Permettono di lavorare direttamente con indirizzi di memoria, rendendo possibile l\u2019accesso efficiente a variabili, array, strutture e periferiche hardware. Anche se li abbiamo introdotti nelle sezioni su variabili e funzioni, vale la pena dedicare un capitolo a parte per chiarire tutti i dettagli e i casi particolari.</p>"},{"location":"codice/lezioni_di_c/puntatori/#cose-un-puntatore","title":"Cos\u2019\u00e8 un puntatore","text":"<p>Quando dichiariamo una variabile, ad esempio <code>int numero = 10;</code>, il processore riserva una cella di memoria (o pi\u00f9 di una, a seconda del tipo di dato) per memorizzare il valore <code>10</code> e associa a questa casella il nome <code>numero</code>. L'indirizzo di questa casella \u00e8 la sua posizione fisica nella memoria.</p> <p>Un puntatore non \u00e8 altro che una variabile speciale il cui valore non \u00e8 un dato come un numero o un carattere, ma l'indirizzo di memoria di un'altra variabile. Invece di contenere il dato stesso, il puntatore \"punta\" alla casella di memoria che contiene quel dato. Dichiarazione:</p> <pre><code>int x = 10;\nint *p = &amp;x; // p contiene l\u2019indirizzo di x\n\nint *puntatore_a_intero;\nchar *puntatore_a_carattere;\nfloat *puntatore_a_float;\n</code></pre> <ul> <li><code>&amp;x</code> \u2192 (<code>&amp;</code> operatore di indirizzo) indirizzo della variabile <code>x</code></li> <li><code>*p</code> \u2192 (<code>*</code> operatore di dereferenziazione o indirezione) valore contenuto all\u2019indirizzo puntato da <code>p</code></li> </ul> <p>\u00c8 importante sottolineare il fatto che in queste variabili sono a tutti gli effetti salvati degli indirizzi di memoria, quindi il tipo di dato contenuto al loro interno \u00e8 un <code>unsigned int</code> che ha la dimensione del bus del processore. Sulle architetture a 32bit sar\u00e0 un <code>uint32</code> mentre in quelle a 64bit sar\u00e0 un <code>uint64</code>. Dichiarare un tipo diverso serve al processore per capire quanto \u00e8 grande il dato contenuto alla cella di memoria a cui si sta puntando e come interpretarlo.</p> <p>Attenzione: </p> <p>Quando si usano i puntatori, a meno che non si sia assolutamente sicuri che abbiano un valore valido, bisogna controllare che non sia nullo e che sia del tipo corretto rispetto al dato a cui si sta puntando. \u00c8 anche possibile assegnare <code>NULL</code> ad un puntatore, ma bisogna stare attenti a come lo si usa.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-e-costanti","title":"Puntatori e costanti","text":"<p>Esistono varie combinazioni di <code>const</code> con i puntatori:</p> <ol> <li>Puntatore a costante: il contenuto non pu\u00f2 essere modificato</li> </ol> <pre><code>const int *p = &amp;x;\n*p = 5; // ERRORE\np = &amp;y; // OK\n</code></pre> <ol> <li>Puntatore costante: il puntatore non pu\u00f2 cambiare, ma il contenuto pu\u00f2</li> </ol> <pre><code>int *const p = &amp;x;\n*p = 5; // OK\np = &amp;y; // ERRORE\n</code></pre> <ol> <li>Puntatore costante a costante: niente pu\u00f2 essere modificato</li> </ol> <pre><code>const int *const p = &amp;x;\n*p = 5; // ERRORE\np = &amp;y; // ERRORE\n</code></pre> <p>Questa distinzione \u00e8 fondamentale in embedded per proteggere buffer o registri di periferica.</p>"},{"location":"codice/lezioni_di_c/puntatori/#aritmetica-dei-puntatori","title":"Aritmetica dei puntatori","text":"<p>I puntatori possono essere incrementati o decrementati, ma l\u2019unit\u00e0 di incremento dipende dal tipo a cui puntano:</p> <pre><code>int a[3] = {10, 20, 30};\nint *p = a;\n\np++;        // ora punta a a[1]\nprintf(\"%d\\n\", *p); // stampa 20\n</code></pre> <p>L\u2019operatore <code>+</code> o <code>-</code> muove il puntatore di un numero di elementi, non di byte. La sottrazione tra puntatori restituisce il numero di elementi tra loro.</p>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-e-array","title":"Puntatori e array","text":"<p>Un array si comporta come un puntatore al primo elemento. Passare un array a una funzione significa passare un puntatore:</p> <pre><code>void stampa(int arr[], int n) {\n    for(int i = 0; i &lt; n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n</code></pre> <p>\u00c8 equivalente a:</p> <pre><code>void stampa(int *arr, int n) { ... }\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-a-struct","title":"Puntatori a struct","text":"<p>Quando si ha una struttura, \u00e8 spesso pi\u00f9 efficiente passare un puntatore:</p> <pre><code>struct Punto {\n    int x;\n    int y;\n};\n\nvoid sposta(struct Punto *p, int dx, int dy) {\n    p-&gt;x += dx;\n    p-&gt;y += dy;\n}\n</code></pre> <ul> <li> <p><code>p-&gt;x</code> \u00e8 equivalente a <code>(*p).x</code></p> </li> <li> <p>I puntatori a struct permettono di risparmiare memoria e tempo di copia.</p> </li> </ul>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-void","title":"Puntatori void","text":"<p><code>void *</code> \u00e8 un puntatore generico, senza tipo. Serve quando vogliamo passare un indirizzo di memoria senza sapere il tipo, ad esempio in buffer generici o callback.</p> <pre><code>void stampa_generico(void *ptr, char tipo) {\n    if(tipo == 'i') printf(\"%d\\n\", *(int *)ptr);\n    if(tipo == 'f') printf(\"%f\\n\", *(float *)ptr);\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#array-di-puntatori-e-puntatori-a-puntatori","title":"Array di puntatori e puntatori a puntatori","text":"<p>\u00c8 possibile avere array di puntatori:</p> <pre><code>char *nomi[] = {\"Mario\", \"Luigi\", \"Peach\"};\n</code></pre> <p>O puntatori a puntatori, utili ad esempio per gestire array dinamici di stringhe:</p> <pre><code>char **strs;\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#puntatori-a-funzioni","title":"Puntatori a funzioni","text":"<p>I puntatori possono memorizzare indirizzi di funzioni, permettendo di chiamarle in modo dinamico. Abbiamo gi\u00e0 visto esempi nel capitolo su funzioni.</p> <p>Esempio riassuntivo:</p> <pre><code>typedef int (*Operazione)(int, int);\n\nint somma(int a, int b) { return a + b; }\n\nOperazione op = somma;\nint risultato = op(3, 4); // richiama somma(3,4)\n</code></pre>"},{"location":"codice/lezioni_di_c/puntatori/#considerazioni-finali","title":"Considerazioni finali","text":"<ul> <li> <p>I puntatori sono essenziali in C embedded per accesso diretto alla memoria, gestione di buffer e interfacciamento con driver.</p> </li> <li> <p>Comprendere <code>const</code>, <code>void *</code>, aritmetica dei puntatori e puntatori a struct/funzioni \u00e8 fondamentale per evitare bug difficili da trovare.</p> </li> <li> <p>Una volta chiari questi concetti, il codice diventa pi\u00f9 modulare, efficiente e sicuro.</p> </li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/","title":"Sintassi base del C","text":"<p>Il linguaggio C \u00e8 alla base dello sviluppo embedded: \u00e8 semplice, efficiente e permette un controllo diretto sull\u2019hardware. In questa sezione vediamo le fondamenta che servono per scrivere e capire il codice della centralina.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#variabili","title":"Variabili","text":"<p>Una variabile \u00e8 uno spazio di memoria a cui diamo un nome e che contiene un valore.</p> <p>\u26a0\ufe0f Nota per l\u2019embedded: \u00c8 sempre consigliato evitare l\u2019allocazione dinamica con funzioni come <code>malloc()</code> o <code>alloca()</code>. Negli ambienti a risorse limitate (come i microcontrollori) queste chiamate possono causare memory leak, frammentazione o corruzione della memoria. Meglio usare variabili globali, statiche o allocate nello stack, che garantiscono maggiore stabilit\u00e0 e prevedibilit\u00e0.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#dichiarazione","title":"Dichiarazione","text":"<pre><code>int numero;        // variabile intera\nfloat temperatura; // variabile con virgola\nchar lettera;      // variabile carattere\n````\n\n### Inizializzazione\n\n```c\nint numero = 10;\nfloat temperatura = 36.5;\nchar lettera = 'A';\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#regole-sui-nomi","title":"Regole sui nomi","text":"<ul> <li>Devono iniziare con lettera o <code>_</code></li> <li>Possono contenere lettere, numeri e <code>_</code></li> <li>Sono case-sensitive (<code>variabile</code> \u2260 <code>Variabile</code>)</li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#tipi-di-dato-principali","title":"Tipi di dato principali","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#interi","title":"Interi","text":"<ul> <li><code>int</code> \u2192 intero base (dimensione dipende dal compilatore, spesso 32 bit)</li> <li><code>short</code> \u2192 intero corto (16 bit)</li> <li><code>long</code> \u2192 intero lungo (32 o 64 bit)</li> <li><code>unsigned</code> \u2192 versione senza segno (solo positivi)</li> </ul> <p>Esempio:</p> <pre><code>int a = -10;\nunsigned int b = 20;\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#numeri-decimali","title":"Numeri decimali","text":"<ul> <li><code>float</code> \u2192 virgola mobile a 32 bit (circa 6-7 cifre decimali)</li> <li><code>double</code> \u2192 virgola mobile a 64 bit (circa 15-16 cifre decimali)</li> </ul> <p>Esempio:</p> <pre><code>float x = 3.14f;\ndouble y = 2.718281828;\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#caratteri","title":"Caratteri","text":"<ul> <li><code>char</code> \u2192 memorizza un singolo carattere (es. 'A', 'b', '1')</li> <li>In realt\u00e0 \u00e8 un numero intero (ASCII)</li> </ul> <pre><code>char c = 'A';  // ASCII 65\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#booleani","title":"Booleani","text":"<p>In C puro non esisteva, ma da C99 si pu\u00f2 usare, bisogna includere la libreria <code>stdbool.h</code>:</p> <pre><code>#include &lt;stdbool.h&gt;\n\nbool flag = true;\n</code></pre> <p>Reminder: C \\(\\ne\\) C++, la libreria standard C \u00e8 definita da file chiamati <code>&lt;libreria&gt;.h</code> e non <code>&lt;libreria&gt;</code> e basta, bisogna mettere il .h </p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#costanti","title":"Costanti","text":"<p>Una costante \u00e8 un valore che non cambia.</p> <pre><code>const float PI = 3.14159;\n#define MAX_VALORE 100\n</code></pre> <ul> <li><code>const</code> \u2192 variabile costante</li> <li><code>#define</code> \u2192 macro gestita dal preprocessore</li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#operatori","title":"Operatori","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#aritmetici","title":"Aritmetici","text":"<pre><code>+   // addizione\n-   // sottrazione\n*   // moltiplicazione\n/   // divisione\n%   // resto (solo interi)\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#relazionali","title":"Relazionali","text":"<pre><code>==  // uguale\n!=  // diverso\n&gt;   // maggiore\n&lt;   // minore\n&gt;=  // maggiore o uguale\n&lt;=  // minore o uguale\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#logici","title":"Logici","text":"<pre><code>&amp;&amp;  // AND logico\n||  // OR logico\n!   // NOT logico\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#operatori-bitwise","title":"Operatori bitwise","text":"<pre><code>&lt;&lt;  // left shift\n&gt;&gt;  // right shift\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori","title":"Puntatori","text":"<p>Un puntatore \u00e8 una variabile che contiene l\u2019indirizzo di memoria di un\u2019altra variabile. Sono fondamentali in C perch\u00e9 permettono di accedere direttamente alla memoria, alle periferiche e ai registri.</p>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#dichiarazione_1","title":"Dichiarazione","text":"<pre><code>int x = 10;\nint *p = &amp;x;   // p contiene l\u2019indirizzo di x\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#utilizzo","title":"Utilizzo","text":"<pre><code>printf(\"Valore di x: %d\\n\", x);   // stampa 10\nprintf(\"Indirizzo di x: %p\\n\", &amp;x);\nprintf(\"Valore tramite puntatore: %d\\n\", *p); // stampa 10\n</code></pre> <ul> <li><code>&amp;x</code> \u2192 indirizzo della variabile <code>x</code></li> <li><code>*p</code> \u2192 valore contenuto all\u2019indirizzo puntato da <code>p</code></li> </ul>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori-e-array","title":"Puntatori e array","text":"<p>Un array \u00e8 strettamente legato ai puntatori.</p> <pre><code>int numeri[3] = {1, 2, 3};\nint *ptr = numeri;\n\nprintf(\"%d\\n\", *ptr);       // 1\nprintf(\"%d\\n\", *(ptr + 1)); // 2\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#puntatori-a-char-e-stringhe","title":"Puntatori a <code>char</code> e stringhe","text":"<p>In C una stringa \u00e8 un array di <code>char</code> terminato da <code>\\0</code>.</p> <pre><code>char saluto[] = \"Ciao\";\nchar *p = saluto;\n\nprintf(\"%s\\n\", p);   // stampa \"Ciao\"\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#tipi-definiti-dallutente","title":"Tipi definiti dall\u2019utente","text":""},{"location":"codice/lezioni_di_c/sintassi_base_c/#struct","title":"<code>struct</code>","text":"<p>Serve per raggruppare variabili diverse in un\u2019unica entit\u00e0.</p> <pre><code>struct Sensore {\n    int id;\n    float valore;\n};\n\nstruct Sensore s1 = {1, 23.5};\n</code></pre>"},{"location":"codice/lezioni_di_c/sintassi_base_c/#typedef","title":"<code>typedef</code>","text":"<p>Permette di creare alias per tipi pi\u00f9 leggibili.</p> <pre><code>typedef unsigned int uint32_t;\n\nuint32_t counter = 100;\n</code></pre>"},{"location":"codice/lezioni_di_c/stdint/","title":"Tipi di <code>stdint.h</code>","text":"<p>In C la dimensione di tipi come <code>int</code>, <code>long</code>, <code>short</code> pu\u00f2 variare a seconda del compilatore e dell\u2019architettura. Per i microcontrollori questo \u00e8 un problema, perch\u00e9 dobbiamo sapere con certezza quanti bit occupa una variabile.</p> <p>Per questo si usa l\u2019header <code>&lt;stdint.h&gt;</code>, che definisce tipi con dimensione fissa.</p>"},{"location":"codice/lezioni_di_c/stdint/#tipi-interi-con-dimensione-precisa","title":"Tipi interi con dimensione precisa","text":"<ul> <li><code>int8_t</code> \u2192 intero con segno a 8 bit (da -128 a 127)  </li> <li><code>uint8_t</code> \u2192 intero senza segno a 8 bit (da 0 a 255)  </li> <li><code>int16_t</code> \u2192 intero con segno a 16 bit  </li> <li><code>uint16_t</code> \u2192 intero senza segno a 16 bit  </li> <li><code>int32_t</code> \u2192 intero con segno a 32 bit  </li> <li><code>uint32_t</code> \u2192 intero senza segno a 32 bit  </li> <li><code>int64_t</code> \u2192 intero con segno a 64 bit  </li> <li><code>uint64_t</code> \u2192 intero senza segno a 64 bit  </li> </ul> <p>Esempio:</p> <pre><code>uint16_t valore = 50000; // sicuro che \u00e8 16 bit senza segno\n````\n\n---\n\n## Tipi minimi e massimi\n\nOltre ai tipi a dimensione fissa, `stdint.h` fornisce anche tipi che garantiscono almeno una certa dimensione:\n\n- `int_least8_t` \u2192 almeno 8 bit con segno\n- `uint_least16_t` \u2192 almeno 16 bit senza segno\n- `int_fast32_t` \u2192 il tipo intero \u201cpi\u00f9 veloce\u201d con almeno 32 bit\n\nQuesti sono meno usati in embedded, ma possono tornare utili se non importa la dimensione esatta, ma solo la minima.\n\n---\n\n## Costanti con dimensione fissa\n\n`stdint.h` definisce anche **macro** per scrivere costanti con la dimensione giusta:\n\n```c\n#include &lt;stdint.h&gt;\n\nuint32_t mask = UINT32_C(0xFFFF0000);\n</code></pre> <p>Cos\u00ec evitiamo warning o errori quando usiamo numeri grandi.</p>"},{"location":"codice/lezioni_di_c/stdint/#buona-pratica","title":"Buona pratica","text":"<p>In un progetto embedded \u00e8 consigliato:</p> <ul> <li>usare sempre i tipi di <code>stdint.h</code> (<code>uint8_t</code>, <code>int32_t</code>, \u2026)</li> <li>evitare i tipi \u201cclassici\u201d (<code>int</code>, <code>long</code>, \u2026) perch\u00e9 non sempre hanno la stessa dimensione tra PC e microcontrollore</li> <li>abbinare <code>stdbool.h</code> e <code>stdint.h</code> per scrivere codice pi\u00f9 leggibile e portabile</li> </ul>"},{"location":"codice/lezioni_di_c/stdint/#confronto-tra-tipi-standard-e-tipi-di-stdinth","title":"Confronto tra tipi standard e tipi di <code>stdint.h</code>","text":"Tipo classico Dimensione (dipende da architettura) Possibili valori Equivalente <code>stdint.h</code> (fisso) <code>char</code> 8 bit (di solito) -128 \u2026 127 / 0 \u2026 255 <code>int8_t</code> / <code>uint8_t</code> <code>short</code> almeno 16 bit (spesso 16) -32.768 \u2026 32.767 <code>int16_t</code> <code>unsigned short</code> almeno 16 bit (spesso 16) 0 \u2026 65.535 <code>uint16_t</code> <code>int</code> almeno 16 bit (spesso 32 su ARM) dipende da piattaforma <code>int32_t</code> (se serve 32 bit certi) <code>unsigned int</code> almeno 16 bit (spesso 32) dipende da piattaforma <code>uint32_t</code> <code>long</code> almeno 32 bit (pu\u00f2 essere 32 o 64) dipende da compilatore <code>int32_t</code> o <code>int64_t</code> <code>unsigned long</code> almeno 32 bit (pu\u00f2 essere 32 o 64) dipende da compilatore <code>uint32_t</code> o <code>uint64_t</code>"},{"location":"codice/lezioni_di_c/stdint/#perche-e-importante","title":"Perch\u00e9 \u00e8 importante?","text":"<p>Su un PC a 64 bit: - <code>int</code> \u00e8 spesso 32 bit. - <code>long</code> \u00e8 64 bit (Linux) o 32 bit (Windows).  </p> <p>Su un microcontrollore ARM Cortex-M: - <code>int</code> \u00e8 quasi sempre 32 bit. - <code>long</code> \u00e8 32 bit (non 64!).  </p> <p>Quindi lo stesso codice scritto con <code>int</code> e <code>long</code> pu\u00f2 comportarsi in modo diverso a seconda di dove gira. Con <code>stdint.h</code> questo problema non esiste: la dimensione \u00e8 sempre quella dichiarata.</p>"},{"location":"codice/lezioni_di_c/strutture_base/","title":"Strutture dati minime","text":"<p>Nel linguaggio C le strutture dati fondamentali che si usano quasi ovunque sono gli array, le struct e le enum. Conoscerle a fondo \u00e8 essenziale per scrivere codice chiaro, efficiente e comprensibile.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#array","title":"Array","text":"<p>Un array \u00e8 una sequenza di elementi dello stesso tipo, memorizzati in celle di memoria contigue. Quando si dichiara un array, si deve indicare il tipo degli elementi e la dimensione:</p> <pre><code>int valori[10]; // array di 10 interi\n````\n\nQuesto significa che la variabile `valori` contiene 10 interi, indicizzati da `0` a `9`. L\u2019indice deve sempre essere compreso tra 0 e dimensione-1. Accedere a un indice fuori dai limiti produce un comportamento indefinito, cio\u00e8 errori difficili da individuare.\n\nGli array possono essere **inizializzati**:\n\n```c\nint a[5] = {1, 2, 3, 4, 5};\nint b[5] = {0}; // tutti inizializzati a zero\n</code></pre> <p>Se si forniscono meno valori rispetto alla dimensione, i restanti vengono messi a zero. \u00c8 possibile anche lasciare vuota la dimensione quando i valori sono noti a compilazione:</p> <pre><code>int c[] = {10, 20, 30}; // dimensione 3 dedotta dal compilatore\n</code></pre> <p>Gli array di caratteri sono spesso usati per rappresentare stringhe terminate dal carattere nullo <code>'\\0'</code>:</p> <pre><code>char nome[10] = \"ciao\"; // occuper\u00e0 5 celle: 'c','i','a','o','\\0'\n</code></pre> <p>Negli ambienti embedded gli array vengono utilizzati anche come buffer per la comunicazione (es. pacchetti CAN, UART). In questi casi \u00e8 fondamentale rispettare sempre la dimensione massima per evitare corruzione di memoria.</p> <p>Un array in C si comporta quasi sempre come un puntatore al suo primo elemento. Questo significa che se passo un array a una funzione, in realt\u00e0 passo l\u2019indirizzo della prima cella, non una copia dell\u2019intero array:</p> <pre><code>void stampa(int arr[], int n) {\n    for(int i = 0; i &lt; n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/strutture_base/#struct","title":"Struct","text":"<p>Una <code>struct</code> \u00e8 una struttura che permette di raggruppare variabili di tipi diversi sotto un unico nome. \u00c8 molto utile per rappresentare entit\u00e0 complesse:</p> <pre><code>struct Punto {\n    int x;\n    int y;\n};\n</code></pre> <p>Ora \u00e8 possibile dichiarare variabili di questo tipo:</p> <pre><code>struct Punto p1 = {10, 20};\n</code></pre> <p>Ogni campo si accede con l\u2019operatore <code>.</code>:</p> <pre><code>printf(\"%d\", p1.x);\n</code></pre> <p>Le struct possono contenere anche array o altre struct:</p> <pre><code>struct Rettangolo {\n    struct Punto vertici[4];\n};\n</code></pre> <p>Quando si lavora con puntatori a struct, si usa l\u2019operatore <code>-&gt;</code>:</p> <pre><code>struct Punto *pp = &amp;p1;\npp-&gt;x = 5; // equivalente a (*pp).x\n</code></pre> <p>\u00c8 possibile usare <code>typedef</code> per evitare di scrivere ogni volta <code>struct</code>:</p> <pre><code>typedef struct {\n    int x;\n    int y;\n} Punto;\n\nPunto p2 = {3, 4};\n</code></pre> <p>In embedded le struct sono spesso usate per definire i registri delle periferiche. In questo caso \u00e8 importante considerare il padding: il compilatore pu\u00f2 inserire byte di allineamento tra i campi per rispettare i vincoli dell\u2019architettura. Questo significa che due struct con gli stessi campi ma ordine diverso possono avere dimensioni diverse. Per controllare queste situazioni si usano attributi come <code>__attribute__((packed))</code> o le opzioni del compilatore.</p> <p>Le struct possono anche essere annidate e usate come contenitori per dati condivisi tra task in un sistema operativo real-time. \u00c8 una buona pratica abbinarle a mutex o code quando pi\u00f9 parti del programma devono accedere alle stesse informazioni.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#enum","title":"Enum","text":"<p>Una <code>enum</code> definisce un insieme di valori simbolici associati a numeri interi. \u00c8 utile per rendere pi\u00f9 leggibile il codice e per rappresentare stati, modalit\u00e0 o codici di errore.</p> <pre><code>enum Stato {\n    IDLE,\n    RUN,\n    ERROR\n};\n</code></pre> <p>Di default il primo valore parte da 0 e gli altri crescono di 1. Nell\u2019esempio, <code>IDLE = 0</code>, <code>RUN = 1</code>, <code>ERROR = 2</code>. \u00c8 possibile assegnare valori arbitrari:</p> <pre><code>enum Comando {\n    START = 10,\n    STOP = 20,\n    RESET = 30\n};\n</code></pre> <p>\u00c8 consigliato usare <code>typedef</code> per semplificare:</p> <pre><code>typedef enum {\n    LED_OFF = 0,\n    LED_ON = 1\n} LedState;\n</code></pre> <p>Le enum migliorano la leggibilit\u00e0:</p> <pre><code>LedState stato = LED_OFF;\n\nif (stato == LED_ON) {\n    // accendi il LED\n}\n</code></pre> <p>In embedded le enum sono molto utili per definire le macchine a stati finiti. Ogni stato della FSM corrisponde a un valore della enum, rendendo il codice pi\u00f9 chiaro e meno soggetto a errori rispetto all\u2019uso di costanti numeriche.</p>"},{"location":"codice/lezioni_di_c/strutture_base/#union","title":"Union","text":"<p>Una <code>union</code> \u00e8 simile a una <code>struct</code>, ma con una differenza fondamentale: tutti i campi condividono lo stesso spazio di memoria. Questo significa che una union occupa tanta memoria quanta ne richiede il campo pi\u00f9 grande, e tutti i membri si sovrappongono.</p> <p>Esempio di dichiarazione:</p> <pre><code>union Valore {\n    uint32_t intero;\n    float reale;\n    uint8_t byte[4];\n};\n````\n\nIn questo caso `union Valore` occupa 4 byte, perch\u00e9 il campo pi\u00f9 grande (`uint32_t` e `float`) \u00e8 di 4 byte.  \nSe assegniamo un valore a `intero`, possiamo leggere la sua rappresentazione binaria attraverso l\u2019array `byte`:\n\n```c\nunion Valore v;\nv.intero = 0x12345678;\n\nprintf(\"%02X %02X %02X %02X\\n\", v.byte[0], v.byte[1], v.byte[2], v.byte[3]);\n</code></pre> <p>Il risultato dipender\u00e0 dall\u2019endianness del processore (little endian o big endian), perch\u00e9 determina l\u2019ordine dei byte in memoria.</p> <p>Le union sono molto potenti, ma bisogna usarle con attenzione: scrivere in un campo e leggere da un altro non sempre \u00e8 portabile al 100% secondo lo standard C, anche se in pratica nei sistemi embedded \u00e8 una tecnica comune.</p> <p>Esempi di utilizzo tipico nelle applicazioni embedded:</p> <ul> <li>Interpretare un pacchetto ricevuto su bus di comunicazione sia come array di byte che come valori numerici.</li> <li>Definire registri hardware in modo che un singolo registro possa essere letto intero oppure per campi pi\u00f9 piccoli.</li> <li>Effettuare \u201ctype punning\u201d (riutilizzare lo stesso blocco di memoria come tipi diversi) per ridurre l\u2019uso di memoria.</li> </ul> <p>Differenze rispetto a struct:</p> <ul> <li>In una <code>struct</code> ogni campo ha il suo spazio separato, e la dimensione totale \u00e8 almeno la somma delle dimensioni dei campi (pi\u00f9 eventuale padding).</li> <li>In una <code>union</code> tutti i campi condividono lo stesso spazio, e la dimensione totale \u00e8 uguale a quella del campo pi\u00f9 grande.</li> </ul>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/","title":"Visibilit\u00e0 e organizzazione del codice in C","text":"<p>Oltre a sapere cos\u2019\u00e8 una variabile, \u00e8 fondamentale capire dove \u00e8 visibile e come organizzare i file in un progetto embedded.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#file-c-e-h","title":"File <code>.c</code> e <code>.h</code>","text":"<p>In un progetto in C i file sono generalmente divisi in due categorie:</p> <ul> <li>File <code>.c</code> \u2192 contengono il codice implementativo (funzioni, logica).  </li> <li>File <code>.h</code> \u2192 contengono le dichiarazioni (prototipi di funzioni, definizioni di strutture, costanti, variabili globali).  </li> </ul>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#esempio","title":"Esempio","text":"<p>sensore.h</p> <pre><code>#ifndef SENSORE_H\n#define SENSORE_H\n\nvoid sensore_init(void);\nint sensore_leggi(void);\n\n#endif\n````\n\n**sensore.c**\n\n```c\n#include \"sensore.h\"\n\nvoid sensore_init(void) {\n    // inizializzazione hardware\n}\n\nint sensore_leggi(void) {\n    return 42; // valore di esempio\n}\n</code></pre> <p>Cos\u00ec il modulo <code>sensore</code> pu\u00f2 essere usato anche da altri file senza duplicare il codice.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#visibilita-delle-variabili","title":"Visibilit\u00e0 delle variabili","text":"<p>La visibilit\u00e0 definisce in quali file o funzioni una variabile \u00e8 accessibile.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#variabili-locali","title":"Variabili locali","text":"<p>Dichiarate dentro una funzione \u2192 visibili solo l\u00ec, allocate nello stack.</p> <pre><code>void funzione() {\n    int x = 10; // visibile solo dentro questa funzione\n}\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#variabili-globali","title":"Variabili globali","text":"<p>Dichiarate fuori da ogni funzione \u2192 visibili in tutto il file <code>.c</code>.</p> <pre><code>int contatore = 0; // visibile in tutto il file\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#cose-extern","title":"Cos\u2019\u00e8 extern","text":"<p>La keyword <code>extern</code> in C serve a dichiarare una variabile o funzione definita in un altro file, cos\u00ec che il compilatore sappia che esiste e che verr\u00e0 risolta in fase di linking.</p> <p>In pratica:</p> <ul> <li><code>dichiarazione</code> = dire \u201cquesta variabile/funzione esiste da qualche parte\u201d.</li> <li><code>definizione</code> = riservare davvero memoria o scrivere il codice.</li> </ul> <p><code>extern</code> riguarda solo le variabili globali (anche se si pu\u00f2 usare pure con funzioni, ma l\u00ec \u00e8 implicito).</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#senza-extern-definizione","title":"Senza <code>extern</code> (definizione)","text":"<p>Se scrivi:</p> <pre><code>int counter = 0;\n</code></pre> <p>questa \u00e8 una definizione: il compilatore alloca spazio in memoria per <code>counter</code>.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#con-extern-dichiarazione","title":"Con <code>extern</code> (dichiarazione)","text":"<p>Se scrivi:</p> <pre><code>extern int counter;\n</code></pre> <p>questa \u00e8 solo una dichiarazione: non alloca memoria, dice solo \u201cda qualche parte esiste un <code>int counter</code>\u201d. In questo modo puoi usare <code>counter</code> anche in un file diverso da quello in cui \u00e8 stato definito.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#esempio-pratico-con-piu-file","title":"Esempio pratico con pi\u00f9 file","text":"<p>file1.c</p> <pre><code>#include &lt;stdio.h&gt;\n\nint counter = 42;   // definizione (memoria allocata qui)\n\nvoid printCounter(void) {\n    printf(\"counter = %d\\n\", counter);\n}\n</code></pre> <p>file2.c</p> <pre><code>#include &lt;stdio.h&gt;\n\nextern int counter;  // dichiarazione (nessuna memoria allocata)\n\nvoid increment(void) {\n    counter++;\n}\n</code></pre> <p>main.c</p> <pre><code>void printCounter(void);\nvoid increment(void);\n\nint main(void) {\n    printCounter();  // counter = 42\n    increment();\n    printCounter();  // counter = 43\n    return 0;\n}\n</code></pre> <p>Compilando tutti e tre insieme funziona perch\u00e9 il linker trova <code>counter</code> definito in <code>file1.c</code>:</p> <pre><code>gcc file1.c file2.c main.c -o program\n</code></pre>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#casi-tipici-in-embedded","title":"Casi tipici in Embedded","text":"<p>Noi <code>extern</code> lo usiamo per:</p> <ul> <li>Variabili globali condivise tra pi\u00f9 moduli (es. uno stato della macchina, un buffer CAN, una coda FreeRTOS).</li> <li>Funzioni scritte in un file ma richiamate da altri, anche se l\u00ec l\u2019<code>extern</code> \u00e8 implicito.</li> <li>Header file: metti <code>extern</code> l\u00ec, la definizione vera sta nel <code>.c</code>.</li> </ul> <p>Esempio:</p> <pre><code>// uart.h\n#ifndef UART_H\n#define UART_H\n\nextern QueueHandle_t uartQueue;   // dichiarazione, visibile a tutti i .c\n\nvoid UART_Init(void);\n\n#endif\n</code></pre> <pre><code>// uart.c\n#include \"uart.h\"\n\nQueueHandle_t uartQueue;          // definizione vera (memoria allocata qui)\n\nvoid UART_Init(void) {\n    uartQueue = xQueueCreate(10, sizeof(uint8_t));\n}\n</code></pre> <p>Cos\u00ec ogni modulo che include <code>uart.h</code> sa che esiste <code>uartQueue</code>, ma la memoria viene allocata una volta sola in <code>uart.c</code>.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#il-ruolo-di-static","title":"Il ruolo di <code>static</code>","text":"<p>La parola chiave <code>static</code> ha due significati diversi a seconda del contesto. Il primo caso sono le variabili locali statiche, che mantengono il loro valore tra pi\u00f9 chiamate della funzione.</p> <pre><code>void funzione() {\n    static int chiamate = 0;\n    chiamate++;\n    printf(\"%d\\n\", chiamate);\n}\n</code></pre> <p>Ogni volta che chiamo <code>funzione()</code>, la variabile non si azzera ma \u201cricorda\u201d il valore precedente. il secondo caso sono le variabili e funzioni a livello di file, che limitano la visibilit\u00e0 al solo file <code>.c</code> (non esportate).</p> <pre><code>static int interno = 5;\n\nstatic void helper() {\n    // usata solo in questo file\n}\n</code></pre> <p>Questo \u00e8 molto utile per l\u2019incapsulamento, evitando che variabili o funzioni \u201cinterne\u201d inquinino lo spazio globale del progetto.</p>"},{"location":"codice/lezioni_di_c/visibilit%C3%A0_delle_variabili/#buone-pratiche","title":"Buone pratiche","text":"<ul> <li>Le variabili devono essere il pi\u00f9 locali possibile.</li> <li>Le globali vanno usate solo se davvero necessarie.</li> <li>Usare <code>static</code> per tutto ci\u00f2 che \u00e8 interno a un modulo (<code>.c</code>).</li> <li>Negli header <code>.h</code> mettere solo:<ul> <li>prototipi delle funzioni pubbliche,</li> <li>definizioni di costanti/struct/enum,</li> <li>dichiarazioni <code>extern</code> se serve condividere una variabile globale.</li> </ul> </li> </ul> <p>Cos\u00ec il progetto rimane ordinato, modulare e pi\u00f9 facile da manutenere.</p>"}]}